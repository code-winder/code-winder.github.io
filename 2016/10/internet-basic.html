<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="计算机网络基础" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="计算机网络是计算机技术和通信技术的深度结合，本博客将从通信技术的角度和设计层面以及居高临下的视角对计算机网络进行 深度讲解。计算机网络除了利用物理性质和数学编码实现了二进制数字信号和对不同二进制组合进行不同的解读外，剩下就是 标准制定的问题了，换句话说，就是设计层面的问题，也是逻辑设定的问题。本文只是基础章节，不涉及到过多细节，但会尽量 从宏观视野出发以在迷路过程中充当指南针的角色。" /><meta property="og:description" content="计算机网络是计算机技术和通信技术的深度结合，本博客将从通信技术的角度和设计层面以及居高临下的视角对计算机网络进行 深度讲解。计算机网络除了利用物理性质和数学编码实现了二进制数字信号和对不同二进制组合进行不同的解读外，剩下就是 标准制定的问题了，换句话说，就是设计层面的问题，也是逻辑设定的问题。本文只是基础章节，不涉及到过多细节，但会尽量 从宏观视野出发以在迷路过程中充当指南针的角色。" /><link rel="canonical" href="//code-winder.github.io/2016/10/internet-basic.html" /><meta property="og:url" content="//code-winder.github.io/2016/10/internet-basic.html" /><meta property="og:site_name" content="Code-Winder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-10-11T01:01:18+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络基础" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-10-11T01:01:18+08:00","datePublished":"2016-10-11T01:01:18+08:00","description":"计算机网络是计算机技术和通信技术的深度结合，本博客将从通信技术的角度和设计层面以及居高临下的视角对计算机网络进行 深度讲解。计算机网络除了利用物理性质和数学编码实现了二进制数字信号和对不同二进制组合进行不同的解读外，剩下就是 标准制定的问题了，换句话说，就是设计层面的问题，也是逻辑设定的问题。本文只是基础章节，不涉及到过多细节，但会尽量 从宏观视野出发以在迷路过程中充当指南针的角色。","headline":"计算机网络基础","mainEntityOfPage":{"@type":"WebPage","@id":"//code-winder.github.io/2016/10/internet-basic.html"},"url":"//code-winder.github.io/2016/10/internet-basic.html"}</script><title>计算机网络基础 | Code-Winder</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Code-Winder"><meta name="application-name" content="Code-Winder"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script> <script> // 百度统计代码 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e37ebacf05386ebe11672ab0dc609b69"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script> // google analytics (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '{site.google_analytics_id}}', 'auto'); ga('send', 'pageview'); </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/favicons/favicon.ico" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Code-Winder</a></div><div class="site-subtitle font-italic">灵感源于好奇</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/code-winder" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['414834682','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <i class="fas fa-list-alt fa-fw" id="content-list"></i> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>计算机网络基础</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >X</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 class="title_class" data-toc-skip>计算机网络基础</h1><div id="label_center"><div class="label"><div class="label-card"></div><div class="label-card"> <span class="categories"> <i class="fa fa-th-list"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88" title="Category: 计算机综合" rel="category">计算机综合</a> </span></div><div class="label-card"> <span class="pageTag"> <i class="fa fa-tags"></i> <a href="/tags/it-basic" title="Tag: IT_Basic" rel="tag">IT_Basic</a> </span></div></div></div><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1476118878" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2016/10/11 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/code-winder">code-winder</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="66891 字"> <em>371 分钟</em>阅读</span></div></div></div><div class="post-content"><blockquote><p>计算机网络是计算机技术和通信技术的深度结合，本博客将从通信技术的角度和设计层面以及居高临下的视角对计算机网络进行 深度讲解。计算机网络除了利用物理性质和数学编码实现了二进制数字信号和对不同二进制组合进行不同的解读外，剩下就是 标准制定的问题了，换句话说，就是设计层面的问题，也是逻辑设定的问题。本文只是基础章节，不涉及到过多细节，但会尽量 从宏观视野出发以在迷路过程中充当指南针的角色。</p></blockquote><ul id="markdown-toc"><li><a href="#计算机网络概述" id="markdown-toc-计算机网络概述">计算机网络概述</a><ul><li><a href="#计算机网络分类" id="markdown-toc-计算机网络分类">计算机网络分类</a><li><a href="#计算机网络元素" id="markdown-toc-计算机网络元素">计算机网络元素</a><ul><li><a href="#网络节点" id="markdown-toc-网络节点">网络节点</a><li><a href="#传输链路" id="markdown-toc-传输链路">传输链路</a><li><a href="#协议" id="markdown-toc-协议">协议</a></ul></ul><li><a href="#计算机网络体系结构" id="markdown-toc-计算机网络体系结构">计算机网络体系结构</a><ul><li><a href="#层的划分" id="markdown-toc-层的划分">层的划分</a><ul><li><a href="#五层协议的体系结构" id="markdown-toc-五层协议的体系结构">五层协议的体系结构</a><li><a href="#分层模型中基本概念" id="markdown-toc-分层模型中基本概念">分层模型中基本概念</a></ul></ul><li><a href="#物理层" id="markdown-toc-物理层">物理层</a><ul><li><a href="#通信基础基础" id="markdown-toc-通信基础基础">通信基础基础</a><ul><li><a href="#有关信道的基本概念" id="markdown-toc-有关信道的基本概念">有关信道的基本概念</a></ul><li><a href="#数字数据的数字传输" id="markdown-toc-数字数据的数字传输">数字数据的数字传输</a><ul><li><a href="#基带传输" id="markdown-toc-基带传输">基带传输</a><li><a href="#频带传输" id="markdown-toc-频带传输">频带传输</a></ul><li><a href="#模拟数据的数字传输" id="markdown-toc-模拟数据的数字传输">模拟数据的数字传输</a><li><a href="#数据同步方式" id="markdown-toc-数据同步方式">数据同步方式</a><li><a href="#信道的多路复用技术" id="markdown-toc-信道的多路复用技术">信道的多路复用技术</a><li><a href="#宽带接入技术" id="markdown-toc-宽带接入技术">宽带接入技术</a></ul><li><a href="#数据链路层" id="markdown-toc-数据链路层">数据链路层</a><ul><li><a href="#基本概念" id="markdown-toc-基本概念">基本概念</a><li><a href="#链路层协议" id="markdown-toc-链路层协议">链路层协议</a><ul><li><a href="#三个基本问题" id="markdown-toc-三个基本问题">三个基本问题</a><li><a href="#比特差错检测方法" id="markdown-toc-比特差错检测方法">比特差错检测方法</a><li><a href="#ppp-协议" id="markdown-toc-ppp-协议">PPP 协议</a><li><a href="#使用广播信道的数据链路层" id="markdown-toc-使用广播信道的数据链路层">使用广播信道的数据链路层</a><li><a href="#csmacd-协议" id="markdown-toc-csmacd-协议">CSMA/CD 协议</a></ul></ul><li><a href="#以太网" id="markdown-toc-以太网">以太网</a><ul><li><a href="#以太网的信道利用率" id="markdown-toc-以太网的信道利用率">以太网的信道利用率</a><li><a href="#以太网的-mac-层" id="markdown-toc-以太网的-mac-层">以太网的 MAC 层</a><li><a href="#mac-帧的格式" id="markdown-toc-mac-帧的格式">MAC 帧的格式</a><li><a href="#扩展以太网" id="markdown-toc-扩展以太网">扩展以太网</a><ul><li><a href="#在物理层拓展以太网" id="markdown-toc-在物理层拓展以太网">在物理层拓展以太网</a><li><a href="#在数据链路层扩展以太网" id="markdown-toc-在数据链路层扩展以太网">在数据链路层扩展以太网</a><li><a href="#虚拟局域网" id="markdown-toc-虚拟局域网">虚拟局域网</a></ul><li><a href="#无线局域网" id="markdown-toc-无线局域网">无线局域网</a></ul><li><a href="#网络层" id="markdown-toc-网络层">网络层</a><ul><li><a href="#网络层提供的两种服务" id="markdown-toc-网络层提供的两种服务">网络层提供的两种服务</a><ul><li><a href="#虚电路" id="markdown-toc-虚电路">虚电路</a><li><a href="#无连接的数据报服务" id="markdown-toc-无连接的数据报服务">无连接的数据报服务</a></ul><li><a href="#网际协议-ip" id="markdown-toc-网际协议-ip">网际协议 IP</a><ul><li><a href="#分类的-ip-地址" id="markdown-toc-分类的-ip-地址">分类的 IP 地址</a><li><a href="#划分子网" id="markdown-toc-划分子网">划分子网</a><li><a href="#构造超网" id="markdown-toc-构造超网">构造超网</a></ul><li><a href="#ip-地址与硬件地址的联系" id="markdown-toc-ip-地址与硬件地址的联系">IP 地址与硬件地址的联系</a><ul><li><a href="#arp-和-rarp" id="markdown-toc-arp-和-rarp">ARP 和 RARP</a></ul><li><a href="#ip-数据报格式" id="markdown-toc-ip-数据报格式">IP 数据报格式</a><li><a href="#ip-层转发分组的流程" id="markdown-toc-ip-层转发分组的流程">IP 层转发分组的流程</a><li><a href="#icmp-协议" id="markdown-toc-icmp-协议">ICMP 协议</a><ul><li><a href="#icmp-报文的种类" id="markdown-toc-icmp-报文的种类">ICMP 报文的种类</a></ul><li><a href="#路由选择协议" id="markdown-toc-路由选择协议">路由选择协议</a><ul><li><a href="#分层次的路由选择协议" id="markdown-toc-分层次的路由选择协议">分层次的路由选择协议</a></ul><li><a href="#路由选择算法的理论基础" id="markdown-toc-路由选择算法的理论基础">路由选择算法的理论基础</a><ul><li><a href="#优化原则" id="markdown-toc-优化原则">优化原则</a><li><a href="#最短路径" id="markdown-toc-最短路径">最短路径</a><li><a href="#泛洪算法" id="markdown-toc-泛洪算法">泛洪算法</a></ul><li><a href="#内部网关协议-rip" id="markdown-toc-内部网关协议-rip">内部网关协议 RIP</a><ul><li><a href="#rip-特点" id="markdown-toc-rip-特点">RIP 特点</a><li><a href="#距离向量算法" id="markdown-toc-距离向量算法">距离向量算法</a><li><a href="#rip-协议的报文格式" id="markdown-toc-rip-协议的报文格式">RIP 协议的报文格式</a></ul><li><a href="#内部网关协议-ospf" id="markdown-toc-内部网关协议-ospf">内部网关协议 OSPF</a><ul><li><a href="#ospf-算法" id="markdown-toc-ospf-算法">OSPF 算法</a><li><a href="#ospf-与-rip-的对比" id="markdown-toc-ospf-与-rip-的对比">OSPF 与 RIP 的对比：</a><li><a href="#ospf-报文格式" id="markdown-toc-ospf-报文格式">OSPF 报文格式</a></ul><li><a href="#外部网关协议-bgp" id="markdown-toc-外部网关协议-bgp">外部网关协议 BGP</a><li><a href="#路由器" id="markdown-toc-路由器">路由器</a><li><a href="#广播路由" id="markdown-toc-广播路由">广播路由</a><ul><li><a href="#无控制洪泛" id="markdown-toc-无控制洪泛">无控制洪泛</a><li><a href="#受控洪泛" id="markdown-toc-受控洪泛">受控洪泛</a><li><a href="#生成树广播" id="markdown-toc-生成树广播">生成树广播</a></ul><li><a href="#ip-多播组播" id="markdown-toc-ip-多播组播">IP 多播（组播）</a><ul><li><a href="#硬件多播" id="markdown-toc-硬件多播">硬件多播</a><li><a href="#igmp-和多播路由" id="markdown-toc-igmp-和多播路由">IGMP 和多播路由</a><li><a href="#多播路由选择协议" id="markdown-toc-多播路由选择协议">多播路由选择协议</a></ul><li><a href="#虚拟专用网-vpn" id="markdown-toc-虚拟专用网-vpn">虚拟专用网 VPN</a><li><a href="#网络地址转换-nat" id="markdown-toc-网络地址转换-nat">网络地址转换 NAT</a></ul><li><a href="#传输层" id="markdown-toc-传输层">传输层</a><ul><li><a href="#传输层概述" id="markdown-toc-传输层概述">传输层概述</a><li><a href="#传输协议概述" id="markdown-toc-传输协议概述">传输协议概述</a><li><a href="#udp" id="markdown-toc-udp">UDP</a><li><a href="#可靠传输的工作原理" id="markdown-toc-可靠传输的工作原理">可靠传输的工作原理</a><ul><li><a href="#停止-等待协议" id="markdown-toc-停止-等待协议">停止-等待协议</a><li><a href="#连续-arq-协议" id="markdown-toc-连续-arq-协议">连续 ARQ 协议</a></ul><li><a href="#tcp" id="markdown-toc-tcp">TCP</a><ul><li><a href="#tcp-首部格式" id="markdown-toc-tcp-首部格式">TCP 首部格式</a><li><a href="#tcp-可靠传输的实现" id="markdown-toc-tcp-可靠传输的实现">TCP 可靠传输的实现</a><li><a href="#必须考虑传输效率" id="markdown-toc-必须考虑传输效率">必须考虑传输效率</a></ul><li><a href="#tcp-的拥塞控制" id="markdown-toc-tcp-的拥塞控制">TCP 的拥塞控制</a><ul><li><a href="#慢开始和拥塞避免" id="markdown-toc-慢开始和拥塞避免">慢开始和拥塞避免</a><li><a href="#随机早期检测-red" id="markdown-toc-随机早期检测-red">随机早期检测 RED</a></ul><li><a href="#tcp-的运输连接管理" id="markdown-toc-tcp-的运输连接管理">TCP 的运输连接管理</a><ul><li><a href="#tcp-的链接建立" id="markdown-toc-tcp-的链接建立">TCP 的链接建立</a><li><a href="#tcp-的连接释放" id="markdown-toc-tcp-的连接释放">TCP 的连接释放</a><li><a href="#tcp-的有限状态机" id="markdown-toc-tcp-的有限状态机">TCP 的有限状态机</a></ul></ul><li><a href="#应用层" id="markdown-toc-应用层">应用层</a><ul><li><a href="#域名系统-dns" id="markdown-toc-域名系统-dns">域名系统 DNS</a><ul><li><a href="#dns-名字空间" id="markdown-toc-dns-名字空间">DNS 名字空间</a><li><a href="#域名服务器" id="markdown-toc-域名服务器">域名服务器</a><li><a href="#域名解析过程" id="markdown-toc-域名解析过程">域名解析过程</a></ul><li><a href="#文件传送协议-ftp" id="markdown-toc-文件传送协议-ftp">文件传送协议 FTP</a><li><a href="#远程终端协议-telnet" id="markdown-toc-远程终端协议-telnet">远程终端协议 TELNET</a></ul></ul><h1 id="计算机网络概述">计算机网络概述</h1><p>计算机网络是计算机技术与通信技术相集合的产物，或者说是用通信介质将多台计算机连接起来所形成的计算机系统。这里的 连接有两重含义：</p><ul><li>通过传输介质和传输设备建立的物理上的连接；<li>由一些网络软件实现的逻辑上的连接。</ul><p>之所以要进行连接，是为了实现下列功能：</p><ul><li>通信：计算机间的数据传送。<li>资源共享：即实现计算机硬件、软件资源和信息资源的异地互用。<li>提高计算机系统的可靠性：在计算机网络中各台计算机网络中各台计算机间可以互为后备，从而提高了计算机系统的可靠性。</ul><h2 id="计算机网络分类"><span class="mr-2">计算机网络分类</span><a href="#计算机网络分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>计算机网络是一种复杂的系统。可以从不同的角度对计算机网络进行分类。</p><blockquote><p>按拓扑结构分类</p></blockquote><p>从拓扑学的观点，网络是由一组节点（node）和连接节点的链路（link）组成。在计算机网络中，计算机作为节点， 连接计算机的通信线路作为链路，形成计算机的地理分布和互连关系上的几何排序（几何构形）。这种计算机与链路之间的拓扑关系， 称为计算机网络的拓扑结构。计算机网络的拓扑结构有许多种。但是，按照网络中一条链路所能连接的计算机的台数， 可以把计算机网络归结为两大类：链路型网络（点到点的结构）和广播型网络（多点共享链路结构）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>（１）链路型网络（点到点的结构）
</pre></table></code></div></div><p>在点到点的结构中，一条链路只能连接两个节点。这样，两点之间要么直接通信，要么必须通过中间节点转发。</p><ul><li>星型结构：</ul><p>其拓扑特点是，中央节点与多条链路连接，其余节点只与一条链路连接。</p><p>由于各外围节点分别用线缆与中央节点直接连接，因而在星型结构中数据的传输不会在线路上发生碰撞，并且系统比较容易扩充， 但中央节点会成为系统的“瓶颈”和可靠工作的最薄弱环节。</p><ul><li>树型结构</ul><p>树型结构的特点是网络中有多个中心节点，但主要的数据流通是在网络的各分支之间进行，形成一种分级管理的集中式网络， 适宜于各种管理部门进行分级数据传送的场合。其拓扑特点是，多个中心节点与多条链路连接， 其余节点（末端节点）只与一条链路连接。</p><p>树型结构的优点是连接容易、管理简单、维护方便，缺点是共享能力差、可靠性低。</p><ul><li>环型结构</ul><p>其拓扑特点是，每一个节点都与两条链路连接。在这种结构中，任意两点之间形成两条路径，当某一链路有故障时， 还可以通过另一条路径进行通信。</p><ul><li>格状结构</ul><p>格状结构是所有节点具有两个或两个以上直接通路的拓扑结构。</p><ul><li>全互连结构</ul><p>全互连结构是所有节点之间都有直接通路的拓扑结构。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-01.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-01.PNG" alt="点对点网络分类" class="lazyload" data-proofer-ignore></a></p><p>格状结构和全互连结构也称网状结构，具有较高的可靠性，但网络结构复杂，链路多，投资大。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>(２）广播型网络
</pre></table></code></div></div><p>广播型网络的特点是，通信线路为多个节点共享。这样，一个节点发送的信息可以传输到其他所有的节点； 而当有两个以上节点同时发送信息时，便会引起冲突。总线型结构是一种应用最普遍的广播型网络拓扑结构。</p><p>在总线型结构中各个计算机网络节点的设备用一根总线挂接起来。总线型结构目前在局域网中应用很广，有如下一些特点：</p><ul><li>节点的插入或拆卸方便，易于扩充；<li>不需要中央控制器，有利于分布式控制，某个节点发生故障时对整个系统影响很小，网络的可靠性高；<li>总线自身的故障对系统是毁灭性的，因而要求较高的安装质量。</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-02.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-02.PNG" alt="广播式网络分类" class="lazyload" data-proofer-ignore></a></p><blockquote><p>按覆盖地域分类</p></blockquote><p>网络按照其覆盖地域的大小可以分为微微网（Piconet，使用蓝牙技术）、个人局域网（PAN，Personal Area Network，使用无线电技术）、 局域网（LAN，Local Area Network）、城域网（MAN，Metropolitan Area Network）和广域网（WAN，Wide Area Network）。</p><blockquote><p>按照网络中主机的台数分类</p></blockquote><p>这是 Internet 中根据 IP 地址数的分类方法，它按主机台数将网络分为Ａ、Ｂ、Ｃ三类，对应大型网络、中型网络和小型网络。</p><blockquote><p>其他分类方法</p></blockquote><ul><li>按使用权限：公用网和专用网（私用网）<li>按操作系统及其版本分类：如 UNIX 网<li>按所用技术分类：如 x.25、帧中继网、ATM 等<li>按使用介质：如 无线网、光纤网等<li>按业务范围：如校园网、企业网、金桥网、教育科研网、经济网、科技网、医卫网等</ul><h2 id="计算机网络元素"><span class="mr-2">计算机网络元素</span><a href="#计算机网络元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>从平面拓扑结构的角度，可以认为节点、链路构成了网络的平面结构（节点的分布和连接）； 从分层的垂直结构的角度，可以认为协议（协议栈）、服务、接口等构成了网络的垂直结构（可以认为是节点的垂直剖析）。</p><h3 id="网络节点"><span class="mr-2">网络节点</span><a href="#网络节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在复杂的网络中进行数据传输，从源节点往往要经过多个中间节点才能传送到目的节点。中间节点大致有４种：端节点、中继节点、 交换节点和路由节点。</p><ul><li>端节点</ul><p>端节点是进行数据处理的节点。在计算机网络中，这些节点应当具有两种功能：数据处理（数据终端设备 DTE）和通信 （数据通信设备 DCE） 。</p><p>数据终端设备ＤＴＥ为具有一定数据处理能力的发送、接收设备，如计算机或各种终端设备；数据通信设备ＤＣＥ为通信接口设备， 在ＤＴＥ与通信网之间提供信号变换及编码功能，并负责建立、维护和释放物理连接，如波形变换器、基带传输器、调制解调器等。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-03.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-03.PNG" alt="端节点结构" class="lazyload" data-proofer-ignore></a></p><ul><li>中继节点</ul><p>信号在介质中传输时，随着传输距离的增加，幅度将会逐渐衰减，波形将会产生失真。中继器（Repeater） 用于同类网络介质之间的互连，起到信号再生、放大作用。</p><p>再生就是通过对失真的但仍可以辨认的波形的分析，重新生成原来的波形； 放大就是将信号衰减了的幅度加以恢复。通过再生和放大能够使网络传输的距离范围得以扩大。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-04.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-04.PNG" alt="中继器的工作原理" class="lazyload" data-proofer-ignore></a></p><p>中继有一通一的中继和一通多的中继。应当强调的是，经过集线器的信号都是重新整理过后再传送出去。 不同的通信介质有不同的中继器。</p><ul><li>交换节点</ul><p>一个通信过程往往要 经过多条 链路之间 的转接才 能实现。转接由 交换（Switching）节点实现。 简单地说，交换节点的功能是将一条链路上送来的数据有选择地转送到另外的一条链路上。 复杂拓扑结构网络中的通信信道就是经过多个中间节点的转发—连接而实现的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-05.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-05.PNG" alt="交换节点" class="lazyload" data-proofer-ignore></a></p><ul><li>路由节点</ul><p>路由节点是一种特殊的节点。它位于网络之间，起连接网络的作用，属于所连接的网络共有。正是由于路由节点，才使互联网得以形成。 如果把每个网络看成一个通路———链路，那么路由节点的分布就形成了互联网络的拓扑结构或框架。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-06.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-06.PNG" alt="路由节点" class="lazyload" data-proofer-ignore></a></p><p>路由器的网络连接功能主要体现在它能为到达的数据选择到达目的节点的路由。这就是路由节点称为路由器（Router）的原因。 路由和交换虽然具有相似之处，但是是在不同的层次中实现的。</p><h3 id="传输链路"><span class="mr-2">传输链路</span><a href="#传输链路" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>传输链路是网络中连接两个节点的直接信息通路，简称链路（Link）。数据在计算机网络中传输，往往要经过多条链路一段一段地传输。 中间可能经过中继节点，也可能经过交换节点。</p><p>链路可能是物理的，也可能是逻辑的。采用多路复用技术可以把一条物理链路划分成多条逻辑链路。通信介质就是搭载信号的传输媒介， 是链路的物理基础。通信介质分为硬介质（双绞线电缆、同轴电缆、光缆等） 和软介质（即空间介质，如微波通信、卫星通信、红外通信等）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-07.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-07.PNG" alt="通信介质性能比较" class="lazyload" data-proofer-ignore></a></p><h3 id="协议"><span class="mr-2">协议</span><a href="#协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>凡是两个以上的对象或系统相互进行联系，都需要建立联系的规则或约定。这些为了通信或联系所制定的约定、 规则和标准就被称为协议（Protocol）。实际上，人类的每一种语言都是一种协议。协议存在于任何通信过程中， 它包含了所传输信息的格式（语法）、语义和定时（传输顺序）三个方面的约束。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>协议的基本功能
</pre></table></code></div></div><p>在计算机网络中，协议的目的是确保通信过程顺利、安全、可靠地进行，因此它的基本功能有以下几点：</p><ul><li>分割与组装：</ul><p>在通信网络中，为了提高传输效率以及克服传输能力的限制，在发送端要将报文分割成一些适合网络传输的数据包———分组， 并在分组时加上控制信息；在接收端要将数据分组重新组装成报文。</p><ul><li>规定格式和特性：</ul><p>规定数据格式，规定网络接口的机械、物理、功能和规程特性等。</p><ul><li>传输服务：不同的通信系统有不同的传输服务。<li>传输控制：</ul><p>包括流量控制、差错控制和连接控制。流量控制用于控制数据传输过程中发送方的发送速度和数量，解决信道上的拥塞问题； 差错控制用于减少、检测和纠正错误；连接控制用于通信实体间连接的建立或拆除。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>协议的实现
</pre></table></code></div></div><p>网络协议通常是由网卡和网络操作系统共同实现的。</p><ul><li>网卡</ul><p>网卡是网络设备（如工作站、服务器等）与网络的通信介质进行连接服务的设备。</p><p>网络正常工作时，网卡通过通信介质的端口监视网络的状态，接收传输介质上的信号。当网卡接收到有效的数字信号时， 网卡会判断是否发给本站（是，则将数据通过网络设备的接口传输到网络设备；否则放弃或按原方向转发）； 另一方面，要适时将所连设备需发送的数据发送到网上，以实现网络设备间的通信。</p><ul><li>网络操作系统</ul><p>网络操作系统（NOS，Network Operating System）是网络用户与通信网络之间的接口。</p><h1 id="计算机网络体系结构">计算机网络体系结构</h1><p>计算机网络的各层及其协议的集合，称为网络的<em>体系结构</em>。换句话说，计算机网络的体系结构就是这个计算机网络及其构件所应完成 的功能的精确定义。但是， <em>这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的<code class="language-plaintext highlighter-rouge">实现</code>的问题</em>。 <code class="language-plaintext highlighter-rouge">体系结构是抽象的， 而实现则是具体的，是真正在运行的计算机硬件和软件</code>。</p><h2 id="层的划分"><span class="mr-2">层的划分</span><a href="#层的划分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面提到了计算机网络体系涉及到层和协议，其中协议已经讲过了，现在来看下层的划分。</p><p>当一个问题很复杂时就应考虑模块化或分层等问题了，因为这样可以使问题得到简化。分层带来的好处列举如下：</p><ul><li>各层之间是独立的<li>灵活性好：</ul><p>当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。因为层中协议的具体实现对上下层是透明的， 这有服务（通过层间接口实现）时可见的。</p><ul><li>结构上可分隔开：各层都可以采用最合适的技术来实现。<li>易于实现和维护。<li>能促进标准化工作。</ul><p>分层时应注意使每一层的功能非常明确。若层数太少，就会使每一层的协议太复杂，但层数太多又会在描述和综合各层功能的系统工程任务 时遇到较多的困难。通常各层所要完成的功能主要有以下一些（可以根据需要选择）：</p><ul><li>差错控制：使得和网络对等端的相应层次的通信更加可靠。<li>流量控制：使得发送端的发送速率不要太快，要使接收端来得及接收。<li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。<li>复用和分用：发送端几个高层会话复用一条底层连接，在接收端再进行分用。</ul><p>分层当然也有一些缺点，如，有些功能会在不同的层次中重复出现，因而产生了额外开销。</p><h3 id="五层协议的体系结构"><span class="mr-2">五层协议的体系结构</span><a href="#五层协议的体系结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>OSI 七层模型和协议过于复杂，而且其中的表示层和会话层没有什么内容。而 TCP/IP 模型虽然分层不及 OSI 模型清楚，且最下面的 网络接口层是一个空洞的层次，根本就没什么内容。为此，结合 OSI 的理论性和 TCP/IP 的实用性对层次划分进行折中而采用五层模型。 集体见下图：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-08.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-08.PNG" alt="五层模型" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-09.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-09.PNG" alt="OSI 模型" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-10.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-10.PNG" alt="TCP/IP 模型" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-11.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-11.PNG" alt="TCP/IP 协议" class="lazyload" data-proofer-ignore></a></p><ul><li>应用层：</ul><p>应用层是面向网络用户应用进程的，直接为用户服务的，它的数据就放在 TCP 等运输层协议数据包的”数据”部分应用程序收到”传输层”的数据， 接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。 “应用层”的作用，就是规定应用程序的数据格式。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-12.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-12.PNG" alt="应用层通信" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-13.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-13.PNG" alt="应用层通信" class="lazyload" data-proofer-ignore></a></p><ul><li>运输层：</ul><p>运输层的任务就是负责向两个主机中进程之间的通信提供服务，使得应用层用户进程看见的就是好像在连个运输层实体之间有一条端到端 的、全双工通信通路。换句话说，运输层实现了端到端（进程间）通信服务，隐藏了网络细节。</p><ul><li>网络层：</ul><p>翁洛层实现了主机间（并非进程间）的通信服务。为主机通信提供了一条通路，隐藏了各个分段链路，好像就是两台主机直接通信一样。</p><p>数据链路层从一条传输链路的角度来解决传输中的可靠性问题。网络层则是从整个网络的角度来处理数据传输中的有关问题， 处理问题过程中需要考虑通信双方的终端节点及中间节点间的关系。</p><ul><li>数据链路层：</ul><p>数据链路层实现了点对点通信。两个主机之间的数据传输，总是在一段一段的链路上传送的，而在两个相邻结点之间传送数据时直接传送的， 这是就需要使用专门的链路层协议。其最重要的作用是：通过一些数据链路层协议在不太可靠的物理链路上实现可靠的数据传输。</p><p>在物理层实现了透明的０、１码传输的基础上，数据链路层将加强这些原始比特的传输，使之成为一条无错的数据传输链路。</p><ul><li>物理层：</ul><p>物理层并不是指连接计算机的具体物理设备或传输介质，而是指在通信设备或介质之上透明地传送比特流。具体来说，物理层协议要解决 的是主机、工作站等数据终端设备与通信线路上通信设备之间的接口问题。</p><h3 id="分层模型中基本概念"><span class="mr-2">分层模型中基本概念</span><a href="#分层模型中基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>实体：实体表示任何可发送或接收信息的硬件或软件进程。<li>协议：协议是控制两个(或多个)对等实体进行通信的规则的集合。<li>服务：</ul><p>协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。下面的协议对上面的实体是透明的。</p><p>服务就好像是面向对象语言中的抽象数据类型或者对象，它定义了在对象上可以执行的操作，但是并没有说明如何实现这些操作。 而协议与服务的具体实现有关，它对于服务的用户是完全不可见的。</p><h1 id="物理层">物理层</h1><p>物理层考虑的是怎样才能在链接各种计算机的传输媒体上传输比特流，而不是只具体的传输媒体。这很显然包括：物理信号的编码和 译码、比特的产生发送传输和接收、我们知道，物理层建立在传输媒体之上，因此可以将物理层的主要任务描述为确定与传输媒体 的接口有关的一些性质，如机械特性（接口形态）、电气特性（电压范围）、功能特性（电压编码）和过程特性（事件顺序）等。</p><p>数据在计算机中多采用并行传输方式。但数据在通信线路上的传输方式一般都是串行传输（这是出于经济上的考虑），即逐个比特按照 事件顺序传输。因此物理层还要完成传输方式的转换。</p><h2 id="通信基础基础"><span class="mr-2">通信基础基础</span><a href="#通信基础基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>既然物理层建立在传输媒体之上，必然会用到一些数据通信基础。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-14.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-14.PNG" alt="通信模型" class="lazyload" data-proofer-ignore></a></p><p>该系统包括四类部件：计算机（或终端）、通信控制器、信号变换器和通信线路。其中，计算机为信源或信宿；通信控制器负责数据传输 控制，以减轻主机负担，在微机一侧，它的功能一般由微机承担；信号变换器完成数据与电信号之间的变换，以匹配通信线路的信道特性， 依据通信线路的不同，信号变换器称之为“波行变换器”或“调制解调器”；通信线路泛指各种使用的传输介质，是传输信号的通路。</p><p>网络传输介质上一般使用串行的方式进行通信，而计算机内部则是使用并行方式进行通信的。所以有时需要进行相互转换。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-00.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-00.PNG" alt="串行并行通信" class="lazyload" data-proofer-ignore></a></p><h3 id="有关信道的基本概念"><span class="mr-2">有关信道的基本概念</span><a href="#有关信道的基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>信道是信源和信宿之间的通信线路，用来表示向某个方向传送信息的媒体。信道和电路并不等同，一条通信电路往往包含一条发送信道 和一条接收信道。</p><ul><li>单向通信：又称为单工通信<li>双向交替通信：</ul><p>又称为半双工通信。即通信的双方都可以发送信息，但不能双方同时发送（当然也不能同时接收）。这种通信方式是一方发送另一方接收， 过一段时间后再反过来。</p><ul><li>双向同时通信：又称为全双工通信。</ul><p>来自信源的信号常称为<code class="language-plaintext highlighter-rouge">基带信号</code>（即基本频带信号）。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能 传输这种低频分量或直流分量。为此，就必须对基带信号进行<em>调制</em>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>调制可分为两大类：
</pre></table></code></div></div><ul><li>基带调制：</ul><p>仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号。</p><ul><li>带通调制：</ul><p>使用载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为<code class="language-plaintext highlighter-rouge">带通信号</code>（即 仅在一段频率范围内能够通过信道），而使用载波的调制称为<em>带通调制</em>。</p><p>根据载波的振幅、频率和相位随基带数字信号而变化，形成了最基本的带通调制方法：调幅（AM）、调频（FM）、调相（PM）。为了达到 更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>信道的极限容量：
</pre></table></code></div></div><p>在任何信道中，码元（通信中指的是能够被识别的波形）传输的速率是有上限的，传输速率超过此上限， 就会出现严重的码间串扰的问题，是接收端对码元的判决（即识别）称为不可能。</p><p>香农公式指出：信道的极限信息传输速率 C 是： <a href="/assets/img/it_basic/network/basic/internet-basic-15.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-15.PNG" alt="香农公式" class="lazyload" data-proofer-ignore></a></p><p>从上述可知，对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有什么办法提高信息的传输速率呢？ 这就是用编码的方法让每一个码元携带更多比特的信息量。</p><h2 id="数字数据的数字传输"><span class="mr-2">数字数据的数字传输</span><a href="#数字数据的数字传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>用于传输数字数据的线路有数字通信线路和模拟通信线路。因此，数字数据的传输有相应的两种方式：基带传输方式和频带传输方式。</p><h3 id="基带传输"><span class="mr-2">基带传输</span><a href="#基带传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>数字数据以原来的 0 或 1 （一般为矩形波）的形式原封不动地在信道上传送，称为<em>基带传输</em>。</p><p>基带传输是一种最简单的传输方式，近距离通信的局域网都采用基带传输。基带传输时，需要解决的问题是数字数据的数字信号表示。 对于传输数字信号来说，最常用的方法是用不同的电压电平来表示两个二进制数字，即数字信号由矩形脉冲组成。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-16.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-16.PNG" alt="基带信号数字化" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-17.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-17.PNG" alt="基带信号数字化" class="lazyload" data-proofer-ignore></a></p><ul><li>曼彻斯特码</ul><p>其特点是将每个比特周期分为两部分：前半个比特周期传送该比特的原码，后半个周期传送该比特的反码，于是在每个比特周期的 中间产生一个电平跃变。这个跃变信号既可以用做同步信号， 也可以用做表示数据（如图所示，用正跃变表示为“０”，用负跃变表示为“１”）。</p><ul><li>差分曼彻斯特码</ul><p>它是对曼彻斯特码的的改进，它用每一码元的开始边界处有无跃变来区别“０”和“１”，如图所示，有跃变表示为 “０”，无跃变表示为“１”。这时，每个比特周期中间的跃变仅仅用做同步时钟。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-23.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-23.PNG" alt="6种编码" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>数字信号编码方式评价指标：
</pre></table></code></div></div><ul><li>脉冲宽度：</ul><p>脉冲宽度大，信号的能量就大，对于提高接收端的信噪比有利。</p><ul><li>占用的频带宽度：</ul><p>脉冲宽，占用的频带就窄，如归零码比全宽码占用的频带要宽。</p><ul><li>直流分量的成分：</ul><p>直流分量低有利于传输，如双极性码的直流分量较低，曼彻斯特码和差分曼彻斯特码的每个码元中都有跃变，因而没有直流分量。</p><ul><li>自同步能力：</ul><p>曼彻斯特码和差分曼彻斯特码的每个码元中都有跃变，可以提供自同步能力。如在 IEEE 802.5 中，正常的信号编码都采用差分曼彻斯特 码，只有起始和结束字段中各有４位“特殊比特”，这些特殊比特的码元中间没有跃变，要么是全高电平，要么是全低电平， 以“特殊比特”来作为信号编码起始和结束的标志。</p><p>其中，不归零码在传输中难以确定一位的结束和另一位的开始，需要用某种方法使发送器和接收器之间进行定时或同步；归零码的脉冲 较窄，根据脉冲宽度与传输频带宽度成反比的关系，归零码在信道上占用的频带较宽；单极性码会积累直流分量，不能使用交流耦合， 而且直流分量还会损坏连接点表面电镀层；双极性码的直流分量大大减少，这对数据传输是很有利的。</p><h3 id="频带传输"><span class="mr-2">频带传输</span><a href="#频带传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了利用廉价的公共电话交换网实现计算机之间的远程通信，必须将发送端的数字信号变换成能够在公共电话网上传输的音频信号， 经传输后再在接收端将音频信号逆变换成对应的数字信号。实现数字信号与模拟信号互换的设备称为调制解调器。</p><p>数字信号的调制实际上是用基带信号对载波波形的某些参数进行控制，而模拟信号传输的基础是载波。载波具有三大要素：幅度、频率和相位。 数字数据可以针对载波不同要素或它们的组合进行调制。</p><p>数字调制的三种基本形式：幅移键控法 ASK（调幅）、频移键控法 FSK（调频）、相移键控法 PSK（调相）。 <a href="/assets/img/it_basic/network/basic/internet-basic-18.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-18.PNG" alt="频带传输" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-19.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-19.PNG" alt="频带传输" class="lazyload" data-proofer-ignore></a></p><h2 id="模拟数据的数字传输"><span class="mr-2">模拟数据的数字传输</span><a href="#模拟数据的数字传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>模拟数据的数字传输是利用数字信号传输系统来传输模拟信号。这就需要在发送端将模拟数据数字化，即需要进行模/数（A/D）转换； 在接收端再将数字信号转换成模拟信号。通常把 A/D 转换器称为编码器，把 D/A 转换器称为译（解）码器。和调制解调器一样， 编码器和解码器也常在一个设备中实现，称之为编码解码器。</p><p>脉码调制 PCM是以采用定理为基础，对连续变化的模拟新华进行周期性采样，利用大于或等于有效信号最高频率或其带宽 2 倍的采样频率， 通过低通滤波器从这些采样中重新构造出原始信号。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-20.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-20.PNG" alt="采样定理" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>模拟信号数字化的三步骤：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-21.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-21.PNG" alt="采样步骤" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-22.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-22.PNG" alt="脉冲调制" class="lazyload" data-proofer-ignore></a></p><h2 id="数据同步方式"><span class="mr-2">数据同步方式</span><a href="#数据同步方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>数据在传输线路上传输时，为了保证发送端发送的信号能够被接收端正确无误地接收，接收端必须与发送端同步。也就是说，接收端不但要知道一组二进制位的开始与结束，还需要知道每位的持续时间， 这样才能做到用合适的采样频率采样所接收到的数据。通常接收器在每位的中心进行采样，如果发送端和接收端的时钟不同步，即使只有较小的误差，随着时间的增加，误差逐渐积累，终究会造成收、 发之间的失步和误读。由于发送端和接收端的时钟信号不可能绝对一致，因此必须采取一定的同步手段。实际上，同步技术直接影响着 通信质量，质量不好的同步将会使通信系统不能正常工作。</p><blockquote><p>主要的同步方式：</p></blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>位同步：
</pre></table></code></div></div><p>位同步又称同步传输，它是使接收端对每一位数据都要和发送端保持同步。实现位同步的方法分为外同步法和自同步法两种。</p><ul><li>外同步法：</ul><p>在外同步法中，接收端的同步信号事先由发送端送来，而不是自己产生也不是从信号中提取出来。即在发送数据之前，发送端先向接收端 发出一串同步时钟脉冲，接收端按照这一时钟脉冲频率和时序锁定接收端的接受频率，以便在接收数据的过程中始终与发送端保持同步。 外同步法中典型例子是不归零吗 NRZ，</p><ul><li>自同步法：</ul><p>自同步法是指能从数据信号波形中提取同步信号的方法。典型例子就是著名的曼切斯特码和查分曼切斯特码。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-24.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-24.PNG" alt="位同步" class="lazyload" data-proofer-ignore></a></p><p>两种曼切斯特码具有自同步能力和良好的抗干扰性能。但每一个码元都被调成连个电平，所以数据传输速率只有调制速率的 1/2。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>字符同步：
</pre></table></code></div></div><p>字符同步也叫异步传输，每次传送一个字符，具体做法是：每个字符的首末分别设一位起始位和一位（或 1.5 位或 2 位）停止位， 分别表示字符的开始和结束。起始位是 0，结束位是 1，字符可以是 5 位或 8 位，一般 5 位的停止位是 1.5位，8 位字符的停止位是 2 位。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-25.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-25.PNG" alt="字符同步" class="lazyload" data-proofer-ignore></a></p><p>平时不传输字符时，传输线一直处于停止位状态，高电平。一旦检测到传输线有 1 到 0 的跳变，说明发送端开始发送字符，接收端立即应用 这个电平变化启动定时机构，按发送端的顺序接收字符。待发送字符结束，发送端又使传输线处于高电平，直至下一个字符。</p><p>这种方式接收始终仍应与发送时钟同步，但由于每次只接收一个字符，对接收端始终的精度要求降低了，除非时钟偏差超过 50% （这是不可能的），时钟偏差才会引起采样出错。</p><p>字符同步简单、易于实现，但传输效率低，因为每个字符都要附加起始位和结束位，辅助开销比例很大。因此一般用于低速线路中， 像计算机与终端、计算机与调制解调器、计算机与复用器等通信设备的连接。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>帧同步：
</pre></table></code></div></div><p>帧同步以字符块为单位进行传输，一块一般由几千个数据位。为了防止发送端和接收端失步，发送时钟和接收时钟必须同步。目前一般 采用自同步法，即从所接收的数据中提取时钟特征（如曼切斯特码）。</p><p>为了使接收端和发送端同步，除使双方时钟同步外，还必须使接收端能准确判断出数据的开始和结束。一般的做法是在数据块前加一个一定长度 的位模式，一般称为同步信号或前文（SYN，前导码），数据结束后加上后同步信号（后文）。</p><p>前文、后文加上所传输的数据信息构成了一个完整的异步传输方式下的数据单位，称为帧。帧是数据链路层的数据传输单位。简单说来，帧 的传输过程是这样的：接收端检测到前文后，说明发送端已开始发送数据，接收端利用从数据中提取出的时钟信号作为接收时钟，按顺序 接收前文之后的数据信息，直到碰上后文为止。</p><p>帧同步因为以位块为单位（几千比特），额外开销小，因此传输效率高，在数据通信中得到了广泛应用， 但这种方式的缺点是发送端和接收端的控制复杂，且对线路要求较高。</p><h2 id="信道的多路复用技术"><span class="mr-2">信道的多路复用技术</span><a href="#信道的多路复用技术" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在通信系统中，信道有逻辑信道与物理信道之分。物理信道是实实在在的物理通路。物理信道与逻辑信道之间的关系有点像铁路与车次之间 的关系，物理信道好比是铁路，逻辑信道好比是车次。</p><p>逻辑信道是建立在物理信道基础上的：一条物理信道通过载波、分时或改变连接方式等， 有可能分为几条逻辑信道（好像同一条铁道上同时运行多趟列车一样）；在复杂拓扑结构的网络上， 两点之间的通信并不一定要有一条专门的物理线路，而可以由其内部节点间的连接来实现。通常把逻辑信道的实现称为“连接”。</p><p>多路复用指在一个物理信道上同时传送多个信号，或者说是把一个物理信道设法分成多个逻辑信道，以提高信道利用率。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-26.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-26.PNG" alt="多路复用" class="lazyload" data-proofer-ignore></a></p><p>最基本的复用是频分复用 FDM 和时分复用 TDM。复用技术还有波分复用 WDM 和码分复用等。</p><blockquote><p>频分复用</p></blockquote><p>频分复用 FDM 是模拟传输（频带传输）中常用的一种多路复用技术。它把一个物理信道划分为多个逻辑信道， 各个逻辑信道占用互不重叠的频带（频率相差较大的波没有明显的干涉现象），相邻信道之间用“警戒频带”隔离（频率相近的波会发生干涉现象）， 以便将不同路的信号调制（滤波）分别限制在不同的频带内，在接收端再用滤波器将它们分离。</p><p>频分复用的所有用户在同样的时间占用不同的带宽资源，若每一个用户的带宽不变，则当复用的用户数增加时，复用后的信道的总带宽就 跟着变宽。</p><blockquote><p>时分复用</p></blockquote><p>与 FDM 的同时发送多路信号相比，时分多路复用是一种非同时发送的多路复用技术。它将一个传送周期划分为多个时隙， 让多路信号分别在不同的时隙内传送，形成每一路信号在连续的传送周期内轮流发送的情形。TDM 信号也成为等时信号。</p><p>时分复用的所有用户是在不同时间占用同样的频带宽度，若每一个时分复用帧的长度是不变的，那么随着用户的增加，单个用户分配到的 时限宽度就变窄了。但是，时限宽度非常窄的脉冲信号所占的频谱范围也是非常宽的。</p><p><em>统计时分复用 STDM</em> 是一种改进的时分复用（又称为异步时分复用），它能明显提高信道的利用率。<code class="language-plaintext highlighter-rouge">集中器</code>常使用这种统计时分复用。</p><p>数字信号的时分复用也称为<em>复接</em>，参与复接的信号称为支路信号，复用后的信号称为合路信号， 从合路信号中将原来的支路信号分离出来称为分接。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>复接方式：
</pre></table></code></div></div><p>ＴＤＭ可以设计成按位、按字节、按字符、按字或按任意多位的方式来对每个终端进行扫描复接。 <a href="/assets/img/it_basic/network/basic/internet-basic-27.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-27.PNG" alt="复接方式" class="lazyload" data-proofer-ignore></a></p><p><em>按位复接</em>又称为比特复接，即复接时每支路依次复接一个比特。这是目前广泛使用的方法，它的设备简单，需容量小， 且容易进行，但对信号的交换不利。</p><p><em>按字节复接</em>的方法如下：对基群来说，一个码字有８位，复接前先将８位码存起来，在规定的时间内一次复接；４个支路轮流复接。 这种方法需要较大的存储容量，适合于数字电话交换。</p><p><em>按帧复接</em>是每次复接一个支路的帧（256比特）。这种方法不破坏原来的帧结构，有利于交换，但需要更大的存储容量。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>同步时分复用和异步时分复用
</pre></table></code></div></div><ul><li>同步时分复用：</ul><p>同步时分多路复用是指时分方案中的时间片是预先分配好的，时间片与数据源是一一对应的，不管某一个数据源有无数据要发送， 对应的时间片都是属于它的；或者说，各数据源的传输定时是同步的。在接收端，根据时间片的序号来分辨是哪一路数据， 以确定各时间片上的数据应当送往哪一台主机。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-28.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-28.PNG" alt="两种时分复用方式" class="lazyload" data-proofer-ignore></a></p><ul><li>异步时分复用：</ul><p>采用异步时分多路复用时，各时间片与数据源无对应关系，系统可以按照需要动态地为各路信号分配时间片， 各时间片与数据源无对应关系。为使数据传输顺利进行，所传送的数据中需要携带供接收端辨认的地址信息， 因此异步时分多路复用也称为标记时分多路复用。ＡＴＭ技术中的传输就是这种方式。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>复接时系统间的同步问题
</pre></table></code></div></div><p>当由几个低次群数字信号复接成一个高次群数字信号时，如果各低次群采用独立的时钟，即使每个低次群所使用的时钟的标称数码率相同， 也会由于线路长短不同产生的时延差异等原因，造成瞬时数码率的差异，从而形成如图所示的重叠或错位现象， 使复接合成后的数字信号无法分接恢复成为原来的低次群数字信号。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-29.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-29.PNG" alt="复接同步问题" class="lazyload" data-proofer-ignore></a></p><p>为避免这个问题，需要解决系统与系统间的同步问题。系统间的同步可以用两种方法实现：</p><ul><li>用一个高稳定的主时钟来控制被复接的几个低次群，使它们的数码率统一在主时钟的频率上，从而达到同步的目的；<li>另一种，也是最常用的，是称为码速调整的方法。</ul><p>码速调整方法是让各低次群仍然使用自己的时钟，并在复接前插入一些码元。 调整后的数码率高于调整前的数码率的码速调整方法称为正码码速调整。</p><p>在复接器中为调整码率要插入插入码，在分接器中要将它们去掉———消插。分接器进行消插的依据是“插入标志码”。 当插入标志码的 ４ 位中有“000”时，表示无插入码；当插入标志码的 ４ 位中有“111”时，表示有插入码。这种方法叫做“大数判决法”。</p><p>实际上，同步复接中也要使用插入码。与异步复接不同的是，它在每一个帧中都要插入插入码， 目的是使低次群的码速能在复接后符合高次群的要求。</p><blockquote><p>波分复用：</p></blockquote><p>波分复用就是光的频分复用技术。光波分多路复用技术是在一根光纤中能同时传输多个光波信号的技术。 它在发送端将不同波长的光信号组合起来，复用到一根光纤上，在接收端又将组合的光信号分开（解复用），并送入不同的终端。</p><blockquote><p>码分复用：</p></blockquote><p>码分多路复用（CDM）（又称为码分多址，CDMA）也是一种共享信道的方法，每个用户可在同一时间使用同样的频带进行通信， 但使用的是基于码型的分割信道的方法，即每个用户分配一个地址码，各个码型互不重叠，通信各方之间不会相互干扰， 且抗干拢能力强。码分多路复用技术主要用于无线通信系统，特别是移动通信系统。</p><p>在 CDMA 中，每一个比特时间再划分为 m 个短的间隔，称为码片。使用 CDMA 的每一个站被指派一个唯一的 m bit 码片序列。一个站 要发送比特 1，则发送它自己的 m bit 码片序列。如果要发送比特 0，则发送该码片序列的二进制反码。为了方便，我们按照惯例将 码片中的 0 写为 -1，将 1 写为 +1.</p><p>CDMA 系统的一个重要特点就是这种体制给每一个站分配的码片序列不仅必须各不相同，并且必须互相正交。在实用的系统中是使用 伪随机码序列。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-30.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-30.PNG" alt="CDMA 数学原理" class="lazyload" data-proofer-ignore></a></p><p>从上面的定义可知，向量 S 和各站码片反码的向量的内积是 0（相互正交），而且任何一个码片向量和自身做内积都是 1， 同时任何一个码片和自身的反码向量的规格化内积是 -1.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>码分复用通信原理：
</pre></table></code></div></div><p>现嘉定有一个 X 站要接收 S 站发送的数据。X 站就必须知道 S 站所特有的码片序列（就像你打电话给张三，必须知道张三的电话号码一样）。 X 站使用它得到的码片向量 S 与接收到的未知信号进行求内积的运算。X 站接收到的信号时各站发送的码片序列之和（没有收到则为 0）。 根据前面的公式，在根据叠加原理（假定各种信号经过信道到达接收端是叠加的关系）。那么内积得到的结果是：所有其他站（除了 S 站） 信号都被过滤掉（正交，其内积的相关项都是 9），而只剩下 S 站发送的信号。当 S 站发送比特 1 时，在 X 站计算内积的记过是 +1， 当 S 站发送比特 0 时，内积的结果是 -1.</p><h2 id="宽带接入技术"><span class="mr-2">宽带接入技术</span><a href="#宽带接入技术" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>宽带接入技术有很多种，如 XDSL 技术、光纤同轴混合网（HFC网）、FTTx 技术（光纤到…）等。这里只提下 xDSL 技术。</p><p>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。虽然标准模拟电话信号的频带被限制在 300~3400 kHz 的 范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。因此 xDSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有 被利用的高端频谱留给用户上网使用。 DSL 就是数字用户线的缩写，而 DSL 的前缀 x 则表示在数字用户线上实现的不同宽带方案。</p><h1 id="数据链路层">数据链路层</h1><p>前面已经说过的物理层，它只关注单个比特传输，具体一点，它只关注节点产生发送接收比特（而传输只是完全依赖物理性质）。物理层 不知道接收的比特是否有问题（接收端只负责接收和解读，至于该解读与发送端本来的意思是否相同是不知道的）、也不知道信道是否拥挤， 当然也不知道应该什么是否发送（它只管发送就可以了，不知道发送的时机）。发送端和接收端都不知道所发送或接收的一串比特序列有 什么意义，也不清楚该从哪里分段等，总之，</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>物理层只关注单个比特的产生发送和接收，
不清楚比特组合的意义，
而传输依赖通信线路本来的物理性质。
它不知道线路的任何状况，
也不清楚发送的最好时机。
</pre></table></code></div></div><p>然而，通信线路偶尔会出错，而且，它们只有有限的数据传输率（物理层只管发送，不管线路是否能承受），并且在比特的发送时间和接收 时间之间存在一个非零延迟。这些限制对数据传输的效率有非常重要的影响。数据链路层所采用的协议必须考虑所有这些因素。</p><p><em>链路层协议的任务是将网络层的数据报通过路径中的单段链路节点到节点地传送。链路层的一个重要特点是数据保在路径的不同链路上 可能由不同的链路层协议所承载。</em></p><h2 id="基本概念"><span class="mr-2">基本概念</span><a href="#基本概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>链路：</ul><p>所谓“链路”就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。在进行数据通信时，两个计算机之间的通信 路径往往要经过许多段这样的链路，可见链路只是一条路径的组成部分。</p><ul><li>数据链路：</ul><p>数据链路是不同于链路的另一个概念。这是因为当需要在一套线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的 通信协议来控制这些数据的传输。如果把实现这些协议的硬件和软件加在链路上，就构成了数据链路。一般用<em>网络适配器</em>（俗称“网卡”） 来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 可见链路与物理链路对应，数据链路与逻辑链路对应。</p><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li>（1）点对点信道：这种信道使用一对一的点对点通信方式。<li>（2）广播信道：</ul><p>广播信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多， 因此必须使用专用的共享信道协议来协调这些主机的数据发送。</p><ul><li>（数据）帧：</ul><p>帧是数据链路层协议数据单元，它由数据链路层协议对网络层提交来的数据添加首尾部而成。</p><h2 id="链路层协议"><span class="mr-2">链路层协议</span><a href="#链路层协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>数据链路层使用的信道有两类，所以数据链路层协议也分为两类：点对点类协议和广播类协议。</p><h3 id="三个基本问题"><span class="mr-2">三个基本问题</span><a href="#三个基本问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>不论是哪一类协议，都会涉及到以下三个问题：封装成帧、透明传输和查错检测。</p><blockquote><p>封装成帧</p></blockquote><p>封装成帧就是在一段网络层数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端再收到物理层上交的比特流后，就能根据首部 和尾部的标记，从收到的比特流中识别帧的开始和结束。</p><p>可见，帧长等于数据部分的长度加上帧首部和帧尾部的长度，而首部和尾部的一个重要作用就是进行帧定界。此外，首部和尾部还包括 许多必要的控制信息。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层 协议都规定了帧的数据部分的长度上限，即<code class="language-plaintext highlighter-rouge">最大传送单元 MTU</code>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-31.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-31.PNG" alt="帧 MTU" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>帧定界（拆分比特流）的方法：
</pre></table></code></div></div><ul><li>字节计数法：</ul><p>利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节，因此也就知道了 该帧在哪里结束。</p><p>这个算法的问题在于一旦计数值出错，那么后面所有帧被边界都可能弄混。即使检查出了错误要求重传，接收方也不知道该跳过多少字节 才能到达重传的帧的开始。</p><ul><li>字节填充的标志字节法：</ul><p>鉴于字节计数法出现的出错之后的重新同步问题，本方法让每个帧用一些特殊的字节作为开始和结束。这些特殊字节通常都相同， 称为标志字节，作为帧的起始和结束分解符。即使某个帧出错，只要向后搜索就可以知道下一个帧的开始处。</p><p>然而，当标志字节出现在数据中时，就需要区分是数据还是帧定界符。一般的方法就是使用类似转义字符插入到数据中出现的标志字节之前。 但是，转义字符也可能出现在数据中，这样就需要再次转义。为了统一这两种情况，只需要在数据中出现的标志字节或转义字符前插入 转义字符即可，当接收时，只需要将遇到的转义字符去除即可（如果没有这个动作说明到了帧的边界）。</p><ul><li>比特填充的标志比特法：</ul><p>本方法考虑了字节填充的缺点，即只能使用 8 比特的字节。帧的划分可以在比特级完成，因而帧可以包含由任意大小单元（而不是只能以 8 比特为单元）组成的二进制比特数。这种方法是为曾经非常流行的 HDLC（高级数据链路控制）协议而开发的。每个帧的开始和结束由一个 特殊的比特模式，0111 1110 或十六进制 0x7E 标记。每当发送方的数据链路层在数据中遇到五个 1，它便自动在输出的比特流中填入一个 比特 0（在接收方做相反的处理即可）。比特填充还确保了转换的最小密度，这将有助于物理层保持同步。正是由于这个原因，USB（通用 串行总线）采用了比特填充技术。</p><ul><li>物理层编码违禁法：</ul><p>采用比特填充和字节填充的一个副作用是：一帧的长度现在要取决于它所现代的数据内容，因为数据中可能存在特殊标志，需要填充，至于 数据中有多少这样的特殊标志，上层是不关心的，发送方也是不计数的。</p><p>由物理层的知识可知，比特编码信号通常包括一些冗余比特，以便帮助接收器同步接收。这种冗余意味着一些信号将不会出现在常规数据中。</p><p>例如，在 4B/5B 线性编码模式下，4 个数据位被映射成 5 个信号比特，通过这种方法确保线路上的信号有足够的跳变。这意味着 32 个 可能的信号中有 16 个是不会被使用的。我们可以利用这些保留的信号来表示帧的开始和结束。实际上，我们使用“编码违法”来区分 帧的边界。这种方案的优点在于，因为这些用作分解符的信号是保留不用的，所以很容易通过它们找到帧的开始和结束，而且不再需要 填充数据。<code class="language-plaintext highlighter-rouge">许多数据链路协议为安全起见综合使用了这些方法</code>。具体请参看后面讲到的具体协议。</p><blockquote><p>透明传输</p></blockquote><p>相关内容在前面“封装成帧”时已经提到过了。网络层交给数据链路层的数据不需要知道链路层采用的是怎样的定界方法，更不需要对数据链路层 涉及到的特殊标志做特殊处理，也不需要担心会造成链路层帧定界混乱等，这些都是数据链路层应该做的事情，也就是说，这些对网络层 是透明的。</p><blockquote><p>差错检测：</p></blockquote><p>当帧中的一个比特作为 1 传输时，接收方结点可能错误地判断为 0，反之亦然（称之为“比特差错”）。这种比特差错是由信号衰减和 电磁噪声所致。对于出错的帧应遵循早发现早处理的原则。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制以 检测是否存在一个或多个差错。通过让发送结点在在帧中设置差错检测比特，让接收结点进行差错检测来完成这项工作。</p><p>一旦发现帧中出现差错，此时会向发送方提供反馈信息，通常情况下，协议要求接收方发回一些特殊的控制帧。但是，控制帧也有可能 出错或丢失，那么就得不到任何反馈信息，这样就需要引入计时器来解决此类问题，当计时器超时就重发。但是接收端不能区分帧是 第一次发还是重发过来的。</p><p>注意，在数据链路层只能做到帧的无差错接受，或者说，凡是接收端数据链路层接受的帧均五差错（因为有差错的已经被丢弃了）。 特别注意的是，我们现在并没有要求数据链路层向网络层提供“可靠传输”的服务。所谓<code class="language-plaintext highlighter-rouge">“可靠传输”</code>就是：数据链路层的发送端 发送什么，在接收端就收到什么。<code class="language-plaintext highlighter-rouge">传输插锁</code>可分为两大类：</p><ul><li>比特差错<li>没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。</ul><p>为此，OSI 的观点是必须把数据链路层做成是可靠传输的。因此在比特差错检测的基础上，增加了帧编号、确认和重传机制。收到正确的 帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认 为止，这样通信效率比较低。</p><p>因此，因特网广泛使用的数据链路层协议都不使用确认和重传机制（通信线路的通信质量大大提高了，出现 错误的概率大大降低了，再发过多的开销去应付小概率事件是不值得的）。这种机制应由更高层进行识别和处理为好，因为小概率事件发生 是很少的，如果交由链路层处理，那么在如此众多的中间节点（除发送和目标主机之外）都要增加相应的硬件或软件处理逻辑， 处理时间和投入（如增加缓存，因为需要保留发出的帧，以备出错重传）代价过高；如果放在主机中处理，相对的投入也会集中而且少了很多， 并且由于出现的概率少，即使在主机收到之后再要求重传，总体来说损失的时间也不多。</p><blockquote><p>流量控制</p></blockquote><p>链路每一端的结点都具有有限容量的帧缓存能力。当接收结点以比它能够处理的速率更快的速率接收分组时，这是一个潜在问题。没有 流量控制，接收方的缓存区就会溢出，并使帧丢失。</p><h3 id="比特差错检测方法"><span class="mr-2">比特差错检测方法</span><a href="#比特差错检测方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>前面一节中已经提到过差错检测和比特差错，那如何检测比特差错呢？总体思想是：假设 n 位由于编码组合，这样的所有组合会组成一个 集合，那么只使用集合中的一部分表示正确数据（暂称为”合法区“），那么剩下的那部分就是“违法”的（暂称之为“违禁区”， 一旦正确的组合中的某个位出错，如果落入违禁区，则说明出错。这样就可以检测错误了；如果要纠正错误，则需要合法区和违禁区形成 对应关系，方可知道错在哪里，才有可能纠正错误。</p><blockquote><p>基本概念</p></blockquote><p>一帧包含 m 个数据位（即报文）和 k 个冗余位（校验位）。假设帧的总长度为 n，则由 n=m+k。像这样包含数据和校验位的 n 位单元通常 称为 n 为<code class="language-plaintext highlighter-rouge">码字</code>。</p><p><em>海明码距（码距）</em>是两个码字中不相同的二进制位的个数；两个码字的码距是一个编码系统中任意两个合法编码（码字）之间不同的二进制 数位数；<code class="language-plaintext highlighter-rouge">编码系统的码距</code>是整个编码系统中任意两个码字的码距的最小值。<code class="language-plaintext highlighter-rouge">误码率</code>是传输错误的比特占所传输比特总数的比率。</p><p>海明研究发现，<em>检测 d 个错误，则编码系统码距 ≥d+1；纠正 d 个错误，则编码系统码距 &gt; 2d。</em></p><blockquote><p>奇偶校验码</p></blockquote><p>奇偶校验码是一种增加二进制传输系统最小距离的简单和广泛采用的方法。 是一种通过增加冗余位使得码字中”1”的个数恒为奇数或偶数的编码方法，它是一种检错码。在实际使用时又可分为垂直奇偶校验、 水平奇偶校验和水平垂直奇偶校验等几种。</p><blockquote><p>海明码</p></blockquote><p>海明码是一种多重（每个校验位负责不同的信息位组合）奇偶检错系统，它具有检错和纠错的功能。 海明码中的全部传输码字是由原来的信息和附加的奇偶校验位组成的。每一个这种奇偶校验位和信息位被编在传输码字的特定位置上。 这种系统组合方式能找到错误出现的位置，无论是原有信息位，还是附加校验位。</p><p>海明码校验位的个数以及在码字中的位置是由码字的信息位长和位置编号方式（从左至右还是从右至左）决定的。换句话说，码字的信息 位长不同或位置编号起止方式不同，海明码序列则不同。 但是需要注意的是，接收时校验的方式应和发送时产生校验位的方式（如编号起止位方式）保持一致。 由于海明码是及奇偶校验码（即只有两种状态，奇或偶），所以校验位要放在 1、2、4、8、……（2的次方）位置上。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>纠正单比特错或发现两位错至少满足的条件：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-32.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-32.PNG" alt="海明码条件" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>海明码例子：
</pre></table></code></div></div><ul><li>第一种方法：</ul><p>假设信息位数为 4，则根据公式可知需要三个校验比特，并假定位置编号从右至左（符合一般数字规范）。 具体产生校验位和接收端进行校验的方法步骤如下：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-33.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-33.PNG" alt="海明码例1" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-34.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-34.PNG" alt="海明码例1" class="lazyload" data-proofer-ignore></a></p><ul><li>第二种方法</ul><p>与第一种方法在步骤二的地方有所区别。将信息位的位置将十进制转为二进制，然后类似垂直奇偶校验啊进行处理。还是以上个例子 作为本方法的例子。请看步骤二，具体如下表：</p><div class="table-wrapper"><table><tbody><tr><td>信息位<td>信息位位置<td>位置二进制<tr><td>I4<td>7<td>1　1　1<tr><td>I3<td>6<td>1　1　0<tr><td>I2<td>5<td>1　0　1<tr><td>I1<td>3<td>0　1　1<tr><td>校验位<td> <td>r2 r1 r0<tr><td>校正因子<td> <td>S2 S1 S0</table></div><p>表中的校验位就是由表中对应列中为 1 的相应信息位做异或运算得出（参照方法一步骤三结果）， 而<code class="language-plaintext highlighter-rouge">校正因子</code>指的是接收端对数据和原校验位进行校验时得到的新校验位。</p><blockquote><p>CRC 编码</p></blockquote><p>纠错码广泛用于无线通信中，因为无线线路比有线噪声更多、容易出错。有线线路上的错误率非常低，所以对于偶然的错误，利用错误检测和重传机制更为有效。数据 链路层广泛使用循环冗余校验码（CRC）进行错误检测。</p><p>CRC 编码又称为多项式编码。CRC 的基本思想是：吧位串看成系数为 0 或 1 的多项式，一个 k 位的帧看成是一个 k-1 次多项式（共有 k 项）的系数列表。例如， 1101 有 4 位，可以代表一个 4 项（次数从 0 开始）或 3 阶多项式，系数为 1、1、0、1，即 (1 * x^3 + 1 * x^2 + 0 * x^1 + 1 * x^0 =) x^3 + x^2 + 1。</p><p>使用 CRC 编码，需要先商定一个<code class="language-plaintext highlighter-rouge">生成多项式 G(x)</code> 。生成多项式的最高位和最低位必须为 1 。假设原始信息有 m 位，则对应多项式 M(x)（每一位串都有唯一 的多项式与之对应）。生成校验码的思想是：在原始信息位后追加若干校验位（比 G(x) 系数列表少一位），使得追加的信息能被 G(x) 整除。 接收方接收到带校验位的信息，然后用 B(x) 整除。余数为 0.则没有错误；反之则发生错误。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>CRC 校验的例子：
</pre></table></code></div></div><p>假设原始信息串位 10110，CRC 的生成多项式位 G(x) = x^4 + x + 1，求 CRC 校验码。</p><ul><li>1）原始信息后“添 0”</ul><p>主语添加多少个 0 ，由生成多项式的系数列表的位数决定（比该位数少 1）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-35.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-35.PNG" alt="CRC 添加 0" class="lazyload" data-proofer-ignore></a></p><ul><li>2）使用生成多项式除得到校验码</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-36.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-36.PNG" alt="CRC 除法" class="lazyload" data-proofer-ignore></a></p><p>得到余数 1111.注意：余数位数不足，则余数左边用若干个 0 补齐。</p><ul><li>3）将余数添加到原始信后</ul><p>上例中，原始信息 10110，添加余数 1111 后，结果为 10110 1111.</p><ul><li>4）接收方校验</ul><p>接收方接收了带校验和的帧后，用多项式 G(x) 来除。余数为 0，则表示信息无措；否则要求发送方进行重传。</p><p><em>注意：收发信息双方需使用相同的生成多项式。</em></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>常见的 CRC 生成多项式
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-37.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-37.PNG" alt="常见的 CRC 生成多项式" class="lazyload" data-proofer-ignore></a></p><h3 id="ppp-协议"><span class="mr-2">PPP 协议</span><a href="#ppp-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在通信线路质量较差（重传比纠错的代价更高）的年代，在数据链路层使用可靠传输协议曾经是一种好办法。因此， 能实现可靠传输的高级数据链路控制协议 HDLC 就称为了当时比较流行的数据链路层协议，不过现在 HDLX 已很少使用了。对于点对点 的链路，简单得多的 PPP 则是目前使用得最广泛的数据链路层协议。</p><p>因特网用户通常都要连接到某个 ISP（伊特网服务提供商）才能接入到因特网。PPP（点对点协议）就是计算机和 ISP 进行通信时所使用 的数据链路层协议。</p><blockquote><p>PPP 协议应满足的需求</p></blockquote><ul><li>简单</ul><p>IETF 在设计因特网体系结构时把其中最复杂的部分放在传输层的 TCP 协议中，而网际协议 IP 则相对比较简单，它提供的是不可靠的数据 报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>对数据链路层的帧，
不需要纠错，不需要序号，
也不需要流量控制
</pre></table></code></div></div><p>当然，在误码率较高的无线链路上可能会需要更为复杂的链路层协议。</p><p>总之，这种数据链路层的协议非常简单：<em>接收方每收到一个帧，就进行 CRC 检验。如 CRC 检验正确就收下，否则就丢弃这个帧，其他 什么也不做</em>。</p><ul><li>封装成帧</ul><p>这是所有链路层协议所必需的。PPP 协议必须规定特殊的字符作为帧定界符，以便使接收端从收到的比特流中能准确第找出帧的开始和 结束位置。</p><ul><li>透明性：请参考”三个基本问题“</ul><p>PPP 协议不能对出现在网络层分组中的数据（首部或者数据）做任何限制。</p><ul><li>多种网络层协议</ul><p>PPP 协议必须能够支持同时运行在相同的物理链路的多种网络层协议，即必须能够在单一点对点连接上多路复用不同的网络层协议。 这个要求意味着 PPP 至少可能需要一个协议类型字段或某种相似的机制，这样接收方的 PPP 就能够将接收的帧向上分解到合适的 网络层协议。</p><ul><li>多种类型链路</ul><p>除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。如运行在以太网上的 PPP，即 PPPoE，这是 PPP 协议能够 适应多种类型链路的一个典型例子。这个协议把 PPP 帧再封装在以太网帧中，而且可以让多个连接在以太网上的用户共享一条道 ISP 的 宽带链路。</p><ul><li>差错检测</ul><p>PPP 接收方必须能够检测到接收帧中的比特差错，并立即丢弃有差错的帧（若继续转发错误帧就会拜拜浪费网络资源）。</p><ul><li>检测连接状态</ul><p>PPP 必须能够检测到链路层次的故障，并且向网络层通知该差错的情况。</p><ul><li>最大传送单元</ul><p>PPP 协议必须对每一种类型的点对点链路设置最大传送单元 MTU 的标准默认值（不过通信双发可以协商具体大小）。如果高层协议发送 的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。</p><p>需要强调的是，MTU 是数据链路层的帧可以载荷的<code class="language-plaintext highlighter-rouge">数据部分</code>的最大长度，而不是该帧的总长度。</p><ul><li>网络层地址协商</ul><p>PPP 协议必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址。因为仅仅在链路层建立了连接 而不知道对方网络层地址时，则还不能够保证网络层能够床送分组。</p><ul><li>数据压缩协商</ul><p>PPP 协议必须提供一种方法来协商使用数据压缩算法，但 PPP 协议并不要求将数据压缩算法进行标准化。</p><blockquote><p>PPP 协议不需要的功能</p></blockquote><p>PPP 协议是不可靠传输协议，只能检测比特差错，只支持点对点全双工链路。因此，不需要纠错、流量控制（交给传输层）、序号。 不支持多点线路，也不支持半双工或单工链路。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-39.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-39.PNG" alt="PPP 帧格式" class="lazyload" data-proofer-ignore></a></p><p>PPP 首部的<em>协议字段</em>表示所携带的数据所遵循的协议类型，以便提交到对应的网络层协议处进行处理。当协议字段为 0x0021，则 PPP 帧的 信息字段就是 IP 数据报；若为 0xC021，则信息字段是 PPP 链路层控制协议 LCP 的数据；若为 0x8021 ，则表示是网络层的控制数据 （IPCP，其为 NCP 协议类中的一种）；另外有，C023:密码鉴权协议 PAP，C223: 握手挑战鉴权协议。最后，对 LCP、IPCP的数据报文 有兴趣的请参考其他资料。</p><p><em>FCS</em> 校验域（FrameCheck Sequence, FCS）为 2 个字节，它计算的是在没有插入任何转义符号前的地址域、控制域、协议域、 信息域内的数据，不包括标志域和校验域。在发送数据时，依次计算上述内容，然后将计算后的结果放入校验域；在接收时， 首先去除转义字符，然后再计算校验。在接收中计算校验时可以将校验域也计算在内，计算的结果应该是固定值 F0B8 (16 进制)。</p><p>帧定界符出现在数据部分时可以使用字节填充，也可以使用零比特填充（请参考“三个基本问题”）。</p><blockquote><p>PPP 协议的工作状态</p></blockquote><p>PPP 协议有三个组成部分：</p><ul><li>一个将 IP 数据报封装到串行链路的方法。<li>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP。<li>一套网络控制协议 NCP，其中的每一个协议支持不同的网络层协议。</ul><p>接下来我们来看看 PPP 协议各个部分是如何协调工作的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-40.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-40.PNG" alt="PPP 工作状态图" class="lazyload" data-proofer-ignore></a></p><p>LCP 协商时，即发送 LCP 的配置请求帧，另一方可以发送以下几种响应中的一种：</p><ul><li>配置确认帧：所有选项都接受。<li>配置否认帧：所有选项都理解但不能接受（如 MTU）。<li>配置拒绝帧：选项有的无法识别或不能接受，需要协商。</ul><p>LCP 配置选项包括链路上的最大帧长、所使用的鉴别协议的规约（如果有的话），以及不使用 PPP 帧中的地址和控制字段（因为这两个字段 的值时固定的，没有任何信息量，可以在 PPP 帧的首部中省略这两个字节）。</p><p>协商结束后双方就建立了 LCP 链路，接着就进入“鉴别”状态，在这一状态，值允许床送 LCP 协议的分组、鉴别协议的分组以及监测 链路质量的分组。若使用口令鉴别协议 PAP，则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。如果需要有更好 的安全性，则可使用更加复杂的口令握手鉴别协议 CHAP。若鉴别身份失败，则转到“链路终止”状态；若鉴别成功，则进入“网络层协议” 状态（可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信）。</p><h3 id="使用广播信道的数据链路层"><span class="mr-2">使用广播信道的数据链路层</span><a href="#使用广播信道的数据链路层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>广播信道可以进行一对多的通信。局域网使用的就是广播信道。局域网有以下特点：</p><ul><li>具有广播功能，可共享硬件和软件资源。<li>便于系统的扩展和逐渐地演变。<li>提高了系统的可靠性、可用性和生存性。</ul><p>局域网可按网络拓扑进行分类。由于<code class="language-plaintext highlighter-rouge">集线器</code>的出现和双绞线大量用于局域网中，星形以太网及多级星型结构的以太网获得了非常 广泛的应用。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-41.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-41.PNG" alt="局域网拓扑" class="lazyload" data-proofer-ignore></a></p><p>必须指出，<em>局域网工作的层次跨越了数据链路层和物理层</em>。局域网使用的拓扑结构意味着要共享信道，这在技术上有两种方法：</p><ul><li>静态划分信道：参见“信道的多路复用技术”。<li>动态媒体接入控制：它有称为多点接入，其特点是信道并非在用户通信时固定分配给用户。这里又分为两类：<ul><li>随机接入：速记接入的特点是所有的用户可随机地发送信息，但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享 媒体上就要产生<code class="language-plaintext highlighter-rouge">碰撞</code>（或冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。<li>受控接入：受控接入的特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和 集中控制的多点线路探询（或称为轮训）。该接入方法已经很少使用了。</ul></ul><p>为了使数据链路层更好地适应多种局域网标准（增加了 LLC），IEEE 802 委员会就把局域网的数据链路层拆成两个子层，即逻辑链路 控制 LLC 子层和媒体接入控制 MAC 子层、与接入到传输媒体有关的内容都放在 MAC 子层，而 LLC 子层则与传输媒体无关，不管采用何种 传输媒体和 MAC 子层的局域网对 LLC 子层来说都是透明的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-42.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-42.PNG" alt="局域网 LLC" class="lazyload" data-proofer-ignore></a></p><p>由于以太网在局域网市场中已经取得了垄断地位，并且几乎成为了局域网的代名词，所以 LLC 子层的作用已经消失了，很多产商生产的 适配器（跨越物理层和数据链路层，提供 MAC 地址）上就仅装有 MAC 协议而没有 LLC 协议。</p><h3 id="csmacd-协议"><span class="mr-2">CSMA/CD 协议</span><a href="#csmacd-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>以太网为了简化和高效，其发送的数据都使用具有自同步能力的慢切斯特编码的信号，其提供的服务时不可靠的交付， 即尽最大努力的交付。当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。但对有差错帧是否需要重传则由高层来决定。 即使重传，以太网也不知道这是重传帧，而是当做新的数据帧来发送。</p><p>载波监听多路访问/冲突检测 CSMA/CD 是一种争用型的介质访问控制协议。它是低于万兆以太网的应用的 MAC 层协议。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>其工作原理是：
</pre></table></code></div></div><p>发送数据前先监听信道是否空闲（<code class="language-plaintext highlighter-rouge">载波监听</code>、<code class="language-plaintext highlighter-rouge">坚持算法</code>）。若空闲，则立即发送数据。在发送数据时，边发送边继续监听。 若监听到冲突（<code class="language-plaintext highlighter-rouge">多点接入</code>、<code class="language-plaintext highlighter-rouge">碰撞检测</code>），则立即停止发送数据，同时发出一个干扰信号（Jam）清除已发出的帧并通知所有 结点“冲突已经发生”，等待一段随机时间（<code class="language-plaintext highlighter-rouge">退避算法</code>）再重新尝试。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-43.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-43.PNG" alt="工作流程" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>碰撞产生的原因：
</pre></table></code></div></div><p>既然每一个站在发送数据之前已经监听到信道为“空闲”，那么为什么还会出现数据在总线上的碰撞呢？这是因为电磁波传输信号存在 延迟（具体原因有：同时检测到空闲并同时发送；检测到空闲，但已经有帧在途中，由于延迟而没有检测到）。 电磁波在 1 km 电缆的传播时延约为 5 μm（应该记住，很多计算都用到）。</p><p>常把总线上的单程端到端（发送端和接收端）传播时延记为 τ。那么，A 发送（假设发给 B ）数据后，最迟要经过多长时间才能知道 自己发送的数据和其他站的数据有没有发生碰撞？极限状态是：当 A 发送的帧快到 B 时，B 却发送开始发送数据，此时发生碰撞 （离开 A 发送该帧的时间已经有 τ），当 B 发出的帧（发生了碰撞）到达 A 时才会被检测出来（又需要 τ），所以这个时间最多是 两倍的总线端到端的传播时延（即为端到端往返传播时延）。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏 情况设计，即取总线两端的两个站（距离最大的两个站）之间的传播时延为端到端传播时延。</p><p>由此可见，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性，而且这一小段时间是不确定的，只有经过 <code class="language-plaintext highlighter-rouge">争用期（又称为碰撞窗口）</code>（以太网的端到端往返时间）这段时间还没有检测到碰撞，才能肯定这次发送不会发送碰撞。</p><p>显然，在使用 CSMA/CD 协议时，一个站不可能同时进行发送和接收。因此使用 CSMA/CD 协议的以太网不可能进行全双工通信而只能 进行双向交替通信（半双工通信）。</p><blockquote><p>坚持算法</p></blockquote><p>载波监听时，信道空闲则依据一定的坚持算法来决定如何发送（占用信道的一方，刚发往一帧需要等帧间最小间隔为 9.6 μs后，再执行 坚持算法）。</p><p>坚持算法分为以下三类：</p><ul><li>1-持续 CSMA：始终坚持监听，若空闲则立即发送。<li>feud持续 CSMA：等待随机的一段时间再发送。<li>p-持续 CSMA：发送方按 P 概率发送帧。p 的取值比较困难，打了会产生冲突，小了会延长等待时间而降低通信效率。</ul><blockquote><p>碰撞检测</p></blockquote><p>以太网规定争用期为 512 bit（即64字节，也是以太网最小帧长）时间，帧间最小间隔时间为 96 bit. 对于 10M 以太网的争用期为 51.2 μs，帧间最小间隔时间为 9.6 μs。</p><p>CSMA 只能减少冲突，不能完全避免冲突，以太网使用退避算法中的一种（截断的二进制指数退避算法）来解决发送数据的碰撞问题。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>退避算法：
</pre></table></code></div></div><p>这种算法规定：发生碰撞的站在信道空闲后并不立即发送数据，而是推迟一个随机时间（避免同步）再进入发送流程。 这种方法减少了重传时再次发生碰撞的概率。</p><p>具体算法如下：</p><ul><li>（1）设定基本退避时间为争用期 2 τ。 <a href="/assets/img/it_basic/network/basic/internet-basic-44.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-44.PNG" alt="退避算法" class="lazyload" data-proofer-ignore></a><li>（3）当重传达 16 次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突），则丢弃该帧，并向高层报告。</ul><p>我们可以看出，以太网在发送数据时，如果帧的前 64 字节没有发送冲突（如果发现信号变化幅度超过一定限度，则表明发生冲突）， 那么后续的数据就不会发送冲突。因此以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常终止的 无效帧，收到了这种无效帧就必须应当立即丢弃。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-45.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-45.PNG" alt="802 体系" class="lazyload" data-proofer-ignore></a></p><p><em>传输介质一般使用 10Base-T 形式进行描述</em>。其中 10 是速率，即 10 Mb/s；Base 是基带，Broad 是宽带；而 T 则代表传输介质， T 是双绞线，F 是光纤，</p><h1 id="以太网">以太网</h1><p>在将局域网的代表以太网前，先简单概述下局域网。局域网 LAN 是一种在有限的地理范围内将大量 PC 机及各种设备互连在一起，实现 数据传输和资源共享的计算机网络。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>局域网的主要特点：
</pre></table></code></div></div><ul><li>网络所覆盖的地理范围比较小。<li>高传输率和低误码率。<li>局域网一般采用同轴电缆、双绞线等建立单位内部专用线（而广域网多租用公用线或专用线路）。<li>局域网与广域网侧重点不完全一样。局域网侧重共享信息的处理，而广域网一般侧重共享位置准确无误及传输的安全性。</ul><p>决定局域网的主要技术主要涉及拓扑结构（如星形、环形、总线形或树形）、传输媒体和媒体访问控制等三项技术问题。局域网的传输 形式有两种：基带传输与宽带传输。介质访问控制方法主要有五类：固定分配、按需分配、适应分配、探询访问和随机访问。局域网的 主要硬件设备有：网卡、集线器、网络传输介质和中继器、网桥、路由器、网关等网络互连设备。</p><h2 id="以太网的信道利用率"><span class="mr-2">以太网的信道利用率</span><a href="#以太网的信道利用率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CSMA/CD 要求载波监听、随机发送、碰撞退让等，所以信道的利用率不可能达到 100%；</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-46.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-46.PNG" alt="以太网信道被占用情况" class="lazyload" data-proofer-ignore></a></p><p>组理想的情况是不发生碰撞（着当然就不是 CSMA/CD 了），即没有上图中的争用期，也就只剩下从接口发出帧的时间和传播时延（图中 统称为“占用信道时间”）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-47.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-47.PNG" alt="以太网信道被利用率" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-48.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-48.PNG" alt="以太网信道参数" class="lazyload" data-proofer-ignore></a></p><h2 id="以太网的-mac-层"><span class="mr-2">以太网的 MAC 层</span><a href="#以太网的-mac-层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>MAC 层的硬件地址</p></blockquote><p>在局域网中，硬件地址又称为物理地址或 MAC 地址（应为这种地址用在 MAC 帧中）。IEEE 802 标准为局域网规定了一种 48 位的 全球地址（一般简称为“地址”），是指局域网上的每一台计算机中<code class="language-plaintext highlighter-rouge">固化在适配器的 ROM 中的地址</code>（同一台电脑换了网络 适配器也就意味着该地址发生了改变）。</p><p>严格地讲，<code class="language-plaintext highlighter-rouge">局域网的”地址“应当是每一个站的”名字“或标识符</code>。请注意，如果连接在局域网上的主机或路由器安装有多个 适配器，那么这样的主机或路由器就有多个“地址”。更准确些说，这种 48 位“地址”应当是某个接口的标识符。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-49.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-49.PNG" alt="MAC 地址" class="lazyload" data-proofer-ignore></a></p><p>现在 IEEE 的注册管理机构 RA 是局域网全球地址（相对于本地管理而言）的法定管理机构，它负责分配地址字段的 6 个字节中的前 三个字节给制造商。地址字段中的后三个字节则是由厂家自行指派，只要保证生产处的适配器没有重复地址即可。</p><p>我们知道，适配器具有过滤功能。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧则 收下，然后再进行其他处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站 的帧“包括以下三种帧：</p><ul><li>单播帧（一对一）：即收到的帧的 MAC 地址与本站的硬件地址相同。<li>广播帧（一对全体）：即发送给本局域网上所有站点的帧（全 1 地址）。<li>多播帧（一对多）：即发送给本局域网上一部分站点的帧。</ul><p>所有的适配器都至少应当能够识别前两种帧（即单薄和广播地址）。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就 把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p><p>以太网适配器还可设置为一种特殊的工作方式，即混杂方式。工作在混杂方式的适配器只要“听到”有帧在以太网上传输就都悄悄地接受下来， 而不管这些帧是发往哪个站的（窃听但不中断其他站点的通信）。</p><h2 id="mac-帧的格式"><span class="mr-2">MAC 帧的格式</span><a href="#mac-帧的格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>下图是 MAC 帧的格式已经在物理层的再次封装。顺便指出，在使用 SONET/SDH 进行同步传输时则不需要用前同步码，因为在同步传输 时收发双方的位同步总是一直保持着。在以太网上传送数据时是以帧为单位传送。以太网传送阵时，各帧之间还必须有一定的间隙。 因此，接收端只要找到帧开始定界符，其后面的连续到达的比特流就都属于同一个 MAC 帧。可见以太网不需要使用帧结束定界符，也不需要 使用字节插入来保证透明传输。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-50.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-50.PNG" alt="MAC 帧" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IEEE 802.3 标准规定凡出现以下情况之一的即为无效的 MAC 帧：
</pre></table></code></div></div><ul><li>帧的长度不是整数个字节；<li>用收到的帧检验序列 FCS 查出有差错；<li>收到的帧的 MAC 客户数据字段长度不在 46~1500 字节之间。</ul><p>对于检查出的无效 MAC 帧就简单地丢弃，以太网不负责重传丢弃的帧。</p><p>IEEE 802.3 标准规定的 MAC 帧格式与上图的格式的区别就是两个地方：</p><ul><li>第三个字段是“长度/类型”</ul><p>当这个字段值大于 0x0600（即 1536），就表示“类型”；否则表示 MAC 帧的数据部分的“长度”。</p><ul><li>当“长度/类型”字段值小于 ox0600 时，数据字段必须装入上面的 LLC 子层的 LLC 帧（LLC 帧已经失去了意义）。</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-51.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-51.PNG" alt="类型字段含义列表" class="lazyload" data-proofer-ignore></a></p><h2 id="扩展以太网"><span class="mr-2">扩展以太网</span><a href="#扩展以太网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>有时候需要把以太网的覆盖范围扩展。可以在物理层、数据链路层、网络层等扩展网络，</p><h3 id="在物理层拓展以太网"><span class="mr-2">在物理层拓展以太网</span><a href="#在物理层拓展以太网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>以太网上的主机之间的距离不能太远，否则主机发送的信号经过铜线的传输就会衰减到使 CSMA/CD 协议无法正常工作。在过去广泛使用 粗缆或细缆以太网时，常使用工作在物理层的<code class="language-plaintext highlighter-rouge">转发器</code>（两站之间最多可以经过三个电缆网段）来扩展以太网的地理覆盖范围。但 随着双绞线以太网成为主流，转发器已经很少使用了。</p><p>现在，扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对）和一对光纤调制解调器。如果使用多个<code class="language-plaintext highlighter-rouge">集线器</code>， 就可以连接成覆盖更大范围的多级新型结构的以太网。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-52.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-52.PNG" alt="集线器" class="lazyload" data-proofer-ignore></a></p><p>这样做的可以有以下两个好处：</p><ul><li>能跨几个小局域网进行通信<li>扩大了以太网覆盖的地理范围。</ul><p>但这种多级结构的集线器以太网也带来了一些缺点：</p><ul><li>将各自独立的碰撞域变成了一个更大更严重的碰撞域。<li>如果不同的小局域网使用的以太网技术不同（如数据率不同），那么就不可能用传统的集线器互连起来。</ul><h3 id="在数据链路层扩展以太网"><span class="mr-2">在数据链路层扩展以太网</span><a href="#在数据链路层扩展以太网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在数据链路层扩展以太网要使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。当网桥收到一个 帧时，并不是向所有的借口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到相应的接口，或者是把它丢弃（过滤， 当转发接口和进入网桥的接口一致时，说明是同一个网段，不需要转发，直接丢弃）。、</p><p>网桥依靠转发表（也叫作转发数据库或路由目录，至于此表如何得出，请参见“透明网桥”）来转发或过滤帧。网桥是通过内部的接口 管理软件和网桥协议实体来完成转发和过滤操作的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-53.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-53.PNG" alt="网桥" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>使用网桥带来的好处：
</pre></table></code></div></div><ul><li>过滤通信量、增大吞吐量（因为隔开了碰撞域、各个网段保持各自的通信速率）。<li>扩大了物理范围、提高了可靠性（各个网段的故障被隔离）。<li>可互连不同物理层、不同 MAC 子层和不同速率的以太网。</ul><p>网桥也有一些缺点，如：</p><ul><li>使用网桥转发增加了处理时延。<li>MAC 子层并没有流量控制功能。当网络上的符合很重时，网桥中的缓存可能溢出，导致帧丢失。<li>网桥只适合于用户数不太多和通信量不太大的以太网，否则有时还会因传播过多的广播信息而产生网络拥塞（因为网桥不过滤广播帧） 。这就是所谓的<code class="language-plaintext highlighter-rouge">广播风暴</code>。</ul><p>注意，连个网桥之间还可使用一段点到点链路（可能使用 PPP 协议）；网桥在转发帧时，不该表帧的源地址。</p><blockquote><p>透明网桥（2-4个端口）</p></blockquote><p>目前使用最多的网桥是<code class="language-plaintext highlighter-rouge">透明网桥</code>，其保准是 IEEE 802.1D 。“透明”是指以太网上的结点并不知道所发送的帧将经过哪几个 网桥，以太网上的站点都看不见以太网上的网桥。透明网桥是一种即插即用设备，意思是只要把网桥接入局域网，不用人工培植转发表， 网桥就能工作。</p><p>当网桥刚刚连接到以太网时，其转发表是空的。网桥通过<code class="language-plaintext highlighter-rouge">自学习算法</code>处理收到的帧。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>网桥的自学习算法：
</pre></table></code></div></div><ul><li>网桥工作在混杂方式下先收下进来的所有帧。<li>记下转发表中没有的地址（帧源地址）和对应的接口（有则更新时间或接口），并转发出去</ul><p>自学习算法原理：某帧从某接口进来，其携带的源 MAC 地址说明一定可以通过该接口找到该 MAC 地址（即当其作为目的 MAC 地址时）。 如果源 MAC 地址不在转发表中，则可根据前述原理将源 MAC 地址和对应接口登记到转发表的地址和接口栏。 如果该帧携带的目的 MAC 地址不在转发表中则将其转发到其他所有端口。</p><ul><li>重复上述过程就可以逐渐健全转发表，如此就可以利用转发表实现过滤和转发功能了。</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-54.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-54.PNG" alt="网桥自学习算法" class="lazyload" data-proofer-ignore></a></p><p>实际上，在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间，以便用于更新转发表。因为以太网上的所有工作站 并非总是接通电源的。把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。具体的做法是，网桥中 的接口管理软件周期性地扫描转发表中的项目。只要是在一定时间（如几分钟）以前登记的都要删除，这样就使得网桥中的转发表能反映 当前网络的最新拓扑状态。</p><p>透明网桥还使用了一个<code class="language-plaintext highlighter-rouge">生成树算法</code>，即互连在一起的网桥在进行<code class="language-plaintext highlighter-rouge">彼此通信</code>后，就能找出原来的网络拓扑的一个子集。在这个 子集里，整个连通的网络中不存在回路，即在任何两站之间只有一条路径（但不一定是最佳路径）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-55.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-55.PNG" alt="需要生成树算法的原因" class="lazyload" data-proofer-ignore></a></p><p>为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p><blockquote><p>源路由网桥</p></blockquote><p>透明网桥的最大优点就是容易安装，一接上就能工作。但是，网络资源的利用还不充分。因此，另一种由发送帧的源站负责路由选择的 <em>源路由网桥</em>问世了。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> 源路由网桥的工作原理：
</pre></table></code></div></div><ul><li>主机配置网桥的标识以及连接到的相应的各个网段。<li>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中。<li>源站以广播方式向欲通信的目的站发送一个发现帧，每个发现帧都记录所经过的路由。<li>发现帧到达目的站时就沿各自的路由返回源站。<li>源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。<li>凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息。</ul><p>源路由网桥对主机不是透明的，主机必须知道网桥的标识以及连接到哪一个网段上。使用源路由网桥可以利用最佳路由。若在两个 以太网之间使用并联的源路由网桥，则可使通信量较平均地分配给每一个网桥。用透明网桥则只能使用生成树，而使用生成树一般并 不能保证所使用的路由是最佳的，也不能在不同的链路中进行负载均衡。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-56.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-56.PNG" alt="两种网桥比较" class="lazyload" data-proofer-ignore></a></p><blockquote><p>以太网交换机</p></blockquote><p>交换式集线器常称为以太网交换机或第二层交换机，表明这种交换机工作在数据链路层。<em>以太网交换机实质上就是一个多接口的透明 网桥</em>（意味着自学习和生成树算法参考透明网桥）。此外，以太网交换机的每个接口都直接单个主机或另一个集线器相连 （注意：普通网桥的接口往往是连接到以太网的一个网段），并且一般都工作在全双工方式。当主机需要通信时， 交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>交换模式：
</pre></table></code></div></div><p>交换机将数据从一个端口转发到另一个端口的处理方式称为<code class="language-plaintext highlighter-rouge">交换模式</code>。交换模式有以下三种：</p><ul><li>存储转发：存储校验（适合普通或劣质链路）转发。<li>直通交换：</ul><p>交换机只读出数据帧的前 6 个字节，即通过地址映射表查找目标地址以确定转发端口，不进行校（适合质量好的链路））验就直接转发这个数据帧。</p><ul><li>分段过滤（或称碎片丢弃）</ul><p>接收到 64 字节（进行冲突检测，适合一般链路）就查目标地址进行转发。可见存储转发模式最慢，直通交换最快。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>交换机与其他设备的比较：
</pre></table></code></div></div><div class="table-wrapper"><table><tbody><tr><td> <td>交换机<td>网桥<td>集线器<tr><td>延迟<td>小<td>大<td>小<tr><td>端口<td>多<td>少<td>多<tr><td>碰撞域<td>接口级隔离<td>网段级隔离<td>不能隔离<tr><td>广播域<td>不隔离<td>不隔离<td>不隔离<tr><td>带宽<td>接口独占<td>网段独占<td>共享<tr><td>传输模式<td>全双工<td>半或全双工<td>半双工<tr><td>工作层次<td>数据链路层<td>数据链路层<td>物理层<tr><td>主要功能实现方式<td>硬件<td>软件<td>硬件<tr><td>功能<td>转发/过滤帧，虚拟局域网等<td>过滤/转发帧<td>比特整形放大</table></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>碰撞域（冲突域）：
</pre></table></code></div></div><p>物理网段（冲突域）：链接在同一导线上的所有物理层设备或工作站的集合。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>广播域：
</pre></table></code></div></div><p>逻辑网段（广播域）：限制以太网广播报文的范围。一般来说，逻辑网段定义了第三层网络，如 IP 子网等。</p><h3 id="虚拟局域网"><span class="mr-2">虚拟局域网</span><a href="#虚拟局域网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>利用以太网交换机可以很方便地实现<em>虚拟局域网</em>，在 <code class="language-plaintext highlighter-rouge">IEEE 802.1Q</code>标准中，对虚拟局域网 VLAN 是这样定义的：</p><p>虚拟局域网是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段只有某些共同的需求。每一个 VLAN 的帧都 有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。</p><p><em>虚拟局域网其实只是局域网给用户提供的一种胡武，而并不是一种新型局域网</em>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-57.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-57.PNG" alt="虚拟局域网示意图" class="lazyload" data-proofer-ignore></a></p><p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息（“广播风暴”）而引起性能恶化。</p><p>IEEE 802.3ac 标准定义了以太网的帧格式的扩展，以便支持虚拟局域网。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-58.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-58.PNG" alt="MAC 帧格式扩展" class="lazyload" data-proofer-ignore></a></p><h2 id="无线局域网"><span class="mr-2">无线局域网</span><a href="#无线局域网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这里只讲述冲突的解决方案。EEE 802.11标准使用一种名为<em>载波侦听多路访问／冲突避免（CSMA/CA）</em>的方法来避免冲突。 注意，IEEE 802.3有线网络是检测冲突，而IEEE 802.11网络是<code class="language-plaintext highlighter-rouge">尽可能避免冲突</code>。</p><p>为实现冲突避免，要求所有工作站在传输每帧前进行侦听，当工作站有帧需要发送时，面临的将是下列情况之一：</p><ul><li>① 没有其他设备在传输数据，工作站可立刻传输其帧，接收工作站必须发送一个确认帧， 确认原始帧已在没有发生冲突的情况下到达。<li>② 另一台设备正在传输，工作站必须等待，等到当前帧传输完毕后，它再等待一段随机时间，然后传输自己的帧。</ul><p>无线帧的长度不是固定的，一个工作站传输其帧时，其他工作站如何知道该帧已传输完毕，可以使用无线介质呢？显然，工作站可以进行侦听，等待静默期的到来，但这样做并非总是有效的，其他工作站也在侦听，可能同时决定开始传输。IEEE 802.11标准要求所有工作站在开始传输前等待一段时间， 这段时间被称为<code class="language-plaintext highlighter-rouge">DCF帧间间隔</code>（DCF Interframe Space , DIFS）。</p><p>传输工作站可以在IEEE 802.11报头中包含一个<code class="language-plaintext highlighter-rouge">持续时间值</code>，以指出传输完当前帧所需的大概时间。 持续时间值包含传输完当前帧所需要的时隙数（单位通常为毫秒），其他无线工作站必须查看持续时间值， 并在考虑传输数据前等待相应的时间。</p><p>由于<code class="language-plaintext highlighter-rouge">每个侦听站在传输的帧中看到的持续时间值相同</code>，因此它们都可能在这段时间过去后决定传输自己的帧，这可能导致冲突。 所以，在实际中，除持续定时器外，每个无线工作站还必须实现一个随机后退定时器，传输帧之前， 工作站必须选择一个要等待的随机时隙数，这个数字位于0和最大争用窗口值之间。这里的基本思想是， 准备传输的工作站必须等待一段随机时间，以减少试图立即传输的工作站数量。 这个过程被称为<code class="language-plaintext highlighter-rouge">分布式协调功能</code>（Distributed Coordination Function，DCF），</p><p>由于<code class="language-plaintext highlighter-rouge">后退定时器</code>是随机的，多台工作站仍可能选择相同的退避时间，因此，无法防止这些工作站同时传输数据，进而导致冲突。 这样，在无线网络中将会出现传输错误，而接收站不会返回确认，为此发送站必须考虑重新发送其帧。</p><p>最后，工作站在其随机后退定时器过期后并准备传输数据时，如果发现有人正在传输， 该如何办呢？它必须再等待当前正在传输的帧的持续时间、DIFS时间和随机后退时间。</p><h1 id="网络层">网络层</h1><p>网络层的作用从表面上看极为简单，即使=将分组从一台发送主机移动到一台接收主机。为此，需要两种重要的网络层功能：</p><ul><li>转发：</ul><p>当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。该部分的主要内容涉及到路由器的内部 结构、数据报的分组转发、IP 协议、网络层编址（IPv4、IPv6）、网络地址转换（NAT）、ICMP、网络的划分等。</p><ul><li>选路（或路由）</ul><p>当分组从发送方流向接收方时，网络层决定这些分组所采用的路由或路径。计算这些路径的算法被称为<code class="language-plaintext highlighter-rouge">路由算法</code>。</p><h2 id="网络层提供的两种服务"><span class="mr-2">网络层提供的两种服务</span><a href="#网络层提供的两种服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>网络层可以提供两种服务：面向连接的和无连接的服务。这实质上是可靠的传输服务应该由哪一层负责实现的问题。</p><h3 id="虚电路"><span class="mr-2">虚电路</span><a href="#虚电路" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有些人认为应当借助于电信网的成功经验，让网络层负责可靠交付，使用面向连接的通信方式。 对于面向连接的服务，我们需要一个虚电路网络。其工作原理如下：隐藏在虚电路背后的思想是避免为每个要发送的数据报选择新路径。</p><p>一条虚电路（VC）的组成如下：</p><ul><li>源和目的主机之间的路径（即一系列链路和路由器）<li>VC号，沿着该路径的每段链路一个号码<li>沿着该路径的每台路由器中的转发表项。</ul><p>属于一条虚电路的分组将在它的首部携带一个 VC 号（可类比虚拟局域网 VLAN）。 因为一条虚电路在每条链路上可能具有不同的 VC 号（这样可以简化处理，避免对所有虚电路进行协同处理来确定相同的编号）， 所以每台中间路由器必须用一个新的 VC 号替代每个传输分组的 VC 号（这种方式可以减少分组首部中的 VC 字段长度）。 该新的 VC 号从转发表获得。</p><p>虚电路有三个明显不同的阶段：</p><ul><li>虚电路建立：使用路由算法建立一条虚电路（也可人工配置），为沿途路由器分配 VC 号，增加转发表项，预留虚电路沿途所需资源等。<li>数据传送：一旦创建了虚电路，分组就可以开始沿着该虚电路流动了。<li>数据传送：进行虚电路建立的逆过程。</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-63.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-63.PNG" alt="虚电路路由过程" class="lazyload" data-proofer-ignore></a></p><p>在有些上下文中，这个过程称为标签交换。一种面向连接的网络服务例子是多协议标签互换（MPLS），让主要被用在 Internet 的 ISP 网络，IP 数据报被一个有 20 位连接标识或标签的 MPLS 头包裹着。MPLS 往往对客户端是隐藏的，客户看不到这些标签，ISP 用它来 为超大流量建立长期的连接；但是，当服务质量变得很重要而且还需要协助其他 ISP 完成流量管理任务时，MPLS 的作用越来越突出。</p><h3 id="无连接的数据报服务"><span class="mr-2">无连接的数据报服务</span><a href="#无连接的数据报服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>和电信系统终端不同的是，计算机网络的端系统是有只能的计算机，计算机有很强的差错处理能力，因此应该将可靠的传输服务由端系统 负责（即由上层的传输层负责）。</p><p>因特网采用的设计思路是这样的：<em>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</em>。 网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。网络层不提供 服务质量的承诺。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。</p><p>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应有。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-59.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-59.PNG" alt="两种服务的对比" class="lazyload" data-proofer-ignore></a></p><h2 id="网际协议-ip"><span class="mr-2">网际协议 IP</span><a href="#网际协议-ip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>网际协议 IP 是 TCP/IP 体系中最主要的协议之一。与 IP 协议配套使用的还有四个协议：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-60.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-60.PNG" alt="IP 配套协议" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-61.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-61.PNG" alt="IP 配套协议图" class="lazyload" data-proofer-ignore></a></p><p>使用 IP 协议使得无数复杂差别各异的网络成为了一个虚拟互连网络（虚拟的 IP 网）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-62.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-62.PNG" alt="虚拟互连网" class="lazyload" data-proofer-ignore></a></p><p>一般俩说，将网络互连起来需要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><ul><li>物理层使用的中间设备叫做<code class="language-plaintext highlighter-rouge">转发器</code>（如集线器）。<li>数据链路层使用的中间设备叫做<code class="language-plaintext highlighter-rouge">网桥或桥接器</code>（如透明网桥、以太网交换机）<li>网络层使用的中间设备叫做<code class="language-plaintext highlighter-rouge">路由器</code>。<li>在网络层以上使用的中间设备叫做<code class="language-plaintext highlighter-rouge">网关</code>。</ul><p>接下来条轮网络互连时都是指用路由器进行网络互连和路由选择。<em>路由器其实就是一台专用计算机，用来在互联网中进行路由选择</em>。</p><h3 id="分类的-ip-地址"><span class="mr-2">分类的 IP 地址</span><a href="#分类的-ip-地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位 （IPv 4）的标识符。IP 地址 现在由因特网名字与号码指派公司 ICANN 进行分配。</p><p>IP 地址的编址方法共经历了三个历史阶段。这三个阶段是：</p><ul><li>分类的 IP 地址。<li>子网的划分。<li>构成超网。</ul><p>这几个阶段的演变实际上就是为了更加充分的利用显得有点不足的 IP 地址，最后不得已引进了 IPv6。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>分类的 IP 地址
</pre></table></code></div></div><p>所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是<code class="language-plaintext highlighter-rouge">网络号</code>。 它标志主机（或路由器）所连接到的网络，一个网络号在整个因特网范围内必须是唯一的。第二个字段是<code class="language-plaintext highlighter-rouge">主机号</code>，它标志该主机 （或路由器）。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，<em>一个 IP 地址在整个因特网范围内是唯一 的</em>。</p><p>这种两极的 IP 地址可以定义为：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}
</pre></table></code></div></div><p>下表中 A 类、B 类和 C 类地址都是<code class="language-plaintext highlighter-rouge">单薄地址（一对一通信）</code>，是最常用的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-64.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-64.PNG" alt="分类的 IP 地址" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-65.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-65.PNG" alt="IP 地址十进制记法" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-66.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-66.PNG" alt="IP 地址指派范围" class="lazyload" data-proofer-ignore></a></p><p>下表给出了一般不适用的特殊 IP 地址。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-67.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-67.PNG" alt="特殊 IP 地址" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 地址的重要特点：
</pre></table></code></div></div><ul><li>IP 是分等级的地址结构</ul><p>IP 地址的网络号由 IP 地址管理机构分配，而剩下的主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号 来转发分组（不考虑目的主机的主机号），这样就可以使路由表中的项目数大幅度减少，从而减少了路由表所占的存储空间以及查找 路由表的时间。</p><ul><li>IP 地址标志网络端口</ul><p>实际上 IP 地址时标志一个主机（或路由器）和一条链路的接口。当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应 的 IP 地址，其网络号必须是不同的。这种主机称为<code class="language-plaintext highlighter-rouge">多归属主机</code>。可见路由器至少有两个或多个不同的 IP 地址。</p><ul><li>公平性</ul><p>在 IP 地址中，所有分配到网络号的网络都是平等的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 观点看待局域网
</pre></table></code></div></div><p>按照因特网的观点，一个网络是指具有相同网络号的主机的集合。因此<em>用转发器或网桥连接起来的若干个局域网仍然是一个网络</em>。因此， 具有不同网络号的局域网必须使用路由器进行互连。</p><p>下图使用过三个路路由器连接三个局域网的例子：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-68.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-68.PNG" alt="路由器连接局域网" class="lazyload" data-proofer-ignore></a></p><p>可见：</p><ul><li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。<li>用网桥互连的网段仍然是一个局域网，只能有一个网络号。<li>当两个路由器相连时，在连线两端的接口处，可以分配也可以不分配 IP 地址（相当于点对点链路，如此不分配的叫做无编号网络 或无名网络）。</ul><h3 id="划分子网"><span class="mr-2">划分子网</span><a href="#划分子网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>前面说过的分类的 IP 地址时两极结构，设计的不够合理：</p><ul><li>IP 地址空间利用率有时很低。如 申请了一个 A 类网络号，却只有几十台主机。<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。<li>两级 IP 地址不够灵活。</ul><p>为了解决上述问题，在 IP 地址中又增加了一个 “子网号字段”，使两极 IP 地址变成了三级 IP 地址。这种做法叫做<code class="language-plaintext highlighter-rouge">划分子网</code> 或子网寻址或子网路由选择。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>划分子网的基本思路如下：
</pre></table></code></div></div><ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网，划分子网纯属一个单位内部的事情。本单位意外的网络看 不见这个网络是多少个子网组成，因为这个单位对外仍然表现为一个网络。<li>划分子网的方法是从网络的主机号借用若干为作为子网号，当然主机号也就相应减少了同样的位数。于是两级 IP 地址在本单位 内部就变成了三级 IP 地址：网络号、子网号、主机号。<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器 在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付给目的主机。</ul><p>通过这种方式就减轻了主干网上路由器所需存储的网络号项数，从而层层降低了网络造价。</p><blockquote><p>子网掩码</p></blockquote><p>假定一个数据报已经进入到一个与各子网互连的主干路由器，那么该路由器应怎样转发到特定的子网所在的路由器呢？</p><p>从 IP 数据报的首部并不知道源主机或目的主机所连接的网络是否进行了子网的划分（因为两极 IP 没有子网的信息，而三级 IP 是 面向单位内部的，外面是不知道的）。因此必须另想办法，这就是使用<code class="language-plaintext highlighter-rouge">子网掩码</code>。</p><p><em>子网掩码将作为网络号和子网号对应的所有为位取 1，而剩下的主机号对应的所有位取 0 得到</em>（然后一般再将其使用十进制记法）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>子网号计算
</pre></table></code></div></div><p>用子网掩码和收到的数据报的目的 IP 地址对应位相与便可得到子网号。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-69.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-69.PNG" alt="子网号计算" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>使用子网掩码的好处就是：
</pre></table></code></div></div><p>不管网络有没有划分子网（都必须在路由器的路由表中有子网掩码这一栏，没有划分子网者使用针对网络号的默认子网掩码， 可方便查找路由表和统一算法），只要把子网掩码和 IP 地址进行逐位的“与”运算（这完全可以用硬件实现）， 就立即得出网络地址来。这样在路由器处理到来的分组时就可以采用同样的算法（不论是单位内部还是外部的路由器）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-70.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-70.PNG" alt="默认子网掩码" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>下图是一个具体的子网划分例子：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-71.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-71.PNG" alt="子网划分示例" class="lazyload" data-proofer-ignore></a></p><p>可见，划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-72.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-72.PNG" alt="划分子网下的分组转发" class="lazyload" data-proofer-ignore></a></p><h3 id="构造超网"><span class="mr-2">构造超网</span><a href="#构造超网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难。然而仍然面临着以下困难：IP 地址已分配所剩不多，主干网上的路由表项 急剧增加。</p><p>同一个网络划分子网使用的子网号是固定位数的，为解决面临的困难，使用变长子网掩码 VLSM 可进一步提高 IP 地址资源的利用率。 在 VLAM 的基础上又进一步研究出<code class="language-plaintext highlighter-rouge">无分类编址</code>方法，即<code class="language-plaintext highlighter-rouge">无分类域间路由选择 CIDR</code>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>CIDR 最主要的特点有两个：
</pre></table></code></div></div><ul><li>（1）无分类编址</ul><p>CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念。CIDR 把 32 位的 IP 地址划分为两个部分。前面的部分是 <code class="language-plaintext highlighter-rouge">“网络前缀”</code>（或简称为“前缀”），用来指明网络，后面的部分则用来指明主机。因此，CIDR 使 IP 地址从三级编址（使用子网掩码） 又回到了两极编址，但这已是无分类的两极编址。</p><p>CIDR 一般使用“斜线记法”或称为 CIDR 记法，即在 IP 地址后面加上斜线“/”，然后写上网络前缀所占的位数。</p><ul><li>CIDR 地址快</ul><p>CIDR 把网络前缀都相同的连续的 IP 地址组成一个 “CIDR 地址快”。我们只要知道 CIDR 地址快中的任何一个地址，就可以知道这个 地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-73.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-73.PNG" alt="CIDR 地址快" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>地址掩码（为兼容可称为子网掩码）
</pre></table></code></div></div><p>为了更方便地进行路由选择，CIDR 使用 32 位的地址掩码。地址掩码是一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。 <em>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</em>。</p><p>请注意，“CIDR 不适用子网”是指 CIDR 并没有在 32 位地址中指明若干位作为子网字段。但分配到一个 CIDR 地址块的组织，仍然可以 在本组织内根据需要划分出一些子网。这些子网也都只有一个网络前缀和一个主机号字段，但子网的网络前缀比整个组织的网络前缀 更长些。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>CIDR 的不同记法形式：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-74.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-74.PNG" alt="CIDR 的不同记法形式" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>路由聚合
</pre></table></code></div></div><p>由于一个 CIDR 地址快中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常常成为<code class="language-plaintext highlighter-rouge">路由聚合</code>， 它使得路由表中的一个项目可以表示原来传统分类地址的很多个路由。路由聚合也称为<code class="language-plaintext highlighter-rouge">构成超网</code>。具体见下图示意。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-75.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-75.PNG" alt="CIDR 举例" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-76.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-76.PNG" alt="CIDR 举例" class="lazyload" data-proofer-ignore></a></p><p>可见，把四个系的路由聚合为大学的一个路由（即构成超网），是将网络前缀缩短。<em>网络前缀越短，其地址块所包含的地址数就越多</em>。 而在三级结构中，划分子网是使网络前缀变长。</p><blockquote><p>使用 CIDR 的分组转发</p></blockquote><p>使用 CIDR 时，路由器每个项目由“网络前缀”和“下一跳地址”组成，但是在查找路由表时可能会得到不止一个匹配结果，那如何 选择呢？</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>最长前缀匹配
</pre></table></code></div></div><p>应当从匹配结果中选择具有最长网络前缀的路由。这叫做<code class="language-plaintext highlighter-rouge">最长前缀匹配</code>（又称为最长匹配或最佳匹配）。因为网络前缀越长， 它指明的网络约具体。</p><p>已经确定了最长匹配原则，那么如何查找路由表找出最长前缀匹配呢？</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>使用二叉线索查找路由表
</pre></table></code></div></div><p>对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。这样查找次数太多，最坏的情况是路由表中没有这 路由。对于默认的路由查找都要经历最多-1次不必要的查找。</p><p>为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用 的是<code class="language-plaintext highlighter-rouge">二叉线索</code>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-77.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-77.PNG" alt="使用二叉线索查找路由表" class="lazyload" data-proofer-ignore></a></p><p>以上只是给出了二叉线索这种数据结构的用法，并没有说明“与唯一前缀匹配”和“与网络前缀匹配”的关系。显然，要将二叉线索 用于路由表中，还必须使<code class="language-plaintext highlighter-rouge">二叉线索中的每一个叶子结点包含所对应的网络前缀和子网掩码</code>。当搜索到一个叶结点时，就必须寻找匹配 的目的地址和该叶结点的子网掩码进行逐位“与”运算，看结果是否与对应的网络前缀相匹配。若匹配，就按下一跳的接口转发该分组。 否则，就丢弃该分组。</p><p>为了提高二叉线索的查找速度，广泛使用各种<code class="language-plaintext highlighter-rouge">压缩技术</code>，以减少层次数。如没有分叉就可以将其作为一个结点。例如，上图中的最后两个 地址，其最前面的 4 位都是 1011.欧美从。只要一个地址的前 4 位是 1011，就可以跳过前面 4 位（即压缩了 4 个层次） 而直接从第 5 位开始比较。</p><h2 id="ip-地址与硬件地址的联系"><span class="mr-2">IP 地址与硬件地址的联系</span><a href="#ip-地址与硬件地址的联系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>从层次的角度来看，物理地址时数据链路层和物理层使用的地址。而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-78.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-78.PNG" alt="IP 与硬件地址的区别" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>区别总结如下：
</pre></table></code></div></div><p>总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及 以下使用的是硬件地址。当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就称为 MAC 帧的数据，因而在数据链路层 看不见数据报的 IP 地址。当然传输过程中 IP 地址不变，而硬件地址发生相应的改变。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-79.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-79.PNG" alt="IP 与硬件地址的区别" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>需要强调的是：
</pre></table></code></div></div><ul><li>（1）在 IP 层抽象的互联网上只能看到 IP 数据报。数据报中间经过的路由器的 IP 地址并不出现在其转发的 IP 数据报中。<li>（2）虽然在 IP 数据报首部有源站 IP 地址，但路由器只根据目的站的 IP 地址的网络号进行路由选择。<li>（3）在局域网的链路层，只能看见 MAC 帧。<li>（4）尽管互连在一起的网络的硬件地址体系各不相同，但 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层 上讨论问题，就能够使用同一的、抽象的 IP 地址研究主机和知己或路由器之间的通信。</ul><h3 id="arp-和-rarp"><span class="mr-2">ARP 和 RARP</span><a href="#arp-和-rarp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>前面说到在 IP 数据报传送过程中，MAC 帧的首部地址字段都会改变，那么主机或路由器怎样知道应当在 MAC 帧的首部填入什么样 的硬件地址呢？换句话说，怎么根据 IP 地址找到相应的物理地址或者反过来。而地址接卸协议 ARP 和逆地址解析协议 RARP 就是 用来解决这样的问题的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-80.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-80.PNG" alt="地址解析协议" class="lazyload" data-proofer-ignore></a></p><p>其中逆地址解析协议 RARP 已经包含在 DHCP 协议中了。这里不再赘述。</p><p>网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的 硬件地址之间由于格式不同而不存在简单的映射关系，而且主机或主机网卡可能改换也会是某个网络中的硬件地址集发生改变。为此， 地址解析协议 ARP 解决这个问题的方法是：</p><p>在主机 ARP 高速缓存中赢存放一个从 IP 地址到硬件地址的映射表（该表有本局域网上目前正工作的个主机和路由器的 IP 地址 到硬件地址的映射表），并且这个映射表还经常动态更新（新增或超时删除）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ARP 映射表的建立：
</pre></table></code></div></div><p>首先来看下 ARP 映射表已经建立后是如何被使用的。假设当主机 A 要向本局域网上的某个主机 B 发送 IP 数据报时，就现在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址。再把这个硬件地址写入 MAC 帧，然后 通过局域网把该 MAC 帧发往此硬件地址（实际上是群发的，只不过其他站对照自己的 MAC 地址，然后丢弃了，路由器或交换机也可能 启动过滤进程）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>也有可能查不到主机 B 的 IP 地址的项目（可能 B 刚入网或主机 A 刚启动而 ARP 缓存是空的）。在这种情况下：
</pre></table></code></div></div><ul><li>本机（主机 A） ARP 进程</ul><p>主机 A 就会自动运行 ARP 进程向本局域网广播一个 ARP 请求分组，该分组的主要内容是：“我的 IP 是 xxx…x，硬件地址是 xx-…-xx。我想 知道 IP 地址为 xx…xx 的主机的硬件地址。“</p><ul><li>其他主机 ARP 进程</ul><p>本局域网上所有的主机 ARP 进程都收到了该广播的 ARP 请求帧，然后对照自己的 IP 地址。只有 IP 地址对应者才会用单播的方式 发送 ARP 相应分组给予回应。</p><ul><li>主机 A 根据收到的 ARP 相应分组提取有用信息添加到 ARP 缓存的映射表中。下次就不需要再进行类似的过程了。</ul><p>当 ARP 映射表中信息过时（如主机 B 更换了网络适配器或者已经被删除），仍然按照该表进行发送，则会出现发送失败， 那么同样会启动前面的过程对映射表进行更新。</p><p>请注意，<em>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题</em>。如果索要找的主机和源主机不再同一个 局域网上怎么办呢？</p><p>事实上可以通过局域网的路由器（该路由器在本局域网中，可以使用 ARP ）转发到下一跳路由器（由路由表得到吓一跳的 IP 地址， 然后 ARP 得到下一跳的 MAC 地址）而进入另一个局域网（又可启用 ARP）中，如此通过不断 地转发，不断地从一个局域网到另一个局域网，如此就可以不断地通过更换的 MAC 地址转发出去并找到目的主机了。</p><p>可见，要使用 ARP 有以下典型情况（其他是这些的组合）：</p><ul><li>主机之间通信（同一个局域网中）<li>路由器与主机间（出网或到目的主机）<li>路由器之间（跨网中）</ul><p>从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>既然数据传输过程中必须用到硬件地址，
那么为什么不直接用硬件地址通信而还要使用 IP 地址？
</pre></table></code></div></div><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址，要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址 转换工作，而且中间的硬件地址都有可能变化，所以完成这样的工作简直是不可能的事情。如以太网的 MAC 地址的单播是通过 硬件布线实现的（既然是硬件地址当然通过硬件来实现了），如果进入到使用不同地址格式的网络中， 那比对地址的硬件结构就需要改变了，如果中途相邻的硬件地址发生了改变（如更换了网络设配器）， 那么其他相邻结点的硬件地址布线也应该随着改变，可见这样是及其不方便、不灵活和不透明的。</p><h2 id="ip-数据报格式"><span class="mr-2">IP 数据报格式</span><a href="#ip-数据报格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>IP 数据报的格式能够说明 IP 协议具有的功能。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-81.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-81.PNG" alt="IP 数据报格式" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 数据报分片示例：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-82.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-82.PNG" alt="IP 分片举例" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 首部校验和
</pre></table></code></div></div><p>在发送数据时，为了计算数 IP 据报的校验和。应该按如下步骤：</p><ul><li>1）将校验和字段置为0,然后将 IP 包头按 16 比特分成多个单元，若 IP 首部不是偶数字节，则填充一个全0字节；<li>2）对各个单元采用反码加法运算(即高位溢出位会加到低位,通常的补码运算是直接丢掉溢出的高位)。<li>3）将最终得到的和的反码填入校验和字段；发送数据包。</ul><p>在接收数据时，计算数据报的校验和相对简单，按如下步骤：</p><ul><li>1）将 IP 包头按 16 比特分成多个单元，若 IP 首部不是偶数字节，则填充一个全0字节；<li>2）对各个单元采用反码加法运算，检查得到的和是否符合是全1或全0；<li>3）如果是全1则进行下步处理,否则意味着包已变化从而丢弃之。</ul><p>二进制反码求和：先进行二进制求和，然后对和取反。需要强调的是<em>反码和是采用高位溢出加到低位的</em>， 如 3比特的反码和运算：100b+101b=010b(因为100b+101b=1001b,高位溢出1，其应该加到低位，即001b+1b(高位溢出位)=010b)。</p><h2 id="ip-层转发分组的流程"><span class="mr-2">IP 层转发分组的流程</span><a href="#ip-层转发分组的流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>值得强调的是，在网络层只有具有网络层的路由器（专用计算机）和主机才能转发 IP 分组。实际上，转发 IP 分组可以认为是 路由器之间的通信。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-83.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-83.PNG" alt="路由表举例" class="lazyload" data-proofer-ignore></a></p><p>从上图的简化图中，可以看到，在互联网上转发分组时，是从一个路由器转发到下一个路由器，最后知道路由器直接交付目的主机。 路由器可采用<code class="language-plaintext highlighter-rouge">默认路由</code>，可减少路由表项。对于只连接了一个路由器的主机网络可免去查找比对路由表的过程。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>如何找到下一跳路由器？
</pre></table></code></div></div><p>既然 <em>IP 数据报中始终没有下一跳路由器的 IP 地址（只有一直不变的源 IP 地址和目的 IP 地址）</em>，那么呆转发的数据报又怎样 能够找到下一跳路由器呢？</p><p>事实上，下一跳的 IP 地址（<code class="language-plaintext highlighter-rouge">为何不直接使用硬件地址</code>，因为不同网络的硬件地址格式可能各异，长度不同， 会导致路由算法的复杂法，开销更大；使用统一格式和长度的 IP 地址代表这些硬件地址就简单多了） 是写入在路由表中的，只需要查找出来，然后使用 ARP 得出对应的硬件地址并将原来的 IP 数据报 封装在 MAC 帧中从对应的接口发送出去，然后根据这个硬件地址（<code class="language-plaintext highlighter-rouge">此处能不能不用硬件地址呢？</code>不能，因为路由器可能不是 用点对点链路连接的，可能也连在多个路由器共享的链路上）就可以找到下一跳路由器。</p><p>由此可见，当发送一连串的数据报时，上述的这种查找路由表、计算硬件地址、写入 MAC 帧的首部等过程，将不断地重复进行， 造成了一定的开销（为的是层层简化问题）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 分组转发算法：
</pre></table></code></div></div><ul><li>（1）从 IP 数据报中首部提取目的主机的 IP 地址 D，得出（得出的方法请参考划分子网和构成超网一节）目的网络地址为 Ｎ。<li>（2）若 N 就是与此路由器直接相连的某个网络地址，则进行<code class="language-plaintext highlighter-rouge">直接交付</code>，不需要再转发到其他路由器；否则就是间接交付， 执行（3）。<li>（3）若路由表中有目的地址为 D 的<code class="language-plaintext highlighter-rouge">特定主机路由</code>，则把数据报传送给路由表所指明的下一跳路由器；否则，执行（4）。<li>（4）若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）。<li>（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行（6）。<li>（6）报告转发分组出错。</ul><h2 id="icmp-协议"><span class="mr-2">ICMP 协议</span><a href="#icmp-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>IP 提供的尽力数据报通信服务无连接服务，而并不能解决网络低层的数据报丢失、重复、延迟或乱序等问题， TCP 在 IP 基础建立有连接服务解决以上问题，不能解决网络故障或其它网络原因无法传输的包的问题。</p><p>所以， 网际控制报文协议 ICMP 设计的本意就是希望对 IP 包无法传输时提供报告， ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。这些差错报告帮助了发送方了解为什么无法传递， 网络发生了什么问题，确定应用程序后续操作。</p><p>但 ICMP 不是高层协议，而是 IP 层协议。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-84.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-84.PNG" alt="ICMP 报文格式" class="lazyload" data-proofer-ignore></a></p><h3 id="icmp-报文的种类"><span class="mr-2">ICMP 报文的种类</span><a href="#icmp-报文的种类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ICMP 报文的种类有两种：ICMP 差错报告报文和 ICMP 询问报文。这是由 ICMP 报文格式中的类型字段决定的。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-85.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-85.PNG" alt="ICMP 类型代码" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>徐颖发送 ICMP 差错报告报文的情况：
</pre></table></code></div></div><ul><li>ICMP不能用来报告 ICMP 消息的错误，这样就避免了无限循环。当 ICMP 查询消息时通过发送 ICMP 来响应。<li>对于被分段的数据报，ICMP 消息只发送关于第一个分段中的错误。 也就是说，ICMP 消息永远不会引用一个具有非 0 片偏移量字段的 IP 数据报。<li>响应具有一个广播或组播（多播）目的地址的数据报时，永远不会发送ICMP消息<li>对具有特殊地质（请参见 IP 分类地址一节）的数据报不发送 ICMP 差错报告报文。</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-86.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-86.PNG" alt="ICMP 差错报文格式" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>源站抑制
</pre></table></code></div></div><p>没有一种机制可以告诉源站，拥塞程度已经减轻，因为可以按照原来的速率发送数据报。源站应继续降低发送速率， 直到不再收到更多的源站抑制报文为止。</p><p>在多对一的通信中，许多个源站产生的数据报都必须由路由器或目的主机来处理。在这种情况下， 有的会以低速率发送而有的则以高速率发送，这就导致了源站抑制报文在发送后，路由器或主机并不知道哪一个源站应对拥塞负责。 它可能丢弃从不非常低速率的源站法来的数据报，而没有丢弃真正产生拥塞的源站所发来的数据报。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>超时
</pre></table></code></div></div><p>有两种情况需要发送超时报文。一种是路由器把数据报的生存时间减至零时，路由器丢弃数据报，并向源主机发送超时报文； 另一种是在规定的时间内没有收到所有的分片时，它就丢弃所有的分片，并向源站发送了超时报文。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>下面对改变路由报文进行简短的解释：
</pre></table></code></div></div><p>出于效率的考虑，连接在网络上的主机的路由表一般都采用人工配置，并且主机不和连接在网络上的路由器定期交换路由信息。 在主机刚开始工作时，一般都在路由表中设置了一个默认路由器的IP地址。不管数据报要发送到哪个目的地址， 都一律先将数据报传送给网络上的这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由。 如果默认路由器发现主机发往某个目的地址的数据报的最佳路由不应当经过默认路由器，而是应当经过网络上的另一个路由器R时， 就用改变路由报文将此情况报告主机。</p><p>于是，该主机就在其路由表中增加一项：到某某目的地址应经过路由器R（而不是默认路由器）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ICMP 应用
</pre></table></code></div></div><p>有三种基于ICMP的简单而广泛使用的应用为：Ping ， Traceroute，MTU 测试。</p><ul><li>ping</ul><p>Ping 命令利用了ICMP两种类型的控制消息：“echo request”（回显请求）、“echo reply”（回显应答）。 Ping 是应用层直接使用网络层ICMP的一个例子。它没有通过运输层的TCP或UDP.</p><p>比如在主机 A 上执行ping命令，目标主机是 B。在 A 主机上就会发送“echo request”（回显请求）控制消息， 主机 B 正确接收后即发回“echo reply”（回显应答）控制消息，从而判断出双方能否正常通信。</p><p>如果在 A 主机上能够 ping 通 B 主机，那么主机 A 上显示的信息就是从主机 B 上返回来的“回显应答”。 如果不能 ping 通，主机 A 上显示的信息则是由系统自身所产生的错误提示。顺便提一下：回显应答中有“time”和“TTL”信息。</p><ul><li>Traceroute</ul><p>源主机向目的主机发送一连串 IP 数据报，数据报中封装的是无法交互的 UDP 用户数据报。</p><p>它把一个 TTL 为 1 的 IP 数据报发送给目的主机。第一个路由器把 TTL 减小到 0，丢弃该数据报并把 ICMP 超时消息返回给源主机。 这样，路径上的第一个路由器就被标识了。随后用不断增大的TTL值重复这个过程直至该数据报到达目的主机。此时数据报的 TTL 是 1 ，主机不转发数据报，也不把 TTL 值减 1 。但因 IP 数据报中封装的是无法交付的运输层的 UDP 用户数据报，因此目的主机要向 源主机发送 ICMP 终点不可达差错报告报文。</p><p>这样，源主机达到了自己的目的，因为这些路由器和最后的目的主机发来的 ICMP 报文正好给出了源主机想知道的路由信息—-到达 目的主机所经过的路由器的 IP 地址，以及到达其中的每一个路由器的往返时间。</p><ul><li>确定 MTU</ul><p>确定路径MTU的方法是“要求报告分片但又不被允许” 的 ICMP 报文。</p><ul><li>1、将IP数据报的标志域中的分片 BIT 位置 1，不允许分片。<li>2、当路由器发现 IP 数据报长度大于 MTU 时，丢弃数据报，并发回一个要求分片的 ICMP 报文。<li>3、将 IP 数据报长度减小，分片 BIT 位置 1 重发，接收返回的 ICMP 报文的分析。<li>4、发送一系列的长度递减的、不允许分片的数据报，通过接收返回的 ICMP 报文的分析，可确定路径 MTU。</ul><p>常见的ICMP网络攻击手段</p><ul><li>利用ICMP echo数据包进行DOS攻击<li>利用ICMP重定向报文进行IP欺骗与窃听<li>利用ICMP路由器广播报文进行IP欺骗<li>利用ICMP隧道机制绕过防火墙进行信息获取和远程控制</ul><h2 id="路由选择协议"><span class="mr-2">路由选择协议</span><a href="#路由选择协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面提到的大部分内容是关于分组转发的，简单说来，分组转发就是按照路由表把分组转发到相应的接口。而路由（或选路）选择协议 是产生路由表信道的。路由选择协议的核心就是路由算法，即需要何种算法来获得并填充路由表中的各项目。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>一个理想路由算法的特点：
</pre></table></code></div></div><ul><li>（1）正确性和完整性：</ul><p>所有染着路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</p><ul><li>（2）计算简单：算法的开销要小。<li>（3）要有自适应性（或“稳健性”）：能自动适应通信量和网络拓扑变化。<li>（4）稳定性：一定网络条件下，路由算法应收敛于一个可以接受的解，而不应该使得出的路由不断地变化。<li>（5）公平性<li>（6）最佳的：路由选择算法应当能够找出最好的路由。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</ul><p>一个世纪的路由选择算法，应尽可能接近于理想的算法。在不同的应用条件下，对以上提出的也可由不同的侧重。</p><p>应当指出，路由选择是个非常复杂的问题。因为：</p><ul><li>它是网络中的所有结点共同协调工作的结果。<li>路由选择的环境往往是不断变化的（且无法事先知道）。<li>当网络发生拥塞是，需要选择信息很难获取，从而很难对缓解拥塞有所作为。</ul><p>从适应网络变化的角度可将路由选择算法分为两类：</p><ul><li>静态路由选择策略（也叫非自适应路由选择）：人工配置简单小网络。<li>动态路由选择策越（也叫自适应路由选择）：实现复杂且开销大，适用于较复杂的大网络。</ul><h3 id="分层次的路由选择协议"><span class="mr-2">分层次的路由选择协议</span><a href="#分层次的路由选择协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因特网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。至少由于以下两个原因，因特网采用分层次的 路由选择协议：</p><ul><li>规模大：这将导致路由表过大和路由器通信占用过多带宽。<li>管理自治：隐藏内部路由器细节的管理上的需要。</ul><p>这两个问题都可以通过将路由器组织进自治系统 AS 来解决。自治系统 AS 的经典定义是：</p><ul><li>AS 内部路由器使用相同的路由技术和协议（即<code class="language-plaintext highlighter-rouge">内部路由选择策略一致</code>）<li>AS 对外的路由器应和其他 AS 对外的路由器保持一致的路由选择策略（即<code class="language-plaintext highlighter-rouge">外部路由选择策略一致</code>）。</ul><p>因此，路由选择协议也自然划分为两大类：</p><ul><li>内部网关（或路由）协议 IGP（或 IRP）：在一个自治系统内部使用的路由选择协议。如 RIP 和 OSPF 协议。<li>外部网关（或路由）协议 EGP（或 ERP）：跨越自治系统的路由就就需要 EGP 了。如 BGP-4.</ul><p>自治系统之间的路由选择也叫<code class="language-plaintext highlighter-rouge">域间路由选择</code>，这些路由器被称为<code class="language-plaintext highlighter-rouge">网关路由器</code>，可见网关路由器充当了双重角色， 在内测运行 IGP 类协议，在外侧运行 EGP 类协议；而在自治系统内部的路由选择叫做<code class="language-plaintext highlighter-rouge">域内路由选择</code>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-87.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-87.PNG" alt="自治系统内外协议" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>当一个自治系统非常大时，
那如何进一步分层呢？
如何分最好呢？
</pre></table></code></div></div><p>前面已经说过了，分层路由可以减少每个路由器中路由表项数，但这里需要强调的是，这种空间的节省不是免费得来的，它需要付出 代价，其代价就是增加了路径长度（经过的路由器多了，查找路由表的次数也增加了）。如何分层请看下面的例子：</p><p>考虑一个具有 720 个路由器的子网：</p><ul><li>如果没有分层，每个路由器需要 720 个路由表项；<li>如果分成 24 个区域，每个区域 30 个路由器，那么每个路由器只需要 30 个本地表项（本地路由器），加上 23 个远程表项目， 总共 53 个表项（网关路由器）；<li>如果采用三级层次结构，总共 8 个簇，每个簇包含 9 个区域，每个区域 10 个路由器，那么，每个路由器需要 10 个表项用于 记录本地路由器，8 个表项用于到同一簇内其他区域的路由，7 个表项用于远程的簇，总共 25 个表项。</ul><p>有人发现：*对于一个包含 N 个路由器的网络，最优的层数是 ln N，每个路由器所需的路由器表项是 eln N 个。他们还证明了， 由于分层路由器而导致的平均路径长度的实际增长非常小，通常是可以接受的。</p><h2 id="路由选择算法的理论基础"><span class="mr-2">路由选择算法的理论基础</span><a href="#路由选择算法的理论基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>计算机网络中的路由器可以看做数据结构中图的结点，而路由器之间的通路可以看成图中的有向边（因为源路由到目的路由 是有方向），并且每条计算机链路上有耗时长短、流量大小等指标（相当于有向边上的权值），这样计算机网络中路由器之间的关系 就可以用有向带权图来简化了。从而转化成图论和数据结构中图的相关问题了。</p><h3 id="优化原则"><span class="mr-2">优化原则</span><a href="#优化原则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>最优化路径（可参考数据结构中的 单源点最短路径一节）的一般陈述如下：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>全局最优必是局部最优，
反之不然，因为局部可能有多个最优。
</pre></table></code></div></div><p>具体到计算机网络的表述是：如果路由器 J 在从路由器 B 到路由器 S 的最优路径上，那么从 J 到 S 的最优路径也必定遵循同样 的路由（可用反证法证明）。</p><p>最为最优化原则的一个直接结果，从所有的源到一个指定目标的最优路径的集合构成了一颗以目标节点为根的树，这样的树称为 <code class="language-plaintext highlighter-rouge">汇集树</code>。所欲路由算法的目标是为所有路由器按照一定的度量找到这样的汇集树。举例（途中举例度量是跳数）如下：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-88.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-88.PNG" alt="最优化原则举例" class="lazyload" data-proofer-ignore></a></p><p>请注意，汇集树不一定是唯一的，有可能存在具有相同路径长度的其他汇集树。如果我们允许选择所有可能的路径，则树就变成了 更一般的结构，称为<code class="language-plaintext highlighter-rouge">有向无环图（DAG）</code>。</p><p>由于汇集树确实是一棵树，它不包含任何环，所以每个数据报将在有限的跳数内完成传递。然而，实际情形并非如此简单。在运行 过程中，链路和路由器可能会出故障，然后又恢复运行。所以，不同的路由器对当前拓扑结构的了解可能有所不同。为此，炫耀做出 以下选择：每台路由器是独立地获取用于计算汇集树的信息，还是通过相互交换或其他方式获取这些信息。不过， <code class="language-plaintext highlighter-rouge">最优化原则和汇集树为评估其他路由算法提供了一个基准</code>。</p><h3 id="最短路径"><span class="mr-2">最短路径</span><a href="#最短路径" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>详细请参考数据结构中的“最短路径”。这里强调一下，除了调数和物理距离外，还可以用许多其他度量来标识路径长短，例如， 带宽、平均流量、通信成本、平均延迟等其他因素（或综合因素）的一个函数。通过改变函数的权重，路由算法就可以根据任何一种 标准或多种标准的组合来计算“最短”路径。</p><h3 id="泛洪算法"><span class="mr-2">泛洪算法</span><a href="#泛洪算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在实现路由算法时，由于分层路由规则，每个路由器必须根据本地知识而不是网络的全貌做决策。一个简单的本地技术是<code class="language-plaintext highlighter-rouge">泛洪</code>， 这种技术将每一个入境数据报发送到除了入境链路外的每条出境线路。</p><p>很显然，泛洪法会产生大量的重复数据报。这里列举两种抑制方法：</p><ul><li>设置跳数限制。</ul><p>不过带有跳计数器的泛洪能够差生随着跳数增大而指数增长的重复数据报，而且路由器会复制以前已经看到过的数据报（虽然路由器 不知道）。</p><ul><li>序号标记泛洪数据报</ul><p>可以让路由器跟踪已经泛洪过的数据报，从而避免第二次发送它们。实现这个目标的一种方式是让每个源路由器在接收来自主机的 数据报填上一个序号，然后每个路由器为每个源路由器准备一张表，记录已经观察到的来自源路由器的序号。如果入境数据报在这张表中， 它就不能再泛洪到其他路由器。</p><p>为了防止该表无线地膨胀，每个表应该使用一个计数器 k 作为参数，它表示直到 k 的所有序号都已经观察到了（这样序号为 k 及其 以前的序号就不需要存储在该表中了）、当一个数据报抵达是，很容易检查该数据报是否已经被泛洪过（只需要将该数据报的序号与 k 和表中的序号比对即可）。如果是被泛洪过，则丢弃该数据报、</p><p>饭后会发送大量数据报，有时候对实际的网络是不现实的。不过泛洪途径的<code class="language-plaintext highlighter-rouge">鲁棒性非常好</code>，不论有多少路由器被破坏了， 只要存在到目的站的路径就一定能找到。泛洪需要的安装很少，路由器仅仅需要知道自己的邻居即可。这意味着， <code class="language-plaintext highlighter-rouge">泛洪可以作为其他路由算法的基本构件，那些算法更有效但需要更多的处理</code>。</p><p>而<code class="language-plaintext highlighter-rouge">泛洪还可以用作其他路由算法进行比较的性能度量</code>，因为泛洪能并发地选择每一条可能的路径， 因此总能选出最短的那条路径，没有其他算法（很多算法只是求得相对最佳的路径）能够产生一个更短的延迟 （忽略泛洪过程本身开销）。</p><h2 id="内部网关协议-rip"><span class="mr-2">内部网关协议 RIP</span><a href="#内部网关协议-rip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>路由信息西医 RIP 是一种分布式的基于距离向量的路由选择协议，是内部网关协议 IGP 中的一员。其最大的优点就是简单。</p><h3 id="rip-特点"><span class="mr-2">RIP 特点</span><a href="#rip-特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RIP 协议将“距离（或跳数）”定义如下：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>直接交付主机的路由器的跳数定位 1（即每条链路的“费用”为 1）。
从一路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。
</pre></table></code></div></div><p>RIP 协议认为好的路由就是它通过的路由器的数据要少，即“距离短”、RIP 允许一条路径最多只能包含 15 个路由器。因此 “距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型互联网。</p><p>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由，哪怕还存在另一条高速（低时延）但路由器较多 的路由。</p><p>RIP 协议是分布式路由选择协议，需要不断地和其他路由器交换路由信息，那么和哪些路由器交换信息，交换什么信息，在什么时候 交换信息呢？</p><ul><li>仅和相邻路由器交换信息。<li>交换的是各自的整个路由表。<li>按固定时间间隔交换路由信息。</ul><h3 id="距离向量算法"><span class="mr-2">距离向量算法</span><a href="#距离向量算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>距离向量算法是这样工作的：每个路由器维护一张表（即一个矢量），表中列出了当前已知的到每个目标的最佳距离，以及所使用的 链路。这些表通过邻居之间定时的相互交换信息而不断被更新，最终每个路由器都了解整个自治系统的所有最佳路由信息。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>具体算法步骤：
</pre></table></code></div></div><ul><li>（1）修改接收到的邻居（设为 X）路由表所有表项</ul><p>把”下一跳“字段中的地址都改成 X，并把所有”距离“字段的值加 1.每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。</p><ul><li>（2）将修改后邻居路由表整合到本路由器的路由表。<ul><li>若自己原来的表中没有目的网络 N，则添加该项；否则，<li>若下一跳地址相同（都是 X），则替换旧有项；否则，<li>若收到的项目中的距离 d 小一些，则进行更新替换；否则，<li>什么也不做。</ul><li>（3）保持活性，否则不可达</ul><p>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把下一跳为该路由器的路由表项的距离 置为 16 （距离为 16 表示不可达）。</p><ul><li>重复上述过程。</ul><p>由上可知，<em>虽然所有路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然应当是 不同的（如下一跳的地址等）</em>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>RIP 协议的优缺点：
</pre></table></code></div></div><p>RIP 协议的最大的优点就是实现简单、开销较小。但 RIP 协议的缺点也较多：</p><ul><li>RIP 限制了网络的规模（最大距离为 15）<li>交换的是完整路由表，随着网络规模的扩大，开销也就增加。<li>好消息转得块，坏消息传得满，使更新过程的收敛时间过长。</ul><p>因此，对于规模较大的网络就应当使用同类的 OSPF 协议。</p><h3 id="rip-协议的报文格式"><span class="mr-2">RIP 协议的报文格式</span><a href="#rip-协议的报文格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RIP 2 可以支持变长子网掩码和 CIDR。此外，RIP 2 还提供简单的鉴别过程支持多播。RIP 协议使用运输层的用户数据报 UDP 进行 传送（使用 UDP 端口 520）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-89.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-89.PNG" alt="RIP 报文格式" class="lazyload" data-proofer-ignore></a></p><p>RIP2 还具有简单的鉴别功能，若使用鉴别功能，则将原来写入第一个路由信息（20 字节）的位置用作鉴别。这是应将地址簇标识符 置为全 1（即 0xFFFF），而路由标识写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由歇息，但这时最多只能 再放入 24 个路由信息。</p><h2 id="内部网关协议-ospf"><span class="mr-2">内部网关协议 OSPF</span><a href="#内部网关协议-ospf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>就像 RIP 一样，开放最短路径优先 OSPF 协议也被广泛用于因特网中的 AS 内部选路。OSPF 通常被设置在较顶层的 ISP 中，而 RIP 却被设置在较低层 ISP 和企业网中。</p><p>OSPF 被认为是 RIP 的后继者。然而，*OSPF 的核心就是一个使用泛洪链路状态信息的链路状态协议和一个 Dijkstra 最低费用路径算法。 <code class="language-plaintext highlighter-rouge">使用 OSPF 的每台路由器构建了一幅相同关于整个自治系统的完整拓扑图</code>。于是，路由器在本地运行 Dijkstra 最短路径算法， 以确定一个以自身为根结点的到所有子网的最短路径树（汇集树）。各条链路费用是由网络管理员配置的。</p><h3 id="ospf-算法"><span class="mr-2">OSPF 算法</span><a href="#ospf-算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>使用 OSPF 时，路由器向自治系统内所有其他路由器广播选路信息，而不仅仅是向其相邻路由器广播。每当一条链路的转台发生变化 时，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地广播链路状态。</p><p>而 RIP 协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由，但却不知道全网的拓扑结构（只有到了下一跳路由器， 才能知道再下一跳应当怎样走）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>链路状态路由算法：
</pre></table></code></div></div><p>OSPF 使用的链路状态路算法的设计思想非常简单，可以用五个部分加以描述。每一个路由器必须完成以下的事情，算法才能正常工作：</p><ul><li>（1）发现它的邻居结点，并了解其网络地址。（<code class="language-plaintext highlighter-rouge">发现邻居</code>）<li>（2）设置到每个邻居结点的距离或者成本度量值。（<code class="language-plaintext highlighter-rouge">设置链路成本</code>）<li>（3）构造一个包含所有所有刚刚获知的链路信息包（关于邻居的）。（<code class="language-plaintext highlighter-rouge">构造链路状态包</code>）<li>（4）将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。（<code class="language-plaintext highlighter-rouge">分发链路状态包</code>）<li>（5）就算出自己到每个其他路由器的最短路径。（<code class="language-plaintext highlighter-rouge">计算新路由</code>）</ul><p>OSPF 的链路状态数据库能够较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得块是其重要有点。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>OSPF 区域划分：
</pre></table></code></div></div><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<code class="language-plaintext highlighter-rouge">区域</code>。每个居于都有一个 32 位的区域标识符。当然，一个区域也不能太大，在一个区域内的路由器最好不超过 200 个。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-90.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-90.PNG" alt="OSPF 区域划分" class="lazyload" data-proofer-ignore></a></p><p>每个区域都运行自己的 OSPF 链路状态选路算法，一个区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。因此， 一个区域的内部细节对于该区域外的偶遇路由器来说都是不可见的。区域内选路仅涉及同一区域内的那些路由器。</p><p>可见，<code class="language-plaintext highlighter-rouge">划分区域的好处</code>就是把利用洪泛交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的 通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况（可见,每台路由器的 OSPF 的链路状态数据库也会小很多，可节省存储量和计算最短路径的时间等开销）。为了使每一个区域能够和本区域以外的区域进行通信。 如上图，OSPF 使用<code class="language-plaintext highlighter-rouge">层次结构的区域划分</code>。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由<code class="language-plaintext highlighter-rouge">区域边界路由器</code> 进行概括。</p><ul><li>内部路由器：</ul><p>内部路由器位于非主干区域且只执行 AS 内部选路。</p><ul><li>区域边界路由器：</ul><p>区域边界路由器同时属于区域与主干两个区域。</p><ul><li>主干路由器（非边界路由器）：</ul><p>主干路由器执行主干中的选路，但其自身不是区域边界路由器。内部路由器通过该区域中的主干路由器， 从信息（基本上是链路状态通告，但通告的是到另一个区域的路由费用，而不是链路费用）广播中知道存在通向其他区域的路由。</p><ul><li>边界路由器：</ul><p>边界路由器与属于其他自治系统的路由器交换选路信息。例如，这台路由器也许会使用 BGP 执行 AS 间的选路。其他路由器正是 通过这样的边界路由器才知道通向外部网络的路径。</p><p>从上面可以知道，采用分层次划分区域的方法虽然是交换信息的种类增多了，同时也使 OSPF 协议更加复杂了。但这样做却能使每一个 区域内部交换路由器信息的通信量大大减少。因而使 OSPF 协议能够用于规模更大的自治系统中。</p><h3 id="ospf-与-rip-的对比"><span class="mr-2">OSPF 与 RIP 的对比：</span><a href="#ospf-与-rip-的对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>所有在 OSPF 路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</p><p>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定， 链路状态序号增长速率不得超过每 5 秒钟一次。这样，全部序号空间在 600 年内不会产生重复号。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>OSPF 与 RIP 比较列表如下：
</pre></table></code></div></div><div class="table-wrapper"><table><tbody><tr><td> <td>RIP<td>OSPF<tr><td>算法<td>距离矢量路由<td>链路状态路由<tr><td>度量<td>跳数<td>带宽、延迟等可自设费用<tr><td>信息交换单位<td>整个路由表<td>邻居链路状态<tr><td>信息承载方<td>UDP<td>直接 IP数据报<tr><td>交换方式<td>相邻交换<td>组播链路状态<tr><td>信息更新方式<td>无视变化定期<td>有变则组播出去、即使无变也定期<tr><td>网络概念结构<td>平面<td>分层次划分区域<tr><td>安全机制<td>简单鉴别<td>可启用复杂鉴别<tr><td>变化适应<td>收敛慢<td>收敛快<tr><td>知晓信息<td>全 AS 距离及下一跳<td>全网拓扑结构<tr><td>个性信息<td>下一跳及距离<td>汇集树<tr><td>使用规模<td>较小网络<td>较大网络<tr><td>最短路径<td>一条<td>可多条<tr><td>负载均衡<td>无<td>较弱<tr><td>多播<td> <td>支持<tr><td>复杂性<td>简单<td>复杂</table></div><h3 id="ospf-报文格式"><span class="mr-2">OSPF 报文格式</span><a href="#ospf-报文格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>OSPF 不用 UDP 而是<code class="language-plaintext highlighter-rouge">直接用 IP 数据报（协议字段值为 89）传送</code>。OSPF 构成的数据报很短，这样做可减少路由信息的通信量。 数据报很短的另一好处是：可以不必将长的数据报分片传送。而分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而 整个数据报就必须重传。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-91.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-91.PNG" alt="OSPF 报文格式" class="lazyload" data-proofer-ignore></a></p><ul><li>类型 1：<code class="language-plaintext highlighter-rouge">问候(Hello)分组</code>，用来发现和维持邻站的可达性（每隔10s交换一次，若有 40s 未收到则不可达）。<li>类型 2：<code class="language-plaintext highlighter-rouge">数据库描述分组</code>，向邻站给出自己的链路状态数据库中所欲链路状态项目的摘要信息。<li>类型 3：<code class="language-plaintext highlighter-rouge">链路状态请求分组</code>，向对方请求发送某些链路状态项目的详细信息。<li>类型 4：<code class="language-plaintext highlighter-rouge">链路状态更新分组</code>，用泛洪法对全网更新链路状态。链路状态更新分组共有五种不同的链路状态（略）。<li>类型 5：<code class="language-plaintext highlighter-rouge">链路状态确认分组</code>，对链路更新分组的确认。</ul><p>后面四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的链路状态数据库的内容是一样的。两个同步的路由器 叫做“完全邻接的”路由器，不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有达到一致。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-92.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-92.PNG" alt="OSPF 的基本操作" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-93.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-93.PNG" alt="OSPF 广播方法" class="lazyload" data-proofer-ignore></a></p><h2 id="外部网关协议-bgp"><span class="mr-2">外部网关协议 BGP</span><a href="#外部网关协议-bgp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>BGP 是不同 AS 的路由器之间交换路由信息的协议（或边界网关协议）。</p><p>为什么 AS 间和 AS 内部需要不同的选路协议呢？基于以下几个原因：</p><ul><li>策略：比如安全保密性，商业关系、各个 ISP 的服务质量考量对流量进行分流等而人为的设定路由偏好或路由限制。<li>规模：AS 内部路由选择协议可以自行划分层次，而对于 AS 间就有些不现实了（因为各有各的策略）。<li>性能：由于 AS 间选路是面向策略的，因此所用路由的质量或性能通常是次要的问题。AS 之间甚至没有与路由相关的费用概念。而 在一个 AS 内部选路就特别注重最短路径。</ul><p>可见，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由（毕竟 由于各个 ISP 采取的策略不同，甚至对外隐藏了比较好的路由，同时也没有费用等性能指标的概念）。 <em>BGP 采用了<code class="language-plaintext highlighter-rouge">路径向量路由选择协议</code></em>,它与距离向量协议和链路状态协议都有很大的区别。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>BGP 算法概述
</pre></table></code></div></div><p>在配置 BGP 时，每一个 AS 的管理员要选择至少一个路由器作为该 AS 的“<code class="language-plaintext highlighter-rouge">BGP 发言人</code>”。一般说来，两个 BGP 发言人都是 通过一个共享网络连接在一起的，而 BGP 发言人往往就是<code class="language-plaintext highlighter-rouge">BGP 边界路由器</code>。但也可以不是 BGP 边界路由器。</p><p>一个 BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息，就要先建立 TCP 连接（端口号 179），然后再此连接上交换 BGP 报文以 建立 BGP 会话，利用<code class="language-plaintext highlighter-rouge">BGP 会话</code>交换路由信息（如更新路由信息或报告差错等）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-94.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-94.PNG" alt="BGP 发言人" class="lazyload" data-proofer-ignore></a></p><p>BGP 所交换的网络可达性的信息就是要到达某个网络（用网络前缀表示，聚合路由从而减少了路由项）索要经过的一系列 AS。当 BGP 发言人就根据所采用的策略从收到的路由信息中找出各 AS 的较好路由。实际上就是构造出 AS 连通图，它是树形结构，不存在回路。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-95.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-95.PNG" alt="BGP 例子" class="lazyload" data-proofer-ignore></a></p><p>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络锁要经过的 AS 序列。由于使用了 路径向量的信息，就可以很容易避免产生兜圈子的路由。如果一个 BGP 发言人收到了其他 BGP 发言人发来的路径通知，它就要检查一下 本 AS 是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会形成环）。</p><p>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和 减少路由器的处理开销方面都有好处。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>BGP 报文类型
</pre></table></code></div></div><p>这里只是简单罗列下 BGP 几种报文，不会涉及每种报文的具体格式（因为 BGP 过于复杂，有专著研究 BGP，要想完全 理解 BGP 至少几个月，甚至几年）。下面是 BGP-4 的四种报文：</p><ul><li>（1）OPEN（打开）报文：用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。<li>（2）UPDATE（更新）报文：用来通告某一路由的信息，以及列出要撤销的多条路由（但只能一条一条的增加）。<li>（3）KEEPSLIVE（保活）报文：用来周期性地证实邻站的连通性。<li>（4）NOTIFICATION（通知）报文：用来发送检测到的查错。</ul><p><em>两个相邻的 BGP 发言人通过 OPEN 报文商谈建立起邻站关系，然后周期性交换 KEEPLIVE 报文（短小而通信开销小） 维持这种邻站关系，一旦路由发生变化就会立即用 UPDATE 报文告知邻居（这样邻居再告知它的另外的邻居）逐条增加路由或一次 撤销多条路由（从而轻松解决“RIP 中出现的坏消息传得慢”的问题），如果发现错误机会发回 NOTIFICATION 报文告知对方</em>。</p><h2 id="路由器"><span class="mr-2">路由器</span><a href="#路由器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。这也是网络层的主要工作。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-96.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-96.PNG" alt="路由器结构" class="lazyload" data-proofer-ignore></a></p><p>由上图可知，整个的路由器结构可划分为两大部分：<code class="language-plaintext highlighter-rouge">路由选择</code>部分（也叫<code class="language-plaintext highlighter-rouge">控制部分</code>）和<code class="language-plaintext highlighter-rouge">分组转发</code>部分。</p><p>其中路由选择部分的核心构件是路由选择处理机。该处理机的任务是歌剧所选定的路由选择协议构造出路由表，同时经常或定期地和 相邻路由器交换路由信息而不断地更新和维护路由表。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>“转发”和“路由选择”的区别：
</pre></table></code></div></div><ul><li>转发</ul><p>“转发”就是路由器根据<code class="language-plaintext highlighter-rouge">转发表</code>把收到的 IP 数据报从路由器合适的端口转发出去。而转发表是从路由表得出的。转发表必须 包含完成转发功能所必须的信息。这就是说，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些 MAC 地址信息的映射。</p><ul><li>路由选择</ul><p>“转发”仅仅涉及到一个路由器，但“路由选择”则设计到很多路由器，<code class="language-plaintext highlighter-rouge">路由表</code>则是许多路由器协同工作的结果。这些路由器 按照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并由此构造出整个的路由表。路由表一般 仅包含从墓地网络到下一跳）用 IP 地址表示）的映射。</p><p>将转发表和路由表用不同的数据结构实现会带来一些好处，这是因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表 则需要对网络拓扑变化的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。</p><p>为提高查找效率研究转发表的查找算法是值得的，优势为了利用局部性原理会把某些已经查过的转发表项放在高速缓存中。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>输入端口
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-97.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-97.PNG" alt="输入处理" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>输出端口
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-98.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-98.PNG" alt="输出处理" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>交换结构
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-99.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-99.PNG" alt="输出处理" class="lazyload" data-proofer-ignore></a></p><h2 id="广播路由"><span class="mr-2">广播路由</span><a href="#广播路由" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面关注的是单播通信的选路协议，单个源点基于这种协议向单个目的节点发送分组。而在<code class="language-plaintext highlighter-rouge">广播选路</code>中， 网络层提供了一个源节点到网络中的所有其他结点交付分组的服务。<code class="language-plaintext highlighter-rouge">多播选路</code>使单个源节点能够向其他网络结点的一个子集发送 分组的拷贝。</p><blockquote><p>广播选路算法</p></blockquote><p>也许完成广播通信的最直接方式是由发送结点向每个目的地分别发送分组的拷贝。但这样效率低，不同结点收到广播消息的时延较大 （最好能“同时”接收到广播信息）。可见，基于单薄选路基础设施来实现广播将是不明智的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>显然更为有效的方式是：
</pre></table></code></div></div><p>经第一跳仅发送分组的单个拷贝，然后让第一跳后面其他端的结点差生并转发任何附加的拷贝。也就是说，让网络结点本身（而不只是 源节点）产生分组的冗余拷贝将更加有效。</p><h3 id="无控制洪泛"><span class="mr-2">无控制洪泛</span><a href="#无控制洪泛" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>实现广播的最显而易见的技术是使用洪泛方法。该方法要求源节点向他的所有邻居发送该分组的拷贝。当某个结点接收到了一个广播 分组时，它复制该分组并向它的所有其他邻居转发之。如此，只要图示连通的，这种方案最终会将广播分组的拷贝交付给该途中所有 结点。</p><p>遗憾的是，如果该图有圈（网络中很正常），则每个广播分组的一个或多个分组拷贝将无休止第循环，浙江导致<code class="language-plaintext highlighter-rouge">广播风暴</code>，最后、 网络将瘫痪。</p><h3 id="受控洪泛"><span class="mr-2">受控洪泛</span><a href="#受控洪泛" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>避免广播分包的关键是每个结点明智第选择何时洪泛分组，何时不洪泛分组。这可以通过几种方式实现，例如：</p><ul><li>序号控制洪泛</ul><p>此方法中，源节点将其地址）或其他的唯一标识符）以及广播序号放入广播分组，再向它的所有邻居发送该分组。每个结点维护他已经 收到的、复制的和转发的原地址和每个广播分组的序号列表。当一个结点接收到一个广播分组时，它首先检查该分组是否在列表中。 如果在，丢弃该分组；如果不在，复制该分组并向该结点的所有其他邻居转发。</p><p>可见，这样很容易消除图中的环，防止广播风暴。</p><ul><li>反向路径转发（RPF）</ul><p>也称为<code class="language-plaintext highlighter-rouge">反向路径广播（RPB）</code>。RPF 的基本思想简单且优雅：</p><p>当一台路由器接收到具有给定源地址的广播分组时，仅当该分组到达的链路正好是位于它自己到其源的最短单播路径上 （将原地址视为目的地址），它才向其所有其他出链路传输分组；否则，丢弃该分组。也就是说，它只接收和转发处在到达广播源地址 （视为目的地址）最短路径上的下一跳路由器发来的广播分组。</p><p>由于单播的路由表是一颗汇集树，不存在环，可见 RPF 不存在广播风暴。</p><h3 id="生成树广播"><span class="mr-2">生成树广播</span><a href="#生成树广播" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然序号控制洪泛和 RPF 避免了广播风暴，但它们不能完全避免冗余广播分组的传输。序号控制洪泛存在该问题显而易见。而 RPF 存在 该问题的原因是：不同路由器到同一个源地址（视为目的地址）形成的不同汇集树中存在相同的中间节点（可以通过手工运行 RPF 发现 这个原因）。</p><p>RPF 只是丢弃了符合条件的分组，但是这些分组还是转发到这里了（不该来这里的），能不能消除这些冗余的转发路径，只留下必须的 路径呢？这实际上就是<code class="language-plaintext highlighter-rouge">生成树问题</code>（详见数据结构）。更确切地说，我们需要构造最小生成树。</p><p>因此，另一种提供广播的方法是首先对网络结点构造出一颗生成树。当一个源节点要发送一个广播分组时，它向所有属于该生成树的特定链路 发送分组。接收广播分组的结点则向生成树中的所有其他邻居转发该分组（<code class="language-plaintext highlighter-rouge">注意：一个结点不必知道整棵树，它只知道它在图中哪些 邻居是生成树的邻居</code>）。</p><p>与生成树方法相关的主要复杂性是生成树的生成和维护。至于具体算法请参考其他资料。</p><h2 id="ip-多播组播"><span class="mr-2">IP 多播（组播）</span><a href="#ip-多播组播" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>IP 多播（曾译为组播），即一对多通信，但又不是广播通信，例如，实时信息的交付（如新闻、股市行情等）、软件更新、交互式会议等。 与单播相比，在一对过的通信中，多播可大大节约网络资源。见下图：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-100.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-100.PNG" alt="多播和单播" class="lazyload" data-proofer-ignore></a></p><p><em>IP 多播所传送的分组需要使用多播 IP 地址</em>。在多播数据报的目的地址写入的是多播组的标识符，然后设法加入到这个多播组的主机 的 IP 地址与多播组的标识符关联起来。</p><p>其实<code class="language-plaintext highlighter-rouge">多播组的标识符就是 IP 地址中的 D 类地址</code>（前四位是 1110，因此 D 类地址范围是 224.0.0.0 到 239.255.255.255）。 多播数据报也是“尽最大努力交付”，不保证一定能够交付给多播组内的所有成员。因此，<em>多播数据报和一般的 IP 数据报的区别就是 它使用 D 类 IP 地址（但有些地址不能随意使用，因为已经被 IANA 指派）作为目的地址， 并且首部中的协议字段值是 2，表明使用 IGMP 协议</em>。</p><p>显然，<code class="language-plaintext highlighter-rouge">多播地址只能用于目的地址，而不能用于源地址</code>。此外，对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后 面键入多播地址，将永远不会受到相应。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IP 多播可以分为两种：
</pre></table></code></div></div><ul><li>只在本地局域网上进行硬件多播<li>在因特网范围进行多播</ul><p>前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到因特网的。在因特网上进行多播的最后阶段，还是要把 多播数据报在局域网上用硬件多播交付给多播组的所有成员。</p><h3 id="硬件多播"><span class="mr-2">硬件多播</span><a href="#硬件多播" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因特网号码指派管理局 IANA 拥有的以太网地址块的搞 24 位为 00-00-5E。从下图不难看出，在每一个地址中，只有 23 位可用作多播。 这只能和 D 类 IP 地址中的 23 位有一一对应关系。D 类 IP 地址可供分配的有 28 位，可见者 28 位中的前 5 位不能用来构成以太网 硬件地址。</p><p>由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是 本主机要接收的数据报丢弃。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-101.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-101.PNG" alt="硬件多播" class="lazyload" data-proofer-ignore></a></p><h3 id="igmp-和多播路由"><span class="mr-2">IGMP 和多播路由</span><a href="#igmp-和多播路由" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IP 多播在互联网上进行需要两种协议：网际组管理协议 IGMP、多播路由选择协议。但 IGMP 并非在因特网范围内对所有多播组成员 进行管理的协议，它是让连接在本地局域网上的多播路由器知道本局域网上是否有（至于有几个不关心）主机（某个进程） 参加或退出某个多播组。显然，仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和因特网上的其他多播 路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。</p><p><em>多播数据报可以由没有加入多播的主机发出，也可以通过没有组成员接入的网络</em>。多播组成员可以随时加入或退出或不加入就发送数据报， 多播转发必须动态地适应这种成员变化，但网络拓扑并未发生变化（<code class="language-plaintext highlighter-rouge">单播路由选择通常是在网络拓扑发生变化时才能更新路由</code>）。 可见，多播路由选择协议要比单薄路由选择协议复杂得多。</p><blockquote><p>IGMP 协议</p></blockquote><p>IGMP 使用 IP 数据报传递报文，但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的 一个组成部分。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IGMP 报文格式
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-102.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-102.PNG" alt="IGMP 报文格式" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-103.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-103.PNG" alt="IGMP 报文格式" class="lazyload" data-proofer-ignore></a></p><ul><li>组成员加入过程：</ul><p>当一个主机进程希望接收一个组播组的数据，则使用硬件多播发送成员加入报告给本地 IGMP 路由器，然后改路由器向外网理由多播路由 选择算法多播出去。</p><ul><li>查询与响应过程</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-104.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-104.PNG" alt="查询与响应过程" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-105.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-105.PNG" alt="查询与响应过程" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-106.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-106.PNG" alt="查询与响应过程" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-107.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-107.PNG" alt="查询与响应过程" class="lazyload" data-proofer-ignore></a></p><ul><li>组成员离开过程</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-108.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-108.PNG" alt="组成员离开过程" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-109.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-109.PNG" alt="组成员离开过程" class="lazyload" data-proofer-ignore></a></p><ul><li>IGMP v1 余 IGMP v2 互作用</ul><p><a href="/assets/img/it_basic/network/basic/internet-basic-110.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-110.PNG" alt="版本兼容" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-111.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-111.PNG" alt="版本兼容" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-112.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-112.PNG" alt="版本兼容" class="lazyload" data-proofer-ignore></a></p><p><em>在主机和多播路由器之间的所有通信都是使用 IP 多播</em>。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。 因此在支持硬件多播的网络上，没有参加 IP 多播的主机不会受到 IGMP 报文。</p><h3 id="多播路由选择协议"><span class="mr-2">多播路由选择协议</span><a href="#多播路由选择协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>多播路由选择实际上就是要找出以援助及为根结点的<code class="language-plaintext highlighter-rouge">多播转发树</code>。在多播转发树上，每一个多播路由器向树的叶子结点方向转发 受到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报（即多播数据报不应在互联网中兜圈子）。不难看出， 对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>在实践中，有两种方法用于确定多播转发树。这两种方法区别在于：是用单一的组共享树来为组中的所有发送方分发流量，还是为每个 独立的发送方构建一颗特定源的转发树。不过这两种方法都使用了以下三种技术：</p><ul><li>洪泛与剪除：</ul><p>如广播路由中提到的受控洪泛和 RFB（剪除不需要的分组转发路径），可以防止数据报兜圈子。</p><ul><li>隧道技术：</ul><p>当多播数据报路径没有运行多播协议的路由器时，对多播数据报进行再次封装，使之称为向单一目的站发送的单薄数据报，当到了 多播环境时在恢复使用多播技术。</p><ul><li>生成树</ul><blockquote><p>建议使用的多播协议</p></blockquote><p><a href="/assets/img/it_basic/network/basic/internet-basic-113.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-113.PNG" alt="建议使用的多播协议" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-114.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-114.PNG" alt="建议使用的多播协议" class="lazyload" data-proofer-ignore></a></p><h2 id="虚拟专用网-vpn"><span class="mr-2">虚拟专用网 VPN</span><a href="#虚拟专用网-vpn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>局域网中不需要所有的主机都和因特网直接相连，也就不需要全球唯一的 IP 地址了，换句话说，这些内部使用的计算机可以由本机构 自行分配其 IP 地址（不对外通信，即使和外面的重复也没关系）。</p><p>为此，专用地址实现了上面的需求。<code class="language-plaintext highlighter-rouge">专用地址</code>只能用作本地地址而不能用作全球地址。*在因特网中的所有路由器，对目的地址 是专用地址的数据报一律不进行转发。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-115.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-115.PNG" alt="专用地址" class="lazyload" data-proofer-ignore></a></p><p>采用这样的专用 IP 地址的互连网络成为<code class="language-plaintext highlighter-rouge">专用互联网</code>或<code class="language-plaintext highlighter-rouge">本地互联网</code>或<code class="language-plaintext highlighter-rouge">专用网</code>。由于这些专用地址仅在本机构内部使用， 专用 IP 地址也叫作<code class="language-plaintext highlighter-rouge">可重用地址</code>。</p><p>有时一个很大的机构有许多部门分布在相距很远的一些地点，而每一个地点都有自己的专用网。假定这些分布在不同地点的专用网需要 经常进行通信。这时，可以有两种方法：</p><ul><li>租用电信公司的通信线路</ul><p>这种方法的好处是简单方便，但线路租金太高。</p><ul><li>使用虚拟专用网 VPN</ul><p>利用公用的因特网作为本机构各个专用网之间的通信载体，这样的专用网又称为<code class="language-plaintext highlighter-rouge">虚拟专用网</code>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-116.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-116.PNG" alt="VPN" class="lazyload" data-proofer-ignore></a></p><p>有时一个机构的 VPN 需要有某些外部机构（如合作伙伴）参加进来。这样的 VPN 就称为<code class="language-plaintext highlighter-rouge">外联网</code>。内联网和外联网都采用了因特网 技术（TCP/IP 协议）。还有一种类型的 VPN，就是<code class="language-plaintext highlighter-rouge">远程接入 VPN</code>，适合对流动员工的管理与通信。</p><h2 id="网络地址转换-nat"><span class="mr-2">网络地址转换 NAT</span><a href="#网络地址转换-nat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>专用网内的主机没有全球 IP 地址，因此无法直接与因特网上的主机通信，专用网如何和因特网上的主机通信呢？最简单和最直接 的办法就是申请一些全球 IP 地址，但毕竟全球 IP 地址是有限的，而且付出的代价不少。目前使用得最多的方法是采用网络地址转换。</p><p>而<code class="language-plaintext highlighter-rouge">网络地址转换 NAT</code>方法需要在专用网连接到因特网的路由器上安装 NAT 软件（该路由器称为 NAT 路由器）。它至少有一个有效 的外部全球的 IP 地址。这样，所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址， 才能和因特网连接。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-117.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-117.PNG" alt="NAT 原理" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-118.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-118.PNG" alt="NAT 原理" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-119.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-119.PNG" alt="NAT 原理" class="lazyload" data-proofer-ignore></a></p><p>当 NAT 路由器具有 n 个全球 IP 地址时，专用网内最多可以同时有 n 个主机接入到因特网。这样就可以轮流使用 NAT 路由器有限 数量的全球 IP 地址。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-120.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-120.PNG" alt="NAT 地址转换表" class="lazyload" data-proofer-ignore></a></p><p>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上（这种 NAT 也叫作<code class="language-plaintext highlighter-rouge">网络地址与端口转换 NAPT</code>）。 这样就可以使多个拥有本地地址的主机或多个进程，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和因特网上的不同主机进行通信。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-121.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-121.PNG" alt="NAPT 地址转换表" class="lazyload" data-proofer-ignore></a></p><h1 id="传输层">传输层</h1><p>传输层的<code class="language-plaintext highlighter-rouge">最终目标</code>是向它的用户提供高效的、可靠的和成本有效的数据传输服务，它的用户通常是应用层的进程。 为了实现这个目标，传输层需要充分利用网络层提供给它的主机到主机间的通信服务。</p><p>与网络层提供面向连接和无连接两种服务一样，传输层的服务类型也分为两种。面向连接的传输服务在许多方面与面向连接的网络服务 类似，两者的连接都要经历 3 个阶段：连接建立、数据传输和连接释放。这这两层上，寻址和流量控制非常相像。另外，无连接的 传输服务与无连接的网络服务也极为相似。</p><p>既然传输层服务与网络层服务如此<code class="language-plaintext highlighter-rouge">相似</code>，为什么还要设立两个独立的层？</p><p>事实上，用户对网络层没有真正的<code class="language-plaintext highlighter-rouge">控制权</code>，因为他们不拥有路由器，所以不能用更好的路由器火灾在数据链路层上用更好的错误处理机制 来解决服务太差的问题。唯一的可能是在网络层之上再加一层，由该层来提高网络的服务质量，而运输层只存在主机上，用户有很强的 控制权。</p><p>本质上，由于传输层的存在，使得传输服务有可能比网络服务更加可靠。而且，传输服务原语可以通过调用库程序来实现，从而使得这些 源于独立于网络服务原语。不同网络上的网络服务原语可能有很大的差别。将网络服务影藏在一组传输服务原语的背后，带来的好处是：</p><p>一旦改变了网络服务，只需要替换一组库程序即可：新的库程序使用了不同的底层网络服务，但是实现了同样的传输服务原语，如此， 对于用户程序而言，相当于没有改变，也就是说不用改变用户程序。</p><p>值得庆幸的是，正是有了传输层，应用程序才可以按照一组标准的原语来编写代码，并且程序可以运行在各种各样的网络上：他们根本 无须处理不同的网络接口，也不用担心传输的可靠性。因此，下 4 层可以看做是<code class="language-plaintext highlighter-rouge">传输服务的提供者</code>，而上面的层次则可视为 <code class="language-plaintext highlighter-rouge">传输服务的用户</code>。</p><h2 id="传输层概述"><span class="mr-2">传输层概述</span><a href="#传输层概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">从 IP 层来说，通信的两端是来那个主机</code>。IP 数据报的首部明确第标志了这两个主机的 IP 地址。但“两个主机之间的通信”这种说法 还不够清楚，因为同一台主机上同时运行着多个进程，而且这些进程都可能在进行网络通信。真正进行通信的实体是在在主机中的进程， 是不同主机之间的进程间交换数据。</p><p>从运输层的角度看，<em>通信的真正端点并不是主机而是主机中的进程</em>。</p><p>可见，网络层是为主机支架提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。<code class="language-plaintext highlighter-rouge">逻辑通信</code>的意思是：运输层之间的 通信好像是沿水平方向传送数据，而屏蔽了一下各层的诸多细节。</p><p>但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别：</p><ul><li>TCP 协议</ul><p>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条<code class="language-plaintext highlighter-rouge">全双工可靠信道</code>。</p><ul><li>UDP 协议</ul><p>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条<code class="language-plaintext highlighter-rouge">不可靠信道</code>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>UDP 和 TCP 最基本的任务是：
</pre></table></code></div></div><p>将两个端系统间 IP 的交付服务扩展为运行在两个端系统上的进程之间的交付服务。这种将主机间交付扩展到进程间交付，称为 <code class="language-plaintext highlighter-rouge">运输层的多路复用</code>与<code class="language-plaintext highlighter-rouge">多路分解</code>。</p><p>这里的“<code class="language-plaintext highlighter-rouge">复用</code>”是指在发送方不同的应用进程都可以使用同一个运输层协议和同一个源 IP 传送数据，而“<code class="language-plaintext highlighter-rouge">分用</code>”是指 接收方的运输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</p><h2 id="传输协议概述"><span class="mr-2">传输协议概述</span><a href="#传输协议概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>传输服务由传输协议实现，两个传输实体之间的通信必须使用传输使用传输协议。前面提到了传输层提供的服务与网络层很相似，但 前面已经分析了这两层都是不可少的。网络层下面的链路层，传输层的下面是网络层，它们的实现环境是不一样的。在协议角度来看， 数据链路层协议（针对 OSI 模型）和传输协议有些方面类似，比如错误处理、顺序性和流量控制等。然而两者也存在着重大差别：</p><ul><li>地址</ul><p>点到点链路上，路由器不必指定它要与哪一台路由器进行通信（因为可以与接口绑定）。而在传输层，必须显式地指定接收方的地址。</p><ul><li>连接</ul><p>在一条线路上建立一个连接的过程非常简单，而在网络之上传输层中初始的连接建立过程非常复杂（参见 TCP 连接的简历），因为 其下的网络层状态非常复杂。数据链路层中的连接是少量的，而传输层的连接是大量的，所以在输出层中，必须要妥善管理大量的连接。</p><ul><li>数据传输</ul><p>数据链路层和传输层之间的另一个差别是，网络存在着潜在的存储容量，即在网络中滞留了大量的数据报。由于网络内部的路由是独立 进行的且可能无序抵达，甚至他的重传数据报都已经到达，它却稍后才到。网络具有的这种延迟和重复数据报的特性所产生的后果需要 协议进行仔细的设计，以便正确地传输信息。</p><p>传输层协议之间可能有很大不同，但仍然可以通过以下基本元素来考量各个传输协议。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>传输协议的基本元素：
</pre></table></code></div></div><ul><li>寻址<li>连接建立<li>数据传输<li>连接释放<li>差错控制和流量控制<li>多路复用<li>拥塞控制</ul><p>TCP/IP 运输层的两个主要协议都是因特网的正式标准，即：用户数据报协议 UDP，传输控制协议 TCP。它们传送的数据单元分别称之为 TCP 报文段 或 UDP 用户数据报。</p><p><code class="language-plaintext highlighter-rouge">UDP</code>在传送数据之前不需要先建立连接。园地主机的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付， 但在某些情况下 UDP 却是一种最有效的工作方式。</p><p><code class="language-plaintext highlighter-rouge">TCP</code> 则是提供面向连接的服务。在传送数据之前必须先建立连接，数据传送借宿后要释放连接。TCP 不提供广播或多播服务。 由于 TCP 要提供可靠的，面向连接的运输服务，因此不可避免地增加了许多的开销。如确认、流量控制、计时器以及连接管理等。 这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-122.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-122.PNG" alt="UDP 和 TCP 的应用" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>运输层的端口
</pre></table></code></div></div><p>区别同一主机不同的正在使用网络通信的用户进程的一个方法就是在运输层使用<code class="language-plaintext highlighter-rouge">协议端口号</code>（简称<code class="language-plaintext highlighter-rouge">端口</code>）。这就是说， 虽然通信的终点是应用进程，但我们只需要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付给目的 进程）就由 TCP 来完成。</p><p>请注意，这种在协议栈层间的抽象的协议端口是<code class="language-plaintext highlighter-rouge">软件端口</code>，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同 硬件设备进行交互的接口，而<em>软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址</em>。</p><p><code class="language-plaintext highlighter-rouge">端口号只具有本地意义</code>，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在因特网不同计算机中， 相同的端口号是没有关联的。</p><p>由此可见，两个计算机中的进程要相互通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号 （为了找到对方计算机中的应用进程）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-123.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-123.PNG" alt="运输层端口分类" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-124.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-124.PNG" alt="常用熟知端口" class="lazyload" data-proofer-ignore></a></p><h2 id="udp"><span class="mr-2">UDP</span><a href="#udp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>用户数据包协议 UDP 只在 IP 的数据包服务之上增加了很少一点的功能，这就是复用和奋勇的功能以及差错检测的功能。 UDP 是一个基于不可靠通信子网的不可靠传输层协议。因此，基于 UDP 的应用程序必须自己解决可靠性问题，如报文丢失、报文 重复、报文失序、流量控制等。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>UDP 的主要特点是：
</pre></table></code></div></div><ul><li>UDP 是无连接的，可减少开销和发送数据之前的时延。<li>UDP 使用尽最大努力交付，这点和 IP 协议一样。<li>UDP 是面向报文的。</ul><p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分， 而是保留这些报文的边界。也就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，一次发送一个完整的报文。</p><p>因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能哟啊进行分片，这回降低 IP 层 的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部相对较长，这也降低了 IP 层的效率。</p><ul><li>UDP 没有拥塞控制</ul><p>UDP 可以提高实时传输效率，但 UDP 中缺乏拥塞控制能够导致 UDP 发送方和接收方高丢包率，并将挤垮具有拥塞控制的 TCP 会话， 这是一个潜在的严重问题。</p><p>实际上实时传输协议 RTP 和实时传输控制协议 RTCP 在 UDP 的基础上做了改进时期有助于接收端处理流媒体信息。</p><ul><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。<li>UDP 的首部开销小。</ul><p>在 UNIX 系统中，一个 UDP 端口是一个可读和可写的软件结构， UDP 协议为每个端口维护一个接收缓冲区。发送数据时， UDP 协议将数据内容生成一个 UDP 数据报，然后交给网络层的ＩＰ协议发送。接收数据时， UDP 协议从网络层 IP 协议接收到 UDP ， 然后根据目的端口号将其放在相应的接收缓冲区中。如果没有匹配的端口号， UDP 协议将丢弃该数据报， 并向发送主机返回一个“不可到达”的 ICMP 消息；如果匹配端口号已满， UDP 协议也丢弃该数据报，但不回送错误消息， 将来靠超时重发。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>UDP 首部格式
</pre></table></code></div></div><p>下图中所谓<code class="language-plaintext highlighter-rouge">伪首部</code>是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算校验和时，临时添加在 UDP 用户数据报 前面，得到一个<code class="language-plaintext highlighter-rouge">临时的 UDP 用户数据报</code>。伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-125.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-125.PNG" alt="UDP 首部格式" class="lazyload" data-proofer-ignore></a></p><p>UDP 用户数据报首部中校验和的计算方法有些特殊。在计算校验和时，要在 UDP 用户数据报之前增加 12 个字节的<code class="language-plaintext highlighter-rouge">伪首部</code>（见上图）。 校验和就是按照临时的 UDP 用户数据报来计算的。</p><p>UDP 计算校验和的方法和计算 IP 数据报首部校验和的方法相似。但不同的是：IP 数据报检验和只检验 IP 数据报首部，但 UDP 的 校验和时整个临时数据报（包括伪首部、首部、数据部分）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>UDP 校验和计算：
</pre></table></code></div></div><ul><li>把伪首部、首部、和数据部，按顺序划分成多个双字节单元；最后不足两个字节补一个全零字节。<li>对这些双字节单元进行二进制反码运算求和（建议先两个单元做二进制反码运算得到和，在与下一个单元求和）；<li>对求得的和取反，放入检验和字段。</ul><p><em>二进制反码求和运算：对应列相加，1 + 0 =1 ；0+0= 0 ； 1+1 =0 ，产生进位；最高位进位加到和的末尾</em>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>UDP 校验示例
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-126.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-126.PNG" alt="UDP 校验示例" class="lazyload" data-proofer-ignore></a></p><h2 id="可靠传输的工作原理"><span class="mr-2">可靠传输的工作原理</span><a href="#可靠传输的工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TCP 下面的网络提供的是不可靠传输，其要实现可靠传输，必须采用适当的措施才能使得两个运输层之间的通信变得可靠。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>理想的传输条件有以下两个特点：
</pre></table></code></div></div><ul><li>（1）传输信道不产生差错。<li>（2）不管发送方以多块的速度发送数据，接收方总是来得急处理收到的数据。</ul><p>然而实际的网络都不具备以上两个理想条件。但可以使用一些可靠协议，实现：</p><ul><li>（1）当出现差错时让发送方重传出现差错的数据，<li>（2）在接收方来不及处理收到的数据时，即使告诉发送方适当降低发送数据的速度。</ul><h3 id="停止-等待协议"><span class="mr-2">停止-等待协议</span><a href="#停止-等待协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 实现的是全双工通信，不过为了讨论问题的简单，仅考虑 A 发送数据而 B 接收数据并发送确认的情况。所谓“停止-等待”就是 没发送一个分组就停止发送，等待对方的确认，在收到确认后在发送下一个分组。</p><ul><li>无差错的情况</ul><p>这种情况很简单，因为不会发生发送出来的分组和确认帧的丢失，因此该协议可以很好的工作。</p><ul><li>出现差错的情况</ul><p>发送的分组本身在传输中出现差错被丢弃或直接丢失了，或者确认帧也出现了前面的情况，这样发送方将收不到来自接收方的确认， 按照协议就得无休止的等待，因此又加入了<code class="language-plaintext highlighter-rouge">超时重传机制</code>。</p><p>哟啊实现超时重传，发送方就要在放完一个分组后就会设置一个<code class="language-plaintext highlighter-rouge">超时计时器</code>（要比数据在分组传输的平均往返时间更长一些）， 而且要在这期间暂时保留已发送的分组的副本以备重传，会出现两种情形：</p><ul><li>超时前收到了对方的确认，则撤销计时，清除保留的该分组副本<li>超时就立即重传。</ul><p>需要注意的是，IP 层提供的是不可靠传输服务，可能出现丢失、失序到达等。具体说来，有以下情形：</p><ul><li>收到重复分组</ul><p>原来的分组有可能在重传分组不久之后到达，而重传的分组也随后到达，这样就出现了冗余分组，这必须区分出来以便丢弃， 所以<code class="language-plaintext highlighter-rouge">需要对分组进行编号</code>。收到重复分组，在停止-等待协议下可以有两种处理方式：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>①丢弃重复分组，其他什么也不做；
</pre></table></code></div></div><p>当确认分组丢失或被丢弃，将会导致发送方无休止的重传。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>②丢弃重复分组，而且发送确认（只要收到分组就发送确认）。
</pre></table></code></div></div><p>当确认分组无序到达或重复到达时，将会引起混乱，所以此时确认分组也必须编号，而且这个编号和被确认分组的编号有一一对应的关系。</p><p><em>利用上述的确认和超时重传再确认机制，就可以在不可靠的传输网络上实现可靠的通信</em>。像上述的这种可靠传输协议常称为 <code class="language-plaintext highlighter-rouge">地洞重传请求 ARQ</code>或<code class="language-plaintext highlighter-rouge">带有重传的肯定确认</code>，意思是重传的请求是自动（此处是超时重传）进行的， 接收方不需要请求发送方重传某个出错的分组。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>信道利用率：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-127.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-127.PNG" alt="停止等待协议信道利用率示意图" class="lazyload" data-proofer-ignore></a></p><p>所谓信道利用率就是传输有用分组所占的比率，一般用时间比来表示。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-128.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-128.PNG" alt="停止等待协议信道利用率" class="lazyload" data-proofer-ignore></a></p><p>为了提高传输效率，发送方可以不适用低效率的停止等待协议，而是采用<code class="language-plaintext highlighter-rouge">流水线传输</code>。不过这就会增减缓冲区的管理复杂度， 同时要处理分组和确认分组无序到达，以及中间分组丢失等情况。</p><h3 id="连续-arq-协议"><span class="mr-2">连续 ARQ 协议</span><a href="#连续-arq-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>连续重发请求ARQ方案是指发送方可以连续发送一系列信息帧，即不用等前一帧被确认便可继续发送下一帧，效率大大提高。不过也 带来了如下影响：</p><ul><li>必须增加序号范围：</ul><p>防止序号在传输过程中未确认的分组和缓冲区中分组发生序号循环导致的重复。必须保证这一过程中序号唯一性。</p><ul><li>增加缓存</ul><p>协议的发送方和接收方也许必须缓存多个分组。发送方最低限度应当能缓存那些已发送但未确认的分组。</p><ul><li>出错分组处理复杂化</ul><p>所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式。</p><p><em>解决流水线传输差错回复有两种方法：混退 N 帧和选择重传</em>。当某个分组没有收到确认，发送方可以用两种处理方式：</p><ul><li>重传该分组及其之后的所有分组：</ul><p>这种方法中接收方不需要保留无序到达的分组，因为数据必须按序交付，并且发送方反正要重传没有确认的分组及其后面的已发送的 分组的。这种方法使得接收方缓存管理简单，不过丢弃已经正确接收的失序分组是有些浪费，而且随后对该分组的重传也许会丢失或 出错，从而导致更多的重传。这种方法就是<code class="language-plaintext highlighter-rouge">混退 N 帧</code>的基本思想。</p><p>*在回退 N 帧协议中，对序号为 n 的分组的确认采取<code class="language-plaintext highlighter-rouge">累积确认</code>的方式， 表明接收方已经正确接收到序号 n 及其之前的所有分组。这就是说，接收方不必对收到的分组逐个发送确认，而是可以在收到几个 连续分组后，对按序到达的最后一个分组发送确认。能使用累积确认的原因是：发送方连续发送分组，接收方就能在超时重传 前这段时间收到多个分组并发出确认到达发送方。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>超时事件：
</pre></table></code></div></div><p>如果出现超时，发送方将重传所有已发送单还未被确认的分组。每个分组可以启动一个定时器（洗脑利用率更高）， 也可以统一使用一个计时器，不过在回退 N 帧协议中，一个定时器就足够了（因为反正后面的数据都会重传的）。当使用一个定时器 时，它可被当做是最早的已发送但未被确认的分组所使用的定时器。如果收到一个确认，但仍有已发送但未被确认的分组，则定时器被 重新启动；如果没有，则该定时器被终止。</p><ul><li>只重传丢失的分组：</ul><p>这种方法避免了不必要的重传，但对发送方和接收方的缓存管理提出了更高的要求，失序的分组将被缓存知道所有丢失分组（即序号 更小的分组）都被收到，这才可以将一批分组按序交付给上层。这就是<code class="language-plaintext highlighter-rouge">选择重传</code>的基本思想。</p><p>注意：接收方重新确认（而不是负略）已收到过的那些序号小于当前发送窗口基序号（最早的未被确认的序号）的分组，这一点是必须 的。既然接收方已经收到的分组，发送方还是重传分组并到达了接收方，这说明在发送方看来，接收方没有收到该分组（所以会重传， 尽管接收方已经收到，但发送方并不知道）。如果不重新发送确认，则发送窗口将永远不能向前滑动。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-129.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-129.PNG" alt="可靠运输传输机制" class="lazyload" data-proofer-ignore></a></p><p>通过本节的讲述，可靠的传输协议就能实现了。具体请见 TCP 可靠传输的实现。前面的讨论是在嘉定一个放松和一个接收方的前提下 进行的，实际上，实际的 TCP 是全双工通信，我们知道确认分组（又称<code class="language-plaintext highlighter-rouge">哑帧</code>）是非常短小的，但单独发送确认分组必将降低传输效率 （首部占的比重非常大），可使用“<code class="language-plaintext highlighter-rouge">捎带确认</code>”技术：就是暂时延缓确认以便将确认信息搭载在下一个出境数据报上。</p><h2 id="tcp"><span class="mr-2">TCP</span><a href="#tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TCP 是 TCP/IP 体系中非常复杂的一个协议。其主要的特点如下：</p><ul><li>TCP 是面向连接的运输层协议。<li>每一条 TCP 连接只能有两个端点，也就是，只支持一对一通信。<li>TCP 提供可靠交付的服务。<li>TCP 提供全双工通信，TCP 连接的两端都有发送缓存和接收缓存。<li>面向字节流。“流”指的是流入到进程或从进程流出的字节序列。</ul><p>虽然应用程序和 TCP 的交互式一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。 TCP 并不知道所传送的字节流的含义。至于如何换分和组合起来和如何解读这些数据时上层应用程序的事情。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>TCP 面向连接和虚电路的区别：
</pre></table></code></div></div><p>TCP 是运输层协议，在路由器协议栈中没有运输层，也就是说，TCP 经过的网络路径由下面的网络决定，下面的网络可能是数据报网络， 也可能是虚电路网络。当为数据报网络时，一个 TCP 连接中的数据传输路径是不确定，不同报文的路径也可能是不一样的，这取决于 网络环境。</p><p>而虚电路处在网络层，其连接一旦建立，该连接上的数据经过的路径都是一样的，知道该连接的拆除。可见，TCP 面向连接指的是传输 数据前要先建立连接，传输完不用后要释放连接。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>TCP 连接
</pre></table></code></div></div><p>TCP 连接的端口叫做<code class="language-plaintext highlighter-rouge">套接字</code>或<code class="language-plaintext highlighter-rouge">插口</code>。端口号拼接到 IP 地址即构成了套接字。每一条 TCP 连接唯一地被通信两端的两个 端点（即两个套接字）所确定（两点决定一条直线）。</p><h3 id="tcp-首部格式"><span class="mr-2">TCP 首部格式</span><a href="#tcp-首部格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分。而 TCP 的全部功能都体现 在他首部中各字段的作用。首部就像是 C 语言中两端主机的具有网络时延的全局变量，特别需要注意其不完全同步性带来的问题。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-130.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-130.PNG" alt="TCP 首部" class="lazyload" data-proofer-ignore></a></p><p>下面对个别字段进行详细解释：</p><ul><li>紧急 UEG：</ul><p>当 URG = 1 时，表明紧急指针字段有效，并结合紧急指针指出从序号字段值（序号）开始的紧急指针值（表示紧急字节数）个为紧急 数据。紧急数据指的是高优先级发送（紧急数据一旦交给 TCP，就立即装包发送）和（接收端）向上交付的数据（一旦紧急数据一到 就马上交给上层，不必遵照次序）。</p><ul><li>确认 ACK：</ul><p>仅当 ACK = 1 时确认号字段才有效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1.</p><ul><li>推送 PSH：</ul><p>发送方不必等待缓冲区满后才发送，应先将缓冲区现有的数据发送出去；接收方不必等缓冲区满了之后才上交。</p><ul><li>同步 SYN：</ul><p>在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 （即还没有建立连接）时，表明这是一个连接请求报文段。对方若同意建立连接， 则应在相应的报文段中使 SYN = 1 和 ACK = 1（请求发送数据）。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>选项字段：
</pre></table></code></div></div><ul><li>MSS：</ul><p>MSS最大报文段长度(Maxium Segment Size)：指明数据字段的最大长度， 数据字段的长度加上 TCP 首部的长度才等于整个 TCP 报文段的长度。 MSS 值指示自己期望对方发送 TCP 报文段时那个数据字段的长度。通信双方可以有不同的 MSS 值。 如果未填写，默认采用 536 字节。MSS 只出现在 SYN 报文中。即：MSS 出现在 SYN=1 的报文段中。</p><ul><li>窗口扩大选项</ul><p>窗口扩大选项(Windows Scaling)：由于 TCP 首部的窗口大小字段长度是 16 位，所以其表示的最大数是 65535。 但是随着时延和带宽比较大的通信产生（如卫星通信），需要更大的窗口来满足性能和吞吐率，所以产生了这个窗口扩大选项。</p><ul><li>SACK选择确认项</ul><p>SACK 选择确认项(Selective Acknowledgements)：用来确保只重传缺少的报文段，而不是重传所有报文段。 比如主机 A 发送报文段 1、2、3，而主机 B 仅收到报文段 1、3。那么此时就需要使用 SACK 选项来告诉发送方只发送丢失的数据。 那么又如何指明丢失了哪些报文段呢？使用 SACK 需要两个功能字节。一个表示要使用 SACK 选项， 另一个指明这个选项占用多少字节。描述丢失的报文段 2，是通过描述它的左右边界报文段 1、3 来完成的。 而这个 1、3 实际上是表示序列号，所以描述一个丢失的报文段需要 64 位即 8 个字节（丢失分组的始末序号）的空间。 那么可以推算整个选项字段最多描述 (40-2)/8=4 （首部长度字段决定了 TCP 的最大长度，TCP 首部固定部分为 20 字节，启用 SACK 选项需要 2 个功能字节，一个丢失的分组需要始末两个序号占 8 个字节以确定边界）个丢失的报文段。</p><ul><li>时间戳选项：</ul><p>时间戳选项（Timestamps）：可以用来计算 RTT(往返时间)，发送方发送 TCP 报文时，把当前的时间值放入时间戳字段， 接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，当发送方收到确认报文后即可计算出 RTT。 也可以用来防止回绕序号 PAWS，也可以说可以用来区分相同序列号的不同报文。因为序列号用 32 位表示，每 2^32 个序列号 就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文。</p><ul><li>NOP：</ul><p>NOP(NO-Operation)：它要求选项部分中的每种选项长度必须是 4 字节的倍数，不足的则用 NOP 填充。 同时也可以用来分割不同的选项字段。如窗口扩大选项和 SACK 之间用 NOP 隔开。</p><h3 id="tcp-可靠传输的实现"><span class="mr-2">TCP 可靠传输的实现</span><a href="#tcp-可靠传输的实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在“可靠传输的工作原理”一节中已经宽泛的讲过了有关可靠传输的知识了。本节将只讲滑动窗口和超时重传时间的选择。</p><blockquote><p>以字节为单位的<code class="language-plaintext highlighter-rouge">滑动窗口</code></p></blockquote><p>现假定 A 收到了 B 发来的确认报文段，其中窗口字段值为 20（字节），而确认号是 31 （这表明 B 期望收到的下一个序号是 31， 而序号 30 为止的数据已经收到了）。根据这两个数据，A 就构造出自己的发送窗口（发送窗口基序号为 31，大小为 20，因此末 序号为 50）。其示意图如下：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-131.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-131.PNG" alt="发送窗口示意图" class="lazyload" data-proofer-ignore></a></p><p>发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方既可以在收到确认之前连续发送更多的数据，因而可能获得更高的 传输效率。但接收方必须来得及处理这些收到的数据。</p><p>发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的， 因为接收方都没有为这部分数据保留临时存放的缓存空间。</p><p>发送串口的位置由窗口前沿和后沿的位置共同确定。而前沿则由对方发来的确认号决定，但后沿则相对复杂，由对方发来的确认数据报中 的确认号和窗口字段值共同确定（确认号+窗口字段值 = 后沿）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>当对方发来新的有效确认号时
</pre></table></code></div></div><ul><li>前沿将前移（请看上图标注）到新的确认好所指序号；否则（即没有收到新的确认），原地不动；<li>后沿的移动相对复杂：<ul><li>若窗口大小不变或变大，则前移；<li>若窗口值变小，可能出现后沿后移（可能导致已经发送的序号被从新放到了不允许发送的区域，可能导致错误，因而 TCP 的 标准强烈不赞成这样做），也可能前移。</ul></ul><p>根据上面的描述可以将整个发送缓冲区分为两大块：发送窗口（当连接释放后可以为 0）和不允许发送部分。 其中发送窗口在某时刻有课分为两部分：已经发送但为收到确认的部分，允许发送但还没有发送的部分 （又称<code class="language-plaintext highlighter-rouge">可用窗口</code>或<code class="language-plaintext highlighter-rouge">有效窗口</code>，当发送窗口中的数据全部发送之后而又没有收到新的确认，此时该窗口可以为 0）。 也就是说缓冲区被分成三段（假设将缓冲区看成一个首尾相接的循环队列），则每段至少有一个标志，换句话说， 至少需要三个指针才能确定这三段的边界（每段的起始需要一个指针，这三段看成首尾相接构成环， 则相邻段的起始也是邻居的终了位置，所以只需要三个指针）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>接收方可能发生的情况：
</pre></table></code></div></div><ul><li>接收到按序到达的分组，并根据其中收到的最大序号发送确认：<ul><li>发送方收到确认，发送窗口位置可以改变；<li>发送方没有收到确认，发送窗口位置不变，并超时重传。</ul><li>接收到未按序到达的分组，暂时保存在接收缓冲区内，但不针对这些分组发哦发送确认：<ul><li>或者不发送确认；<li>或者选择确认。</ul></ul><p>实际上，接收方是上面两种情况的结合。如果收到的分组被检测出有差错，则要丢弃；如果接收应用程序来不及读取收到的数据， 接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时从接收缓存中读取收到的数据，接收串口就可以 增大，但是最大不能超过接收缓存的大小。可见，<em>TCP 通信双方的传输效率和双方的缓存大小、处理数据的速率、网络拥塞情况和 信道质量有关。为了进一步增加通信效率，通信双方尽可能采用<code class="language-plaintext highlighter-rouge">捎带确认</code></em>。</p><blockquote><p>超时重传时间的选择</p></blockquote><p>超时重传时间的选择影响着通信效率，超时重传时间过短（确认分组还没来得及到达，分组就超时重发了）会导致重传增加；如果超时 时间设置过长，则又使网络的空闲时间增大（若确认分组丢失，发送方就会等较长时间才重传，空闲时间自然增大）， 降低了传输效率。那么，运输层的超时计时器的超时重传时间究竟应设置多大呢？</p><p>TCP 采用了一种自适应算法。它利用 TCP 确认分组的<code class="language-plaintext highlighter-rouge">时间戳选项</code>（详情请参考“TCP 首部格式”）记录的分组发送时间，在结合 收到确认分组的时间作差就得出了<code class="language-plaintext highlighter-rouge">报文段的往返时间 RTT</code>。发送方 TCP 还保留了 RTT 的一个<code class="language-plaintext highlighter-rouge">加权平均往返时间</code> RTT<sub>S</sub>（又称为<code class="language-plaintext highlighter-rouge">平滑的往返时间</code>）。 每当第一次测量到 RTT 样本时，RTT<sub>S</sub> 取为所测量到的 RTT 样本值。但以后就按下列公式计算：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-132.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-132.PNG" alt="加钱平均往返时间计算公式" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-133.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-133.PNG" alt="超时时间计算公式" class="lazyload" data-proofer-ignore></a></p><p>不过发送方根本无法辨别确认还是确认确认（当数据被重传之后，确认分组到达，但这个确认分组可能是对原分组的确认，也可能是 对重传分组的确认，因为确认分组也可能无序到达或迟到）。所以上述方法根据确认分组携带的时间截选项来确定 RTT 就会用两种 情况出现：</p><ul><li>收到的重传分组的确认被当做对原分组的确认，计算出来的 RTT 就偏小，当然 RTO 也偏小<li>若收到的确认是对原来报文的确认，却被当做是对重传报文的确认，则计算出的 RTT 就偏大。当然 RTO 也偏大。</ul><p>为此，需要对重传的报文做特殊处理。这里列举两种处理方式：</p><ul><li>只要重传就不重新计算 RTO。</ul><p>当网络拥塞严重而重传发生时，需要更长的 RTO，而此方式（又称为<code class="language-plaintext highlighter-rouge">Kam 算法</code>）却不更新 RTO，将进一步导致重传， 可能进一步加重网络拥塞。</p><ul><li>Kam 算法修正法：</ul><p>报文段没重传一次，就把 RTO 增大一些。典型的做法是：取新的重传时间为 2 倍的旧的 RTO；当不再发生重传时，才根据前面的 计算公式计算 RTO。实践证明，这种策略较为合理。</p><h3 id="必须考虑传输效率"><span class="mr-2">必须考虑传输效率</span><a href="#必须考虑传输效率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>前面已经讲过，应用进程把数据传送到 TCP 的发送缓存后，剩下的发送任务就由 TCP 来控制了。可以用不用的机制来控制 TCP 报文段 的发送时机。不过要清楚的是：TCP 的发送方发送时机是由发送方的发送机制和接收方发送确认的时机共同决定的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>发送时机举例：
</pre></table></code></div></div><ul><li>TCP 保持一个变量，它等于最大报文段长度 MSS。只要混村中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。<li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送操作和紧急数据。<li>发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</ul><p>但是，如何控制 TCP 发送报文段的实际仍然是一个较为复杂的问题。不过在 TCP 的实现中广泛使用 Nagle 算法。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Nagle 算法：
</pre></table></code></div></div><p>若发送应用进程把要发送的数据组个字节地发送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去（可以探探路，以便 为后面大量数据的发送收集相关信息），把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存 中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个 报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle 算法还规定，当到达的数据已达到 发送窗口的大小的一般或已达到报文段的最大长度时，就立即发送一个报文段。</p><p>发送确认报文的时机也将影响 TCP 发送方的发送时机算法的效率。比如<code class="language-plaintext highlighter-rouge">糊涂窗口综合征</code>，有时也会使 TCP 的性能变坏。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>糊涂窗口综合征：
</pre></table></code></div></div><p>假设 TCP 接收方的缓存已满，而交互式的应用进程一次只从接受缓存中读取 1 个字节（这样就使接受缓存空间仅腾出 1 个字节）， 然后向发送方发送确认，并把窗口设置为 1 个字节（但发送的数据报是 40 字节长，数据占比太低了）。接着，发送方依照发送时机 （比如按照 Nagle 算法）机制发来 1 个字节的数据（发送方发送的 IP 数据报是 41 字节长）。接收方发回确认，仍然将窗口设置为 1 个字节。这样进行下去，使网络的效率很低。</p><p>要解决这个问题，可以让接收方等待一段时间，使得或接收缓存已有足够空间容纳一个最长的报文段，或者等待接受缓存已有一般空闲 的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小（此时超时重传时间算法就显得更重要了 ，因为确认发送要延迟，可能导致不必要的重传）。此外，发送方也不要（一接收到确认就）发送太小的报文段， 而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><h2 id="tcp-的拥塞控制"><span class="mr-2">TCP 的拥塞控制</span><a href="#tcp-的拥塞控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在计算机网络中链路容量（即带宽）、交换结点中的缓存和处理机、端系统等，都是网络的资源。若对网络中某一资源的需求超过了 该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做<code class="language-plaintext highlighter-rouge">拥塞</code>。可见防止拥塞可以有两个思考方向：</p><ul><li>增加可用资源和资源的共享程度：这种方法，可能不但不能解决拥塞问题，而且还可能使网络的性能更坏（因为通信主体都会想尽办法尽可能的占用 可用资源）<li>孔子对资源的需求和恰当地分配可用资源。</ul><p>这种方法可以称为<code class="language-plaintext highlighter-rouge">拥塞控制</code>。所谓<code class="language-plaintext highlighter-rouge">拥塞控制</code>就是防止过多的数据注入到网络中，这样就可以使网络资源（有短板效应） 不会过载。拥塞控制索要做的都有一个前提：<em>网络能够承受现有的网络符合</em>。拥塞控制是一个全局性的过程，设计到所有主机，所有 的路由器，以及与降低网络传输性能有关的所有因素。应做到负载均衡、网络资源使用要匹配与协调。</p><p>但 TCP 连接的端点只要迟迟不能收到对方确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但这时却无法知道拥塞到底发生在 网络的何处，也无法知道发生拥塞的具体原因。</p><p>拥塞控制与流量控制的关系密切。不过<em>流量控制往往指点对点通信量的控制，是个端到端的问题</em>。流量控制索要做的就是保持通信 双方保持尽可能的同步，抑制发送端发送数据的速率，以便接收端来得及接收和处理。可见，流量控制是局部的，不同的网络段和通信 双方允许的带宽和本身速率不同，流量控制也将不同。</p><p>拥塞控制和流量控制之所以常常被弄混，是因为某些拥塞控制算法是向发送端发送控制报文，并告诉发送端，网络已出现麻烦，必须放慢 发送速率。这点又和流量控制是很相似的。</p><p>进行拥塞控制需要付出代价，而且会打破原有的平衡，带来新的影响。所以在设计用撒控制策略时，必须全面衡量得失。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-134.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-134.PNG" alt="拥塞控制的作用" class="lazyload" data-proofer-ignore></a></p><p>实践证明，拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。一般是通过分组丢失程度来判断网络拥塞的，但 分组的丢失是网络发生拥塞的征兆而不是原因。在许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至发生死锁 的原因。这点应特别注意。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-135.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-135.PNG" alt="拥塞控制的作用" class="lazyload" data-proofer-ignore></a></p><p>在最宽泛的层次上，我们可根据网络层是否为运输层拥塞控制提供显式的帮助来区分拥塞控制方法：</p><ul><li>端到端拥塞控制：此类方法中，网络层只提供了拥塞指标的信息，路由器没有直接采取措施来帮助拥塞控制。<li>网络辅助的拥塞控制：在该方法中，网络层组件（即路由器）向发送方提供关于网络中拥塞状态的显式反馈信息。 这种反馈可以通过仅用一个比特来指示链路中的拥塞情况。路由器显式提供拥塞信息的方法有两种：直接反馈信息和间接反馈信息。<ul><li>直接反馈信息可以由网络路由器（以阻塞分组的形式）发给发送方；<li>间接反馈信息是指路由器标记或更新流向接收方的分组中的拥塞的指示字段，一旦接收方收到该分组，就会通知发送方网络 发生了拥塞。注意，这种方式的通知至少要经过一个完整的往返时间。</ul></ul><p>具体的拥塞控制的方法有：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h3 id="慢开始和拥塞避免"><span class="mr-2">慢开始和拥塞避免</span><a href="#慢开始和拥塞避免" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度， 并且动态地在变化。而发送窗口（发送方的发送窗口一定不能超过对方给出的接收窗口） 取决于接收方的就收和处理分组的能力与当时的状态。可见，在考虑拥塞控制这个层面来说， 发送窗口是为了在传输层上数据传输双方的同步，而拥塞窗口则用来指明当时网络余下的容纳分组的能力。如此，发送窗口必然 被要求小于等于拥塞窗口。注意拥塞窗口和发送窗口都是动态变化的。</p><p><code class="language-plaintext highlighter-rouge">发送方控制拥塞窗口的原则是</code>：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。一般具体采用 AIMD（加法递增乘法递减）控制法则 来响应网络传来的拥塞信号，至于使用该法则的时机则由具体的算法来确定。</p><blockquote><p>满开始算法：</p></blockquote><p>慢开始（又称慢启动）：当建立连接时，发送端用一个很小的初始化拥塞窗口，最多不超过 4 个段（早期采用初始值 1 MSS，后根据 经验改成 4），然后发送端发送该初始窗口大小的数据，对于每个在超时重传前得到确认的段，拥塞窗口增加一个段（即每一个确认的 段允许发送两个段：已经收到一个段，意味着网络中少了一个段，在超时前收到的，说明网络状态好，可以追加一个段）。</p><p>可见，使用慢开始算法后，<em>每经过一个传输轮次（原拥塞窗口中的数据全部发送完并都收到了确认，称为一个轮次），拥塞窗口就加倍</em>。 可以说，它根本不慢（呈指数增长），这个“慢”指的是达到较大的速率需要一定的时间，而不是一建立连接就开始大量发送数据。 随着速率的增长，拥塞就会出现，超时时间就会发生，为了防止拥塞窗口 cwnd 增长过快引起网络拥塞（实际上就是为了控制注入 网络中的数据不能一下子太多），还需要设置一个<code class="language-plaintext highlighter-rouge">慢开始门限（或阈值）</code>ssthresh。在达到慢开始门限之前使用慢开始算法， 在慢开始门限之后将采用<code class="language-plaintext highlighter-rouge">拥塞避免算法</code>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>拥塞避免算法：
</pre></table></code></div></div><p>虽然满开始算法和拥塞避免算法都遵循<code class="language-plaintext highlighter-rouge">加法递增乘法递减</code>的法则，但它们使用该法则的时机是不同的。慢开始算法使用加法递增 的时机是：超时事件出现前收到的确认报文。而拥塞算法使用加法递增的时机是：RTT 。</p><p>拥塞避免（并非指完全能够避免拥塞，只是使网络不容易出现拥塞而已）算法的思想是：当到了慢开始门限后， （只要没有发生超时重传事件）每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 增加一段。可见，拥塞窗口将线性缓慢增长。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>对超时事件的反应：
</pre></table></code></div></div><p>前面说的算法是没有发生超时事件的情况下使用的加法递增。不论处于慢开始还是拥塞避免阶段， 只要发生超时（其依据的 RTT 最好使用最慢的路径的精准时间，这个可以通过发送方收到的确认分组中得出）事件就需使用乘法递减。 但不同算法对超时事件的反应是不一样的：</p><ul><li>不采用快速重传机制</ul><p>TCP 马上把拥塞窗口 cwnd 减小到 1，并重新（从头再来）执行慢开始算法，同时把慢开始门限值 ssthresh 减半。</p><ul><li>使用快速重传算法：</ul><p>快重传算法首先要求接收方每收到一个<code class="language-plaintext highlighter-rouge">失序的报文段</code>后就立即发出重复确认而不要等待自己发送数据时才进行捎带确认 （如接收方收到 1，3 而没有收到 2，则立即发送确认表明 2 没有收到，然后收到了 4，继续发送确认表明 2 仍然没有收到，以此 类推）。与快重传配合使用的还有快恢复算法。</p><ul><li>快恢复算法：</ul><p>当发送方接收到三个重复确认时，说明这种情况与发生超时事件不同，至少某些报文已经被发送方收到了（只是失序而已），说明 网络已经腾出了空间，还可以交付一些报文段。</p><p>快恢复算法的思想：执行乘法减小，把慢开始门限 ssthresh 减半，拥塞窗口设置为更新后的 ssthresh 值（而不是 1 MSS），然后开始执行拥塞避免 （“加法增大”）算法（而不是慢开始算法）。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-136.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-136.PNG" alt="慢开始和拥塞避免" class="lazyload" data-proofer-ignore></a></p><h3 id="随机早期检测-red"><span class="mr-2">随机早期检测 RED</span><a href="#随机早期检测-red" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>由于 TCP 拥塞控制算法大都以分组丢失的情况作为拥塞程度的判断依据。所以网络层路由器的分组丢弃策略将会影响到拥塞控制算法 的实施效果。一般分组的处理按照队列“先进先出”原则来进行处理的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>分组丢弃策略：
</pre></table></code></div></div><ul><li>尾部丢弃策略：</ul><p>当网络出现拥塞时，采用尾部丢弃策略（当队列已满时，以后再到达的所有分组将都被丢弃，如果队列未满，则会被放在队列的尾部） 将会导致大量的分组短时间内接连丢失（因为路由器转发分组需要时间，在这期间到达的分组都将被丢弃），使得很多条 TCP 连接 出现重传的情况，从而可能都进入到慢开始状态或发送数据量都大幅度减少（称之为<code class="language-plaintext highlighter-rouge">全局同步</code>）。全局同步使得全网的通信量 突然下降很多，而在网络恢复正常后，其通信量又突然增大很多。如此增大了出现拥塞的可能性和加剧了拥塞程度。</p><p>为了避免发生网络中的全局同步现象，可以在路由器采用<code class="language-plaintext highlighter-rouge">随机早期检测 RED</code>（又叫“随机早期丢弃”）的措施。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>实现 RED 的要点如下：
</pre></table></code></div></div><p><a href="/assets/img/it_basic/network/basic/internet-basic-137.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-137.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-138.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-138.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a></p><p>在出现尾部大面积丢弃（引起全局同步效应）之前，就先以概率 p 随机丢弃个别的分组，让拥塞控制只在个别的 TCP 连接上进行， 因而避免发生全局性的拥塞控制。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-139.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-139.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-140.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-140.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-141.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-141.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a></p><p>算法中使用<code class="language-plaintext highlighter-rouge">平均队列长度</code>的原因是：计算机数据具有突发性的特点，路由器中队列长度经常会出现很快的起伏变化。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-142.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-142.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-143.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-143.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-144.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-144.PNG" alt="RED 算法" class="lazyload" data-proofer-ignore></a></p><h2 id="tcp-的运输连接管理"><span class="mr-2">TCP 的运输连接管理</span><a href="#tcp-的运输连接管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TCP 运输连接有三个阶段：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。TCP 连接 的建立采用客户服务器方式。主动发起连接建立的应用进程叫做<code class="language-plaintext highlighter-rouge">客户</code>，而被动等待连接建立的应用进程叫做<code class="language-plaintext highlighter-rouge">服务器</code>。</p><h3 id="tcp-的链接建立"><span class="mr-2">TCP 的链接建立</span><a href="#tcp-的链接建立" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 的连接建立过程叫做<code class="language-plaintext highlighter-rouge">三次握手</code>或<code class="language-plaintext highlighter-rouge">三次联络</code>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-145.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-145.PNG" alt="TCP 三次握手" class="lazyload" data-proofer-ignore></a></p><p><code class="language-plaintext highlighter-rouge">为什么 A 还要发送一次确认（即进行第三次握手）呢？</code>这主要是为了防止已失效的连接请求报文段（A 可能为了与 B 建立连接， 尝试了多次，但 B 都没有回应，这些请求可能已经消失，也可能释放连接后还滞留在网络中，当然这是一种极端情况，通信了很久 ，请求报文还在网络中。不过，协议就是要全面考虑各种情况）突然又传到了 B（通过确认号可以辨别这种情况），因而产生错误， 导致 B 误以为 A 要发送数据，就一直打开进程等着，导致 B 的许多资源浪费了。有了第三次握手的约定，由于 A 已经释放连接，就不可能回应 B。那么 B 过约 一分钟就会自动回收资源。</p><h3 id="tcp-的连接释放"><span class="mr-2">TCP 的连接释放</span><a href="#tcp-的连接释放" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>数据传输结束后，通信双方中任何一方都可以主动提出释放连接请求，发出连接释放报文段。下图以客户主动释放为例。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-146.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-146.PNG" alt="TCP 连接释放过程" class="lazyload" data-proofer-ignore></a></p><p><code class="language-plaintext highlighter-rouge">为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间能？这有两个理由</code>：</p><ul><li>A 发出的最后一个确认报文到达 B 需要时间，同时可能丢失。一旦丢失，B 会超时重发 FINACK 报文段（如果此时 A 不等，而是 直接关闭了，即不会有任何回应，那么 B 将会一直重传，知道达到重传上限才会自动关闭连接），而 A 则会重传最后一个确认报文段， 从而使 B 能正常进入关闭状态。<li>确保本次连接双方发出的报文段已经没有在网络滞留的可能性。以便净化下一次重新建立连接的环境。</ul><h3 id="tcp-的有限状态机"><span class="mr-2">TCP 的有限状态机</span><a href="#tcp-的有限状态机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了更清晰第看出 TCP 连接的各种状态之间的关系，绘制了下面的 TCP 连接的有限状态机。其中粗实线箭头表示对客户进程的正常 变迁，粗虚线箭头表示对服务器进程的正常变迁，另一种细线箭头表示异常变迁。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-147.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-147.PNG" alt="TCP 连接的有限状态机" class="lazyload" data-proofer-ignore></a></p><h1 id="应用层">应用层</h1><p>除了应用层的其他各层都是为计算机网络提供通信服务的，而应用层则是利用这些通信服务解决应用问题。每个应用层协议都是为了解决 某一类应用问题，而问题的解决又往往是<em>通过不同主机中的多个应用进程之间的通信和协同工作来完成的</em>。应用层的具体内容就是 <code class="language-plaintext highlighter-rouge">规定应用进程在通信时所遵循的协议</code>。</p><p>应用层的许多协议都是基于<code class="language-plaintext highlighter-rouge">客户服务器方式</code>。即使是对等通信方式，实质上也是一种特殊的客户服务器方式。<code class="language-plaintext highlighter-rouge">客户和服务器</code> 都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。这里最主要的特征就是： <em>客户是服务请求方，服务器是服务提供方</em>。</p><h2 id="域名系统-dns"><span class="mr-2">域名系统 DNS</span><a href="#域名系统-dns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DNS 是把主机域名解析为 IP 地址的系统。解决了 IP 地址难记的问题。该系统是由解析器和域名服务器组成的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>DNS 工作方式：
</pre></table></code></div></div><p>为了将一个名字映射成 IP 地址，应用程序调用一个名为解析器的库程序，并将名字作为参数传递给此程序。而解析器则向本地 DNS 服务器 发送一个包含改名字的请求报文；本地 DNS 服务器查询（不过有不同的查询方式，详见后面介绍）该名字， 并且返回一个包含该名字对应 IP 地址的响应报文给解析器，然后解析器在将 IP 地址返回给调用方。 查询报文和响应报文都作为 UDP 数据报发送。有了 IP 地址以后，应用程序就可以与目标主机进行通信了。</p><p><em>DNS 主要基于 UDP 协议，较少情况下使用 TCP 协议，端口号均为 53</em>。域名系统由三部分构成：<code class="language-plaintext highlighter-rouge">DNS 名字空间、域名服务器、DNS 客户机</code>。</p><h3 id="dns-名字空间"><span class="mr-2">DNS 名字空间</span><a href="#dns-名字空间" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>DNS 系统（也称为<code class="language-plaintext highlighter-rouge">因特网上的目录服务</code>）属于分层式命名系统，即采用的命名方法是层次树状结构。连接在 Internet 上的主机 或路由器都有一个唯一的层次结构名，即域名。域名可以由若干个部分组成，每个部分代表不同级别的域名并使用“.”号分开。 完整的结构为：<code class="language-plaintext highlighter-rouge">主机. …….三级域名.二级域名.顶级域名.</code>。顶级域名后的“.”号表示根域，通常可以不用写。</p><p>顶级域名由 ICANN （Internet 名字与数字地址分配机构）负责管理，并由 ICANN 委任的注册机构负责运行。</p><p>域名可以是绝对的，也可以是相对的。绝对域名总是以句点作为结束，而相对域名则不然。相对域名必须在一定的上下文环境中被解释 才有的真正含义。无论是绝对域名还是相对域名，一个域名对应于域名树中一个特定的结点，以及他下面的所有结点。域名不区分大小写， 各组成部分的名字最多可以有 63 个字符，整个路径的名字不得超过 255 个字符。</p><p>每个域自己控制如何分配它下面的子域。为了创建一个新域，创建者必须得到包含该新域的上级域的许可。命名机制遵循的是以组织 为边界，而不是以武力网络为边界。</p><h3 id="域名服务器"><span class="mr-2">域名服务器</span><a href="#域名服务器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>DNS服务器没有采用集中式数据库，因为这会造成单点故障、通信容量瓶颈、远距离延迟、数据库庞大难以维护等。为了处理规模问题， DNS 使用了大量的 DNS 服务器，它们以层次方式组织，并且分布在全世界范围内。，没有一台 DNS 服务器具有因特网上所有主机 的映射，相反，该映射分布在所有的 DNS 服务器上。每一个域名服务器都只对域名体系中的一部分进行管辖，并且尽量就近进行解析。</p><p>大致说来，有 4 种类型的 DNS 服务器：<code class="language-plaintext highlighter-rouge">根 DNS 服务器、顶级域名 DNS 服务器、权限（权威） DNS 服务器和本地域名服务器（默认域名服务器）</code>。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-148.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-148.PNG" alt="DNS 域名服务器层次" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/network/basic/internet-basic-149.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-149.PNG" alt="DNS 域名服务器作用划分" class="lazyload" data-proofer-ignore></a></p><h3 id="域名解析过程"><span class="mr-2">域名解析过程</span><a href="#域名解析过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>DNS 查询有两种方式：递归查询和迭代查询。</p><ul><li>递归查询</ul><p>主机向本地域名服务器的查询一般都是采用<code class="language-plaintext highlighter-rouge">递归查询</code>。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>所谓递归查询就是：
</pre></table></code></div></div><p>如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续 发出查询请求报文（即代替主机继续查询），而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是索要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p><ul><li>迭代查询</ul><p>本地域名服务器向根域名服务器的查询通常是采用迭代查询。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>迭代查询的特点：
</pre></table></code></div></div><p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出索要查询的 IP 地址，要么告诉本地域名服务器能够解析该 域名的 DNS 服务器 IP 地址，然后让本地域名服务器进行后续的查询（而不是代替本地域名服务器进行后续查询）。根域名服务器通常 是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询；顶级域名服务器在收到 本地域名服务器的查询请求后，要么根除索要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询。 本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的 IP 地址，然后把这个结果返回给发起查询的主机。当然本地 域名服务器也可以采用递归查询。这取决于最初的查询请求报文的设置是要求使用哪一种查询方式。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-150.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-150.PNG" alt="DNS 两种查询方式" class="lazyload" data-proofer-ignore></a></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>DNS 高速缓存
</pre></table></code></div></div><p>为了提高 DNS 查询效率，并减少域名服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<code class="language-plaintext highlighter-rouge">高速缓存</code> （有时也称为高速缓存域名服务器）。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>不但本地域名服务器中需要高速缓存，在主机中也很需要。许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放 自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。</p><h2 id="文件传送协议-ftp"><span class="mr-2">文件传送协议 FTP</span><a href="#文件传送协议-ftp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。FTP 屏蔽了各计算机系统的细节，因而适合于在 异构网络中任意计算机之间传送文件。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>FTP 特点
</pre></table></code></div></div><p>基于 TCP 的 FTP 和基于 UDP 的 TFTP，它们都是文件共享协议的一大类，即<code class="language-plaintext highlighter-rouge">复制整个文件</code>。其特点是：若要存取一个文件，就 必须先获得一个本地的文件副本（即先下载到本地）；如果要修改文件，只能对文件的副本进行修改，然后再将修改后的整个文件副本 传回到原结点。</p><p>另一类文件共享协议是<code class="language-plaintext highlighter-rouge">联机访问</code>。联机访问意味着允许多个程序同时对一个文件进行存取，和数据库系统不同之处是用户不需要调用 一个特殊的客户进程，而是由操作系统提供对远地共享文件进行访问的服务，就如同对本地文件的访问一样（即“<code class="language-plaintext highlighter-rouge">透明存取</code>”）。 例如，网络文件系统 NFS 就属于此类。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>FTP 工作原理：
</pre></table></code></div></div><p>FTP 只提供文件传送的一些基本服务，使用 TCP 可靠的运输服务。其主要功能是减少或消除在不同操作系统下处理文件的不兼容性。 不兼容性主要表现如下：</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-151.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-151.PNG" alt="文件共享遇到的问题" class="lazyload" data-proofer-ignore></a></p><p>FTP 使用客服服务器方式，一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 服务器进程由两大部分组成：一个主进程，负责接收新的请求； 另外有若干个从属进程，负责处理单个请求。</p><p><a href="/assets/img/it_basic/network/basic/internet-basic-152.PNG" class="popup img-link "><img data-src="/assets/img/it_basic/network/basic/internet-basic-152.PNG" alt="主进程工作步骤" class="lazyload" data-proofer-ignore></a></p><p>从属进程中又可分为控制进程和数据传送进程。在进程文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：<code class="language-plaintext highlighter-rouge">控制连接</code> 和<code class="language-plaintext highlighter-rouge">数据连接</code>。控制连接在整个会话期间一直保持打开，用于发送和接收控制信息；实际用于传输文件的是<code class="language-plaintext highlighter-rouge">数据连接</code>。由于 FTP 使用了一个分离的控制进程，因此 FTP 控制信息是带外传送的。</p><p>使用两个独立的连接的主要好处是：使协议更加简单和更容易实现，同时在传输文件时还可以利用控制连接（如终止传输）。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>FTP 的适用场合：
</pre></table></code></div></div><p>FTP 并非对所有的数据传输都是最佳的。如在大文件尾部追加一小段内容。然而，NFS 采用另一种思路：NFS 允许应用进程打开一个远地 文件，并能在该文件的某一个特定的位置上开始读写数据，如此在网络上传送的只是少量的修改数据。</p><h2 id="远程终端协议-telnet"><span class="mr-2">远程终端协议 TELNET</span><a href="#远程终端协议-telnet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TELNET 是一个简单的远程终端协议。是 Internet 远程登陆服务的标准协议。Telnet 协议的目的是提供一个相对通用的，双向的， 面向八位字节的通信方法，允许界面终端设备和面向终端的过程能通过一个标准过程进行互相交互。 应用 Telnet 协议能够把本地用户所使用的计算机变成远程主机系统的一个终端。</p><p>TELNET 使用了一种对称的数据表示，当每个客户机发送数据时，把它的本地终端的字符表示影射到 NVT （网络虚拟终端）的字符表示上， 当接收数据时，又把NVT的表示映射到本地字符集合上。</p><p>NVT 的格式定义很简单，所有的通信都使用 8 位一个字节。在运转时，NVT 使用 7 位 ASCII 码传送数据，而当高位置 1 时用作控制 控制命令。</p><p>TELNET 还有选项协商，这使得可以使用更多终端功能。</p><h1 style="visibility: hidden;" id="want-cmm"> 我要评论</h1></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20-%20Code-Winder&url=%2F%2Fcode-winder.github.io%2F2016%2F10%2Finternet-basic.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20-%20Code-Winder&u=%2F%2Fcode-winder.github.io%2F2016%2F10%2Finternet-basic.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2F%2Fcode-winder.github.io%2F2016%2F10%2Finternet-basic.html&text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20-%20Code-Winder" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/it-basic/">IT_Basic</a> <a class="post-tag" href="/tags/tool/">Tool</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/it-basic/">IT-Basic</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/vim/">Vim</a></div></div></div><script> (function() { $("#content-list").click(function(event){ var e=window.event || event; if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } if($('#markdown-toc').is(':hidden')){ $('#markdown-toc').show(); }else{ $('#markdown-toc').hide(); } }); $("#markdown-toc").click(function(event){ var e=window.event || event; if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } }); $(document).click(function(event) { $("#markdown-toc").hide(); }); }()); </script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"><ul class="nav navbar-nav"><li><a href="#计算机网络概述" class="nav-link">计算机网络概述</a><ul class="nav navbar-nav"><li><a href="#计算机网络分类" class="nav-link">计算机网络分类</a><li><a href="#计算机网络元素" class="nav-link">计算机网络元素</a><ul class="nav navbar-nav"><li><a href="#网络节点" class="nav-link">网络节点</a><li><a href="#传输链路" class="nav-link">传输链路</a><li><a href="#协议" class="nav-link">协议</a></ul></ul><li><a href="#计算机网络体系结构" class="nav-link">计算机网络体系结构</a><ul class="nav navbar-nav"><li><a href="#层的划分" class="nav-link">层的划分</a><ul class="nav navbar-nav"><li><a href="#五层协议的体系结构" class="nav-link">五层协议的体系结构</a><li><a href="#分层模型中基本概念" class="nav-link">分层模型中基本概念</a></ul></ul><li><a href="#物理层" class="nav-link">物理层</a><ul class="nav navbar-nav"><li><a href="#通信基础基础" class="nav-link">通信基础基础</a><ul class="nav navbar-nav"><li><a href="#有关信道的基本概念" class="nav-link">有关信道的基本概念</a></ul><li><a href="#数字数据的数字传输" class="nav-link">数字数据的数字传输</a><ul class="nav navbar-nav"><li><a href="#基带传输" class="nav-link">基带传输</a><li><a href="#频带传输" class="nav-link">频带传输</a></ul><li><a href="#模拟数据的数字传输" class="nav-link">模拟数据的数字传输</a><li><a href="#数据同步方式" class="nav-link">数据同步方式</a><li><a href="#信道的多路复用技术" class="nav-link">信道的多路复用技术</a><li><a href="#宽带接入技术" class="nav-link">宽带接入技术</a></ul><li><a href="#数据链路层" class="nav-link">数据链路层</a><ul class="nav navbar-nav"><li><a href="#基本概念" class="nav-link">基本概念</a><li><a href="#链路层协议" class="nav-link">链路层协议</a><ul class="nav navbar-nav"><li><a href="#三个基本问题" class="nav-link">三个基本问题</a><li><a href="#比特差错检测方法" class="nav-link">比特差错检测方法</a><li><a href="#ppp-协议" class="nav-link">PPP 协议</a><li><a href="#使用广播信道的数据链路层" class="nav-link">使用广播信道的数据链路层</a><li><a href="#csmacd-协议" class="nav-link">CSMA/CD 协议</a></ul></ul><li><a href="#以太网" class="nav-link">以太网</a><ul class="nav navbar-nav"><li><a href="#以太网的信道利用率" class="nav-link">以太网的信道利用率</a><li><a href="#以太网的-mac-层" class="nav-link">以太网的 MAC 层</a><li><a href="#mac-帧的格式" class="nav-link">MAC 帧的格式</a><li><a href="#扩展以太网" class="nav-link">扩展以太网</a><ul class="nav navbar-nav"><li><a href="#在物理层拓展以太网" class="nav-link">在物理层拓展以太网</a><li><a href="#在数据链路层扩展以太网" class="nav-link">在数据链路层扩展以太网</a><li><a href="#虚拟局域网" class="nav-link">虚拟局域网</a></ul><li><a href="#无线局域网" class="nav-link">无线局域网</a></ul><li><a href="#网络层" class="nav-link">网络层</a><ul class="nav navbar-nav"><li><a href="#网络层提供的两种服务" class="nav-link">网络层提供的两种服务</a><ul class="nav navbar-nav"><li><a href="#虚电路" class="nav-link">虚电路</a><li><a href="#无连接的数据报服务" class="nav-link">无连接的数据报服务</a></ul><li><a href="#网际协议-ip" class="nav-link">网际协议 IP</a><ul class="nav navbar-nav"><li><a href="#分类的-ip-地址" class="nav-link">分类的 IP 地址</a><li><a href="#划分子网" class="nav-link">划分子网</a><li><a href="#构造超网" class="nav-link">构造超网</a></ul><li><a href="#ip-地址与硬件地址的联系" class="nav-link">IP 地址与硬件地址的联系</a><ul class="nav navbar-nav"><li><a href="#arp-和-rarp" class="nav-link">ARP 和 RARP</a></ul><li><a href="#ip-数据报格式" class="nav-link">IP 数据报格式</a><li><a href="#ip-层转发分组的流程" class="nav-link">IP 层转发分组的流程</a><li><a href="#icmp-协议" class="nav-link">ICMP 协议</a><ul class="nav navbar-nav"><li><a href="#icmp-报文的种类" class="nav-link">ICMP 报文的种类</a></ul><li><a href="#路由选择协议" class="nav-link">路由选择协议</a><ul class="nav navbar-nav"><li><a href="#分层次的路由选择协议" class="nav-link">分层次的路由选择协议</a></ul><li><a href="#路由选择算法的理论基础" class="nav-link">路由选择算法的理论基础</a><ul class="nav navbar-nav"><li><a href="#优化原则" class="nav-link">优化原则</a><li><a href="#最短路径" class="nav-link">最短路径</a><li><a href="#泛洪算法" class="nav-link">泛洪算法</a></ul><li><a href="#内部网关协议-rip" class="nav-link">内部网关协议 RIP</a><ul class="nav navbar-nav"><li><a href="#rip-特点" class="nav-link">RIP 特点</a><li><a href="#距离向量算法" class="nav-link">距离向量算法</a><li><a href="#rip-协议的报文格式" class="nav-link">RIP 协议的报文格式</a></ul><li><a href="#内部网关协议-ospf" class="nav-link">内部网关协议 OSPF</a><ul class="nav navbar-nav"><li><a href="#ospf-算法" class="nav-link">OSPF 算法</a><li><a href="#ospf-与-rip-的对比" class="nav-link">OSPF 与 RIP 的对比：</a><li><a href="#ospf-报文格式" class="nav-link">OSPF 报文格式</a></ul><li><a href="#外部网关协议-bgp" class="nav-link">外部网关协议 BGP</a><li><a href="#路由器" class="nav-link">路由器</a><li><a href="#广播路由" class="nav-link">广播路由</a><ul class="nav navbar-nav"><li><a href="#无控制洪泛" class="nav-link">无控制洪泛</a><li><a href="#受控洪泛" class="nav-link">受控洪泛</a><li><a href="#生成树广播" class="nav-link">生成树广播</a></ul><li><a href="#ip-多播组播" class="nav-link">IP 多播（组播）</a><ul class="nav navbar-nav"><li><a href="#硬件多播" class="nav-link">硬件多播</a><li><a href="#igmp-和多播路由" class="nav-link">IGMP 和多播路由</a><li><a href="#多播路由选择协议" class="nav-link">多播路由选择协议</a></ul><li><a href="#虚拟专用网-vpn" class="nav-link">虚拟专用网 VPN</a><li><a href="#网络地址转换-nat" class="nav-link">网络地址转换 NAT</a></ul><li><a href="#传输层" class="nav-link">传输层</a><ul class="nav navbar-nav"><li><a href="#传输层概述" class="nav-link">传输层概述</a><li><a href="#传输协议概述" class="nav-link">传输协议概述</a><li><a href="#udp" class="nav-link">UDP</a><li><a href="#可靠传输的工作原理" class="nav-link">可靠传输的工作原理</a><ul class="nav navbar-nav"><li><a href="#停止-等待协议" class="nav-link">停止-等待协议</a><li><a href="#连续-arq-协议" class="nav-link">连续 ARQ 协议</a></ul><li><a href="#tcp" class="nav-link">TCP</a><ul class="nav navbar-nav"><li><a href="#tcp-首部格式" class="nav-link">TCP 首部格式</a><li><a href="#tcp-可靠传输的实现" class="nav-link">TCP 可靠传输的实现</a><li><a href="#必须考虑传输效率" class="nav-link">必须考虑传输效率</a></ul><li><a href="#tcp-的拥塞控制" class="nav-link">TCP 的拥塞控制</a><ul class="nav navbar-nav"><li><a href="#慢开始和拥塞避免" class="nav-link">慢开始和拥塞避免</a><li><a href="#随机早期检测-red" class="nav-link">随机早期检测 RED</a></ul><li><a href="#tcp-的运输连接管理" class="nav-link">TCP 的运输连接管理</a><ul class="nav navbar-nav"><li><a href="#tcp-的链接建立" class="nav-link">TCP 的链接建立</a><li><a href="#tcp-的连接释放" class="nav-link">TCP 的连接释放</a><li><a href="#tcp-的有限状态机" class="nav-link">TCP 的有限状态机</a></ul></ul><li><a href="#应用层" class="nav-link">应用层</a><ul class="nav navbar-nav"><li><a href="#域名系统-dns" class="nav-link">域名系统 DNS</a><ul class="nav navbar-nav"><li><a href="#dns-名字空间" class="nav-link">DNS 名字空间</a><li><a href="#域名服务器" class="nav-link">域名服务器</a><li><a href="#域名解析过程" class="nav-link">域名解析过程</a></ul><li><a href="#文件传送协议-ftp" class="nav-link">文件传送协议 FTP</a><li><a href="#远程终端协议-telnet" class="nav-link">远程终端协议 TELNET</a></ul><li><a href="#want-cmm" class="nav-link"> 我要评论 </a></ul></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/2016/07/mysql.html"><div class="card-body"> <em class="small" data-ts="1467591945" data-df="YYYY/MM/DD" > 2016/07/04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL 杂谈</h3><div class="text-muted small"><p> 本文主要介绍 MySQL 相关的一些理论知识、实践经验和验证实验。 基本概念 MySQL 基本框架图 SQL 语句 数据库连接 语句执行流程 查询语句执行流程 查询状态 查询优化 ...</p></div></div></a></div><div class="card"> <a href="/2023/03/etcd.html"><div class="card-body"> <em class="small" data-ts="1677711925" data-df="YYYY/MM/DD" > 2023/03/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>etcd 杂谈</h3><div class="text-muted small"><p> 本文主要对 ETCD 的相关资料进行收集，以备查阅和整理。 架构简介 etcd 应用 典型应用场景 常用工具和命令 etcd 实现原理 通讯协议 etcd 集群 etcd 故障及调优 etcd 综合 etcd 源码和常见面试题 架构简介 etcd 架构原理学习（来自etcd实战） et...</p></div></div></a></div><div class="card"> <a href="/2016/07/kafka.html"><div class="card-body"> <em class="small" data-ts="1467765411" data-df="YYYY/MM/DD" > 2016/07/06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>kafka 杂谈</h3><div class="text-muted small"><p> 本文主要介绍 kafka 相关的一些理论知识、实践经验和验证实验。 架构简介 kafka 应用 典型应用场景 常用工具和命令 kafka 实现原理 通讯协议 kafka 集群 kafka 故障及调优 kafka 综合 kafka 常见面试题 架构简介 Kafka系列3-Kafka架构 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/2016/09/data-struct-basic.html" class="btn btn-outline-primary" prompt="上一篇"><p>数据结构基础</p></a> <a href="/2016/11/OS-basic.html" class="btn btn-outline-primary" prompt="下一篇"><p>操作系统基础</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/it-basic/">IT_Basic</a> <a class="post-tag" href="/tags/tool/">Tool</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/it-basic/">IT-Basic</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/vim/">Vim</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/code-winder">code-winder</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div style="text-align:center;width: 90%;"><p class="mb-0"> 总访问量 <span id="busuanzi_value_site_pv" style="color: blue;"></span> ，访客数 <span id="busuanzi_value_site_uv" style="color: blue;"></span> ，本文总阅读量 <span id="busuanzi_value_page_pv" style="color: blue;"> </span></p></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1.11.6/dayjs.min.js,npm/dayjs@1.11.6/locale/zh.min.js,npm/dayjs@1.11.6/plugin/relativeTime.min.js,npm/dayjs@1.11.6/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-72449510-4"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-72449510-4'); }); </script>
