<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="MySQL 杂谈" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文主要介绍 MySQL 相关的一些理论知识、实践经验和验证实验。" /><meta property="og:description" content="本文主要介绍 MySQL 相关的一些理论知识、实践经验和验证实验。" /><link rel="canonical" href="//code-winder.github.io/2016/07/mysql.html" /><meta property="og:url" content="//code-winder.github.io/2016/07/mysql.html" /><meta property="og:site_name" content="Code-Winder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-07-04T08:25:45+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL 杂谈" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-07-04T08:25:45+08:00","datePublished":"2016-07-04T08:25:45+08:00","description":"本文主要介绍 MySQL 相关的一些理论知识、实践经验和验证实验。","headline":"MySQL 杂谈","mainEntityOfPage":{"@type":"WebPage","@id":"//code-winder.github.io/2016/07/mysql.html"},"url":"//code-winder.github.io/2016/07/mysql.html"}</script><title>MySQL 杂谈 | Code-Winder</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Code-Winder"><meta name="application-name" content="Code-Winder"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script> <script> // 百度统计代码 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e37ebacf05386ebe11672ab0dc609b69"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script> // google analytics (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '{site.google_analytics_id}}', 'auto'); ga('send', 'pageview'); </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/favicons/favicon.ico" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Code-Winder</a></div><div class="site-subtitle font-italic">灵感源于好奇</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/code-winder" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['414834682','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <i class="fas fa-list-alt fa-fw" id="content-list"></i> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>MySQL 杂谈</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >X</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 class="title_class" data-toc-skip>MySQL 杂谈</h1><div id="label_center"><div class="label"><div class="label-card"></div><div class="label-card"> <span class="categories"> <i class="fa fa-th-list"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88" title="Category: 计算机综合" rel="category">计算机综合</a> </span></div><div class="label-card"> <span class="pageTag"> <i class="fa fa-tags"></i> <a href="/tags/it-basic" title="Tag: IT_Basic" rel="tag">IT_Basic</a> </span></div></div></div><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1467591945" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2016/07/04 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/code-winder">code-winder</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9810 字"> <em>54 分钟</em>阅读</span></div></div></div><div class="post-content"><blockquote><p>本文主要介绍 MySQL 相关的一些理论知识、实践经验和验证实验。</p></blockquote><ul id="markdown-toc"><li><a href="#基本概念" id="markdown-toc-基本概念">基本概念</a><ul><li><a href="#mysql-基本框架图" id="markdown-toc-mysql-基本框架图">MySQL 基本框架图</a></ul><li><a href="#sql-语句" id="markdown-toc-sql-语句">SQL 语句</a><ul><li><a href="#数据库连接" id="markdown-toc-数据库连接">数据库连接</a><li><a href="#语句执行流程" id="markdown-toc-语句执行流程">语句执行流程</a><ul><li><a href="#查询语句执行流程" id="markdown-toc-查询语句执行流程">查询语句执行流程</a><ul><li><a href="#查询状态" id="markdown-toc-查询状态">查询状态</a><li><a href="#查询优化" id="markdown-toc-查询优化">查询优化</a></ul><li><a href="#update-语句执行流程" id="markdown-toc-update-语句执行流程">update 语句执行流程</a><li><a href="#insert-语句执行流程" id="markdown-toc-insert-语句执行流程">insert 语句执行流程</a><li><a href="#delete-语句执行流程" id="markdown-toc-delete-语句执行流程">delete 语句执行流程</a></ul><li><a href="#语句实现原理" id="markdown-toc-语句实现原理">语句实现原理</a><ul><li><a href="#select-工作原理" id="markdown-toc-select-工作原理">select 工作原理</a><li><a href="#关联查询join" id="markdown-toc-关联查询join">关联查询（join）</a><li><a href="#order-by-工作原理" id="markdown-toc-order-by-工作原理">order by 工作原理</a><li><a href="#group-by-工作原理" id="markdown-toc-group-by-工作原理">group by 工作原理</a><li><a href="#where-和-having-的区别" id="markdown-toc-where-和-having-的区别">where 和 having 的区别</a></ul></ul><li><a href="#事务机制" id="markdown-toc-事务机制">事务机制</a><ul><li><a href="#衡量事务的四个特性acid" id="markdown-toc-衡量事务的四个特性acid">衡量事务的四个特性（ACID）</a><ul><li><a href="#undo-log-实现原子性" id="markdown-toc-undo-log-实现原子性">undo log 实现原子性</a><li><a href="#redo-log-实现持久性" id="markdown-toc-redo-log-实现持久性">redo log 实现持久性</a><li><a href="#锁和-mvcc-机制实现隔离性" id="markdown-toc-锁和-mvcc-机制实现隔离性">锁和 MVCC 机制实现隔离性</a></ul></ul><li><a href="#日志文件" id="markdown-toc-日志文件">日志文件</a><ul><li><a href="#日志落盘策略" id="markdown-toc-日志落盘策略">日志落盘策略</a><li><a href="#数据丢失的场景" id="markdown-toc-数据丢失的场景">数据丢失的场景</a><li><a href="#主从同步" id="markdown-toc-主从同步">主从同步</a><li><a href="#存储过程" id="markdown-toc-存储过程">存储过程</a><li><a href="#视图" id="markdown-toc-视图">视图</a></ul><li><a href="#索引" id="markdown-toc-索引">索引</a><ul><li><a href="#不走索引的情况" id="markdown-toc-不走索引的情况">不走索引的情况</a></ul><li><a href="#存储引擎" id="markdown-toc-存储引擎">存储引擎</a></ul><h1 id="基本概念">基本概念</h1><p>MySQL 是一个开源免费的<a href="/2016/12/dataBase-basic.html#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93-1">关系数据库</a>软件。 数据库相关的基础可以参考博文<a href="/2016/12/dataBase-basic.html">数据库基础</a>。</p><h2 id="mysql-基本框架图"><span class="mr-2">MySQL 基本框架图</span><a href="#mysql-基本框架图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>框架图可以帮助我们从宏观上了解 MySQL 的大致全貌，有助于我们从关联的角度理解其如此设计的背后逻辑。 同时也可以帮助我们从外部寻找线索窥探其中的设计原理和实现细节。以下几张架构图试图从不同的详略角度 刻画 MySQL 的基本架构。</p><ul><li>其中较为底层的原理可参见<a href="https://www.gxlcms.com/mysql-463427.html">一篇文章让你搞懂MYSQL底层原理</a>，<li>更详细的文档可参考<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/">官方文档</a><li><a href="https://dev.mysql.com/doc/refman/8.0/en/">操作手册</a><li><a href="https://dev.mysql.com/doc/refman/8.0/en/programs-overview.html">mysql组成部分总览</a><li><a href="https://zhuanlan.zhihu.com/p/362948658">mysql组件间的协同流程</a><li>源码方面的解读<a href="https://www.gxlcms.com/sql_question-408121.html">MySQL源码探索02SQL命令总体执行流程</a><li>有人总结的面试经典<ul><li><a href="https://zhuanlan.zhihu.com/p/100026210">《深入精通Mysql（一）》Mysql整体架构和sql执行过程（面试高频题</a><li><a href="https://zhuanlan.zhihu.com/p/100248191">《深入精通Mysql（二）》深入底层剖析Mysql索引（面试必问）</a><li><a href="https://segmentfault.com/a/1190000021470407?utm_source=sf-related">《深入精通Mysql（三）》深入底层剖析Mysql各种锁机制（面试必问）</a><li><a href="https://segmentfault.com/a/1190000021470437">《深入精通Mysql（四）》MySQL 事务机制，中高级开发面试必问！</a><li><a href="https://zhuanlan.zhihu.com/p/343538668">深入了解MySQL主从复制的原理</a><li><a href="https://zhuanlan.zhihu.com/p/101317330">《深入精通Mysql（六）》系列之如何通过慢查询日志进行SQL分析和优化</a><li><a href="https://zhuanlan.zhihu.com/p/101319550">《深入精通Mysql（七）》系列之如何通过EXPLAIN 执行计划分析SQL语句的性能瓶颈</a><li>配置可能引发一些问题：<a href="https://www.bilibili.com/read/cv16090870/">MySQL部署和运维</a>、<a href="https://www.cnblogs.com/yangchongxing/p/11993380.html">mysql配置和问题</a>、<a href="https://cloud.tencent.com/developer/article/2069199">mysql配置参数详解</a></ul></ul><p><a href="/assets/img/it_basic/mysql/mysql框架图-1.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/mysql框架图-1.jpeg" alt="图01-框架图-1" title="MySQL 架构图-1" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/mysql框架图-2.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/mysql框架图-2.jpeg" alt="图01-框架图-2" title="MySQL 架构图-2" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/mysql框架图-3.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/mysql框架图-3.png" alt="图01-框架图-3" title="MySQL 架构图-3" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/mysql框架图-4.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/mysql框架图-4.jpeg" alt="图01-框架图-4" title="MySQL 架构图-4" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/mysql框架图-5.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/mysql框架图-5.png" alt="图01-框架图-5" title="MySQL 架构图-5" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/mysql-001.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/mysql-001.png" alt="图01-框架图-5" class="lazyload" data-proofer-ignore></a></p><h1 id="sql-语句">SQL 语句</h1><p>MySQL 语句可以分为以下几类，详细的可参考<a href="https://www.w3cschool.cn/sql/">标准SQL</a>。</p><ul><li>mysql支持的数据类型可参考<a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">官方文档</a><li>mysql与标准的SQL的关系可参考<a href="https://dev.mysql.com/doc/refman/8.0/en/extensions-to-ansi.html">标准SQL扩展</a>、<a href="https://dev.mysql.com/doc/refman/8.0/en/differences-from-ansi.html">与标准SQL的差异</a><li>mysql操作可参考<a href="https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html">官方文档</a></ul><div class="table-wrapper"><table><thead><tr><th>类型<th>包含的指令<tbody><tr><td><code class="language-plaintext highlighter-rouge">DDL</code>((Data Definition Language，数据定义语言))<td><code class="language-plaintext highlighter-rouge">create</code>: 创建数据库及其对象(包括新建表，索引，视图，存储过程，用户等)<tr><td> <td><code class="language-plaintext highlighter-rouge">alter</code>: 改变现有数据库或表的结构 (包括修改索引，修改字段类型，删除索引)<tr><td> <td><code class="language-plaintext highlighter-rouge">truncate</code>: 删除表中所有记录，并删除已分配的空间<tr><td> <td><code class="language-plaintext highlighter-rouge">comment</code>: 添加注释<tr><td> <td><code class="language-plaintext highlighter-rouge">rename</code>: 重命名，其中包括索引、表名等。<tr><td> <td><code class="language-plaintext highlighter-rouge">use</code>: 切换数据库。<tr><td> <td><code class="language-plaintext highlighter-rouge">show</code>: 查看所有的数据库或表或建表语句，后面可接 databases，tables，或者 show create databases或table 库名或表名。<tr><td> <td><code class="language-plaintext highlighter-rouge">desc</code>: 查看表结构 desc 表名<tr><td> <td><code class="language-plaintext highlighter-rouge">drop</code>: 删除数据库或表或用户，drop database或table 库名或表名<tr><td><code class="language-plaintext highlighter-rouge">DML</code> (Data Manipulation Language，数据操作语句)<td><code class="language-plaintext highlighter-rouge">select</code>: 从数据库中检索数据<tr><td> <td><code class="language-plaintext highlighter-rouge">insert</code>: 新增数据到数据库中<tr><td> <td><code class="language-plaintext highlighter-rouge">update</code>: 更新表格中现有数据<tr><td> <td><code class="language-plaintext highlighter-rouge">delete</code>: 删除现有数据<tr><td> <td><code class="language-plaintext highlighter-rouge">explain</code>: 查看语句的执行计划<tr><td> <td><code class="language-plaintext highlighter-rouge">lock table</code>: 锁表操作<tr><td><code class="language-plaintext highlighter-rouge">DCL</code> (Data Control Language，数据控制语句)<td><code class="language-plaintext highlighter-rouge">grant</code>: 允许用户访问数据库的权限<tr><td> <td><code class="language-plaintext highlighter-rouge">revoke</code>: 撤销用户访问数据库的权限<tr><td><code class="language-plaintext highlighter-rouge">TCL</code> (Transactional Control Language，事务控制语言)<td><code class="language-plaintext highlighter-rouge">commit</code>: 提交事务<tr><td> <td><code class="language-plaintext highlighter-rouge">rollback</code>: 回滚事务<tr><td> <td><code class="language-plaintext highlighter-rouge">set transaction</code>: 设置事务隔离级别</table></div><p>这里以存储过程的操作为例：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">-- 创建存储过程</span>
<span class="k">CREATE</span> <span class="k">PROCEDURE</span> <span class="n">proname</span><span class="p">()</span> 
<span class="k">BEGIN</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>

<span class="c1">-- 执行存储过程</span>
<span class="k">CALL</span> <span class="n">proname</span><span class="p">();</span>

<span class="c1">-- 删除存储过程</span>
<span class="k">DROP</span> <span class="k">PROCEDURE</span> <span class="n">proname</span><span class="p">;</span>

</pre></table></code></div></div><h2 id="数据库连接"><span class="mr-2">数据库连接</span><a href="#数据库连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当你在终端敲下该命令 <code class="language-plaintext highlighter-rouge">mysql -h 主机名(ip) -u 用户名 -P 端口 -p密码 数据库名 --default-character-set=编码类型</code> （详细参数说明可参考<a href="https://dev.mysql.com/doc/refman/8.0/en/programs-client.html">官方文档</a> 回车之后发生了什么？</p><ul><li>TCP 三次握手<li>mysql 客户端与服务端握手认证（三次握手）<ul><li>服务器 -&gt; 客户端：握手初始化消息<li>客户端 -&gt; 服务器：登陆认证消息<li>服务器 -&gt; 客户端：认证结果消息</ul><li>命令执行阶段（上述阶段完成之后）<ul><li>客户端 -&gt; 服务器：执行命令消息<li>服务器 -&gt; 客户端：命令执行结果</ul><li>退出命令<li>TCP 四次挥手</ul><blockquote><p>参考文章</p></blockquote><ul><li>具体的协议包分析可参考<a href="https://www.shuzhiduo.com/A/Gkz18rb2dR/">mysql通信协议抓包分析</a>、<a href="https://my.oschina.net/OutOfMemory/blog/1595684">Mysql 通讯协议分析</a>、 <a href="https://blog.csdn.net/qq794096244/article/details/112543129?spm=1001.2101.3001.6650.15&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-112543129-blog-113088775.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-112543129-blog-113088775.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=21">通信方式类别</a>。 mysql 客户端与服务端的通信协议可参考<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_PROTOCOL.html">官方文档</a>。<li>对于 TCP 的连接和断开分析可参考 <a href="https://www.cnblogs.com/zhuochongdashi/archive/2021/10/26/15465151.html">4个实验，彻底搞懂TCP连接的断开</a>。<li>不用的版本或配置，可能会导致相同的语句的执行结果或报错不一样，配置可参考<a href="https://www.cnblogs.com/Lqdream/p/16924954.html">Mysql数据库配置参数详解大全</a>、<a href="https://cloud.tencent.com/developer/article/2069199">mysql配置参数详解</a></ul><h2 id="语句执行流程"><span class="mr-2">语句执行流程</span><a href="#语句执行流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>了解 MySQL 语句执行流程有助于我们优化和选择恰当的语句，以提供性能。每个具体执行流程中执行 的操作不相同，所涉及到的数据量不同，有的可能使用临时表等，针对这些特点可以采取更换顺序、 减少数据量等手段进行优化。</p><h3 id="查询语句执行流程"><span class="mr-2">查询语句执行流程</span><a href="#查询语句执行流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>DML语句首先进行语法分析，对使用sql表示的查询进行语法分析，生成查询语法分析树。<li>语义检查：检查sql中所涉及的对象以及是否在数据库中存在，用户是否具有操作权限等<li>视图转换：将语法分析树转换成关系代数表达式，称为逻辑查询计划；<li>查询优化：在选择逻辑查询计划时，会有多个不同的表达式，选择最佳的逻辑查询计划；<li>代码生成：必须将逻辑查询计划转换成物理查询计划，物理查询计划不仅能指明要执行的操作，也给出了这些操作的执行顺序，每步所用的算法，存储数据的方式以及从一个操作传递给另一个操作的方式。<li>将DML转换成一串可执行的存取操作的过程称为束缚过程，</ul><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">--查询组合字段</span>
<span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="k">select</span> <span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="k">distinct</span><span class="p">(</span><span class="mi">6</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="n">top</span><span class="p">(</span><span class="o">&lt;</span><span class="n">top_specification</span><span class="o">&gt;</span><span class="p">)(</span><span class="mi">6</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="n">select_list</span><span class="o">&gt;</span>
<span class="c1">--连表</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="k">from</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">J</span><span class="p">)</span><span class="o">&lt;</span><span class="n">left_table</span><span class="o">&gt;&lt;</span><span class="n">join_type</span><span class="o">&gt;</span> <span class="k">join</span> <span class="o">&lt;</span><span class="n">right_table</span><span class="o">&gt;</span> <span class="k">on</span> <span class="o">&lt;</span><span class="n">on_predicate</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">&lt;</span><span class="n">left_table</span><span class="o">&gt;&lt;</span><span class="n">apply_type</span><span class="o">&gt;</span> <span class="n">apply</span> <span class="o">&lt;</span><span class="n">right_table_expression</span><span class="o">&gt;</span> <span class="k">as</span> <span class="o">&lt;</span><span class="k">alias</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">P</span><span class="p">)</span><span class="o">&lt;</span><span class="n">left_table</span><span class="o">&gt;</span> <span class="n">pivot</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">pivot_specification</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">as</span> <span class="o">&lt;</span><span class="k">alias</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">U</span><span class="p">)</span><span class="o">&lt;</span><span class="n">left_table</span><span class="o">&gt;</span> <span class="n">unpivot</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">unpivot_specification</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">as</span> <span class="o">&lt;</span><span class="k">alias</span><span class="o">&gt;</span>
<span class="c1">--查询条件</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="k">where</span> <span class="o">&lt;</span><span class="n">where_pridicate</span><span class="o">&gt;</span>
<span class="c1">--分组</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="k">group</span> <span class="k">by</span> <span class="o">&lt;</span><span class="n">group_by_specification</span><span class="o">&gt;</span>
<span class="c1">--是否对分类聚合后的结果进行再汇总</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="k">with</span> <span class="o">&lt;</span><span class="k">cube</span><span class="o">|</span><span class="k">rollup</span><span class="o">&gt;</span>
<span class="c1">--分组条件</span>
<span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="k">having</span><span class="o">&lt;</span><span class="n">having_predicate</span><span class="o">&gt;</span>
<span class="c1">--排序</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="k">union</span><span class="p">(</span><span class="k">all</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="k">order</span> <span class="k">by</span><span class="o">&lt;</span><span class="n">order_by_list</span><span class="o">&gt;</span>
<span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="k">limit</span> <span class="o">&lt;</span><span class="n">limit_number</span><span class="o">&gt;</span>

<span class="c1">--说明：</span>
<span class="c1">--1、顺序为有1-6，6个大步骤，然后细分，6-1，6-2，6-3，由小变大顺序，1-J，1-A，1-P，1-U，为并行次序。如果不够明白，接下来我在来个流程图看看。</span>
<span class="c1">--2、执行过程中也会相应的产生多个虚拟表（下面会有提到），以配合最终的正确查询。</span>
<span class="c1">--参考自博客：https://blog.csdn.net/bitcarmanlee/article/details/51004767?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-6.control</span>
</pre></table></code></div></div><p><a href="/assets/img/it_basic/mysql/select解析-1.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/select解析-1.png" alt="select解析" title="select 解析" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/select执行流程-1.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/select执行流程-1.png" alt="select执行流程" title="select 执行流程-1" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/mysql/select执行流程-2.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/select执行流程-2.png" alt="select执行流程" title="select 执行流程-2" class="lazyload" data-proofer-ignore></a></p><h4 id="查询状态"><span class="mr-2">查询状态</span><a href="#查询状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>对于 MySQL 连接，任何时刻都有一个状态，该状态表示了MySQL当前正在做什么。使用 <code class="language-plaintext highlighter-rouge">show full processlist</code> 命令查看当前状态。 在一个查询生命周期中，状态会变化很多次，下面是这些状态的解释：</p><ul><li><code class="language-plaintext highlighter-rouge">sleep</code>：线程正在等待客户端发送新的请求；<li><code class="language-plaintext highlighter-rouge">query</code>：线程正在执行查询或者正在将结果发送给客户端；<li><code class="language-plaintext highlighter-rouge">locked</code>：在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态；<li><code class="language-plaintext highlighter-rouge">analyzing and statistics</code>：线程正在收集存储引擎的统计信息，并生成查询的执行计划；<li><code class="language-plaintext highlighter-rouge">copying to tmp table</code>：线程在执行查询，并且将其结果集复制到一个临时表中，这种状态一般要么是做group by操作，要么是文件排序操作，或者union操作。如果这个状态后面还有on disk标记，那表示MySQL正在将一个内存临时表放到磁盘上；<li><code class="language-plaintext highlighter-rouge">sorting result</code>：线程正在对结果集进行排序；<li><code class="language-plaintext highlighter-rouge">sending data</code>：线程可能在多个状态间传送数据，或者在生成结果集，或者在想客户端返回数据。</ul><h4 id="查询优化"><span class="mr-2">查询优化</span><a href="#查询优化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>MySQL Query Optimizer 通过执行explain命令来获取一个 Query 在当前状态的数据库中的执行计划。 <code class="language-plaintext highlighter-rouge">expain</code> 出来的信息有10列，分别是 <code class="language-plaintext highlighter-rouge">id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code>。 可以通过<a href="http://mysql.jsrun.net/">这个线上实验网站</a>进行 <code class="language-plaintext highlighter-rouge">expain</code> 实验。</p><ul><li>示例可参见<a href="https://dev.mysql.com/doc/refman/8.0/en/execution-plan-information.html">官方文档</a><li><a href="http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html">Mysql Explain 详解</a>。<li><a href="https://zhuanlan.zhihu.com/p/461298579">万字SQL优化大全</a><li><a href="https://www.cnblogs.com/DisciplinevsFreedom/p/16905202.html">MySQL的SQL优化常用30种方法</a>、<a href="https://zhuanlan.zhihu.com/p/337513296">21个SQL语句优化规范方法</a>、<a href="https://blog.51cto.com/lxw1844912514/2937934">MySQL数据库优化技巧大全</a><li><a href="https://blog.csdn.net/guorui_java/article/details/118633664">MySql基础知识总结（SQL优化篇）</a>、<a href="https://blog.csdn.net/lonelymanontheway/article/details/85851153">MySQL数据库优化总结</a><li><a href="https://www.jb51.net/article/232855.htm">MySQL定位并优化慢查询sql的详细实例</a></ul><div class="table-wrapper"><table><thead><tr><th>字段名<th>描述<th>值<tbody><tr><td><code class="language-plaintext highlighter-rouge">id</code><td>SELECT 识别符。这是 SELECT 的查询序列号<td><code class="language-plaintext highlighter-rouge">id</code> 相同时，执行顺序由上至下<tr><td> <td> <td>如果是子查询，<code class="language-plaintext highlighter-rouge">id</code> 的序号会递增，<code class="language-plaintext highlighter-rouge">id</code> 值越大优先级越高，越先被执行<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">id</code> 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，<code class="language-plaintext highlighter-rouge">id</code> 值越大，优先级越高，越先执行<tr><td><code class="language-plaintext highlighter-rouge">select_type</code><td>示查询中每个 select 子句的类型<td><code class="language-plaintext highlighter-rouge">SIMPLE</code>(简单SELECT,不使用UNION或子查询等)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">PRIMARY</code>(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">UNION</code>(UNION中的第二个或后面的SELECT语句)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">DEPENDENT UNION</code>(UNION中的第二个或后面的SELECT语句，取决于外面的查询)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">UNION RESULT</code>(UNION的结果)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">SUBQUERY</code>(子查询中的第一个SELECT)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">DEPENDENT SUBQUERY</code>(子查询中的第一个SELECT，取决于外面的查询)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">DERIVED</code>(派生表的SELECT, FROM子句的子查询)；<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">UNCACHEABLE SUBQUERY</code>(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)。<tr><td><code class="language-plaintext highlighter-rouge">table</code><td>表示 explain 的一行正在访问哪个表<td>有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称<tr><td><code class="language-plaintext highlighter-rouge">type</code><td>表示MySQL在表中找到所需行的方式<td>常用的类型有：<code class="language-plaintext highlighter-rouge">ALL, index, range, ref, eq_ref, const, system, NULL</code>（从左到右，性能从差到好）<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">ALL</code>：Full Table Scan， MySQL将遍历全表以找到匹配的行<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">index</code>: Full Index Scan，index 与 ALL 区别为 index 类型只遍历索引树<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">range</code>:只检索给定范围的行，使用一个索引来选择行<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">ref</code>: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。相比 <code class="language-plaintext highlighter-rouge">eq_ref</code>，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">eq_ref</code>: 类似 <code class="language-plaintext highlighter-rouge">ref</code>，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">const、system</code>: 当 MySQL 对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">NULL</code>: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。<tr><td><code class="language-plaintext highlighter-rouge">possible_keys</code><td>显示查询可能使用哪些索引来查找<td>explain 时可能出现 <code class="language-plaintext highlighter-rouge">possible_keys</code> 有列，而 <code class="language-plaintext highlighter-rouge">key</code> 显示 NULL 的情况，这种情况是因为表中数据不多，MySQL认为索引对此查询帮助不大，选择了全表查询。<tr><td> <td> <td>如果该列是 <code class="language-plaintext highlighter-rouge">NULL</code>，则没有相关的索引。在这种情况下，可以通过检查 <code class="language-plaintext highlighter-rouge">where</code> 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果<tr><td><code class="language-plaintext highlighter-rouge">key</code><td>显示 MySQL 实际决定使用的键（索引）<td>如果没有选择索引，键是 NULL。要想强制 MySQL 使用或忽视 <code class="language-plaintext highlighter-rouge">possible_keys</code> 列中的索引，在查询中使用 <code class="language-plaintext highlighter-rouge">FORCE INDEX、USE INDEX</code> 或者 <code class="language-plaintext highlighter-rouge">IGNORE INDEX</code>。<tr><td><code class="language-plaintext highlighter-rouge">key_len</code><td>表示索引中使用的字节数<td>可通过该列计算查询中使用的索引的长度（<code class="language-plaintext highlighter-rouge">key_len</code> 显示的值为索引字段的最大可能长度，并非实际使用长度，即 <code class="language-plaintext highlighter-rouge">key_len</code> 是根据表定义计算而得，不是通过表内检索出的）<tr><td> <td> <td>不损失精确性的情况下，长度越短越好。<tr><td><code class="language-plaintext highlighter-rouge">ref</code><td>这一列显示了在 key 列记录的索引中，表查找值所用到的列或常量<td>常见的有：const（常量），func，NULL，字段名（例：film.id）<tr><td><code class="language-plaintext highlighter-rouge">rows</code><td>估计要读取并检测的行数<td>这个不是结果集里的行数<tr><td><code class="language-plaintext highlighter-rouge">filtered</code><td>返回结果的行数占读取行数的百分比<td>值越大越好<tr><td><code class="language-plaintext highlighter-rouge">Extra</code><td>额外信息<td><code class="language-plaintext highlighter-rouge">distinct</code>: 一旦mysql找到了与行相联合匹配的行，就不再搜索了<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">Using index</code>: 所有列都覆盖索引时， 不需要返回表中的行记录<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">Using where</code>: 在存储引擎检索行后再进行过滤<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">Using temporary</code>: 表示MySQL需要使用临时表来存储结果集，常见于 distinct、排序和分组查询。这个需要优化，比如是否有必要使用该语句、新建索引等<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">Using filesort</code>：MySQL中无法利用索引完成的排序操作称为“文件排序”，对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时 mysql 会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">Using join buffer</code>：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。<tr><td> <td> <td><code class="language-plaintext highlighter-rouge">Impossible where</code>：这个值强调了 where 语句会导致没有符合条件的行。</table></div><blockquote><p>offset limit 优化</p></blockquote><p>mysql查询使用select命令，配合limit，offset参数可以读取指定范围的记录,但是offset过大影响查询性能</p><ul><li>通过二级索引查到主键值（找出所有gender=1的id)。<li>再根据查到的主键值通过主键索引找到相应的数据块（根据id找出对应的数据块内容）。<li>根据offset的值，查询300001次主键索引的数据，最后将之前的300000条丢弃，取出最后1条。</ul><p>所以，mysql 查询时，offset 过大影响性能的原因是多次通过主键索引访问数据块的I/O操作。优化方法有以下几种：</p><ul><li>自增 ID 范围： 如 select * from table_name where (id &gt;= 10000) limit 10<li>in 主键： 如 Select * From table_name Where id in (Select id From table_name where ( user = xxx )) limit 10000, 10;<li>inner join: 如 select * from table_name inner join ( select id from table_name where (user = xxx) limit 10000,10) b using (id)<li>提前算出边界，使用 between and 代替</ul><h3 id="update-语句执行流程"><span class="mr-2">update 语句执行流程</span><a href="#update-语句执行流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>以语句 <code class="language-plaintext highlighter-rouge">UPDATE test SET c = c + 1 WHERE id = 1;</code> 为例简单绘制成下图（详见<a href="https://www.jb51.net/article/183349.htm">mysql update语句的执行过程详解</a>）</p><p><a href="/assets/img/it_basic/mysql/update执行流程-1.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/update执行流程-1.png" alt="update 执行流程" title="update 执行流程" class="lazyload" data-proofer-ignore></a></p><p>当事务提交的时候，innodb不会立即删除undo log，因为后续还可能会用到undo log，如隔离级别为repeatable read时， 事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除，即undo log不能删除。 但是在事务提交的时候，会将该事务对应的undo log放入到删除列表中，未来通过purge来删除。 并且提交事务时，还会判断undo log分配的页是否可以重用， 如果可以重用，则会分配给后面来的事务，避免为每个独立的事务分配独立的undo log页而浪费存储空间和性能。</p><p>通过undo log记录delete和update操作的结果发现：(insert操作无需分析，就是插入行而已) delete操作实际上不会直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的。 update分为两种情况：update的列是否是主键列。</p><ul><li>如果不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。<li>如果是主键列，update分两部执行：先删除该行，再插入一行目标行。</ul><h3 id="insert-语句执行流程"><span class="mr-2">insert 语句执行流程</span><a href="#insert-语句执行流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这里只给出简约的流程图（详见<a href="https://blog.csdn.net/weixin_39894255/article/details/111254315?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-4&amp;spm=1001.2101.3001.4242">MySQL insert 语句的磁盘写入之旅</a>）：</p><p><a href="/assets/img/it_basic/mysql/insert执行流程-1.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/insert执行流程-1.png" alt="insert 执行流程" title="insert 执行流程" class="lazyload" data-proofer-ignore></a></p><h3 id="delete-语句执行流程"><span class="mr-2">delete 语句执行流程</span><a href="#delete-语句执行流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这里只给出简约的流程图：</p><p><a href="/assets/img/it_basic/mysql/delete执行流程-1.png" class="popup img-link "><img data-src="/assets/img/it_basic/mysql/delete执行流程-1.png" alt="delete 执行流程" title="delete 执行流程" class="lazyload" data-proofer-ignore></a></p><blockquote><p>删除优化</p></blockquote><p>根据不同的需求选择恰当的删除数据的方式：</p><ul><li>drop： 是直接将表格删除（包括表结构），无法找回<li>truncate： 是删除表中所有数据（保留表结构）<li>delete： 也是删除表中数据，但可以与 where 连用，删除特定行；<li>逻辑珊瑚：使用标记位<li>当待删除的数据比要保留的数据量大得多时：可以先转移要保留的数据，truncate 之后再转回</ul><blockquote><p>delete 和 truncate 的区别</p></blockquote><ul><li>DELETE 是可以带 WHERE 的，所以支持条件删除；而 TRUNCATE 只能删除整个表<li>由于 DELETE 是数据操作语言（DML - Data Manipulation Language），操作时原数据会被放到 rollback segment中，可以被回滚；而 TRUNCATE 是数据定义语言（DDL - Data Definition Language)，操作时不会进行存储，不能进行回滚<li>在数据量比较小的情况下，DELETE 和 TRUNCATE 的清理速度差别不是很大。 但是数据量很大的时候就能看出区别。由于第二项中说的，TRUNCATE 不需要支持回滚， 所以使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项， 固然会慢，但是相对来说也较安全<li>随着不断地进行表记录的 DML 操作，会不断提高表的高水位线（HWM），DELETE操作之后虽然表的数据删除了，但是并没有降低表的高水位， 随着 DML 操作数据库容量也只会上升，不会下降。所以如果使用 DELETE，就算将表中的数据减少了很多， 在查询时还是很和 DELETE 操作前速度一样。 而 TRUNCATE 操作会重置高水位线，数据库容量也会被重置，之后再进行 DML 操作速度也会有提升。</ul><h2 id="语句实现原理"><span class="mr-2">语句实现原理</span><a href="#语句实现原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="select-工作原理"><span class="mr-2">select 工作原理</span><a href="#select-工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可参见 <a href="https://www.jianshu.com/p/NsWbRv">MySQL select实现原理</a></p><h3 id="关联查询join"><span class="mr-2">关联查询（join）</span><a href="#关联查询join" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>join 实现原理可参见 <a href="https://blog.csdn.net/qq_37050329/article/details/88777937">MySQL 的Join及底层实现原理</a>、 <a href="https://zhuanlan.zhihu.com/p/54275505">数据库基础（七）Mysql Join算法原理</a>， 各种join可参见 <a href="https://database.51cto.com/art/201908/602009.htm">图解MySQL里的各种 JOIN，看完不懂来找我！</a></p><h3 id="order-by-工作原理"><span class="mr-2">order by 工作原理</span><a href="#order-by-工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可参见 <a href="https://blog.csdn.net/qq_37113604/article/details/88973260?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">MySQL order by、group by底层实现及优化（非常详细）</a>、 <a href="https://blog.csdn.net/lijingkuan/article/details/70341176">MySQL order by实现原理分析和Filesort优化</a>、 <a href="https://www.cnblogs.com/lamp01/p/10770172.html">Mysql学习之order by的工作原理</a>、 <a href="https://www.cnblogs.com/ggjucheng/archive/2012/11/18/2776449.html">mysql ORDER BY,GROUP BY 和DISTINCT原理</a></p><h3 id="group-by-工作原理"><span class="mr-2">group by 工作原理</span><a href="#group-by-工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可参见 <a href="https://www.jb51.net/article/85359.htm">MySQL分组查询Group By实现原理详解</a></p><h3 id="where-和-having-的区别"><span class="mr-2">where 和 having 的区别</span><a href="#where-和-having-的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可参见 <a href="https://www.pianshen.com/article/6347723055/">mysql having和where的区别</a>、 <a href="https://www.cnblogs.com/xuchao0506/p/9766234.html">mysql where和having的区别</a>、 <a href="https://www.cnblogs.com/leihaha/p/8202935.html">Mysql-where子句与having子句的区别</a></p><h1 id="事务机制">事务机制</h1><p>我们可以把事务理解为一组sql语句的集合，事务可以只包含一条sql语句，也能包含多条复杂的SQL语句， 事务中的所有SQL语句被当作一个操作单元，也就是说，事务中的SQL语句要么都执行成功，要么全部执行失败， 事务内的SQL语句被当做一个整体，被当做一个原子进行操作。MySQL 典型的事务语句使用方法可参见 <a href="https://www.cnblogs.com/coshaho/p/7450543.html">mysql事务（二）——控制语句使用</a>，详细用法见 <a href="https://www.cnblogs.com/diegodu/p/8818776.html">MySQL事务控制语句（学习笔记）</a> ，事务处理实例可参考 <a href="https://blog.csdn.net/hju22/article/details/86651973?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">mysql事务处理语句及使用</a></p><ul><li>事务（transaction）指一组SQL语句；<li>回退（rollback）指撤销指定SQL语句的过程；<li>提交（commit）指将未存储的SQL语句结果写入数据库表；<li>保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）</ul><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">-- 使用回退</span>
<span class="k">START</span> <span class="n">TRANSACTION</span>
<span class="k">delete</span> <span class="k">from</span> <span class="k">table</span>  <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">123</span><span class="p">;</span> <span class="c1">--删除的数据 ROLLBACK 后将会还原</span>
<span class="k">ROLLBACK</span><span class="p">;</span>

<span class="c1">-- 使用提交</span>
<span class="k">START</span> <span class="n">TRANSACTION</span>
<span class="k">delete</span> <span class="k">from</span> <span class="k">table</span>  <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">123</span><span class="p">;</span>
<span class="k">delete</span> <span class="k">from</span> <span class="k">table</span>  <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">123</span><span class="p">;</span>
<span class="k">COMMIT</span><span class="p">;</span> 
<span class="c1">-- COMMIT语句仅在不出错时写出更改，只要有一条语句错误 ，所有语句将会回退。</span>

<span class="c1">-- 使用保留点</span>
<span class="c1">-- 使用保留点处理部分提交或回退</span>
<span class="n">SAVEPOINT</span> <span class="n">pointName</span><span class="p">;</span> <span class="c1">-- 定义一个保留点</span>
<span class="k">ROLLBACK</span> <span class="k">TO</span> <span class="n">pointName</span><span class="p">;</span> <span class="c1">-- 回退到指定保留点</span>
<span class="n">RELEASE</span> <span class="n">SAVEPOINT</span> <span class="n">pointName</span><span class="p">;</span> <span class="c1">--明确地释放保留点</span>

</pre></table></code></div></div><h2 id="衡量事务的四个特性acid"><span class="mr-2">衡量事务的四个特性（ACID）</span><a href="#衡量事务的四个特性acid" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足 ACID 的事务少之又少。 例如 MySQL 的 NDB Cluster 事务不满足持久性和隔离性；InnoDB 默认事务隔离级别是可重复读，不满足隔离性； Oracle 默认的事务隔离级别为 READ COMMITTED，不满足隔离性……因此与其说 ACID 是事务必须满足的条件， 不如说它们是衡量事务的四个维度</p><div class="table-wrapper"><table><thead><tr><th>事务特性<th>描述<th>实现原理<tbody><tr><td>原子性（Atomicity，或称不可分割性）<td>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；<br /> 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。<td>undo log保证了事务的原子性<tr><td>一致性（Consistency）<td>一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。<br />数据库的完整性约束包括但不限于：<br />实体完整性（如行的主键存在且唯一）、<br />列完整性（如字段的类型、大小、长度要符合要求）、外键约束、<br />用户自定义完整性（如转账前后，两个账户余额的和应该不变）。<td>原子性、持久性和隔离性都是为了实现事务的一致性<tr><td>隔离性（Isolation）<td>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰<td>(一个事务)写操作对(另一个事务)写操作的影响：<br />锁机制保证隔离性；<br />(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。<br />InnoDB默认的隔离级别是RR，<br />RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）<tr><td>持久性（Durability）<td>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响<td>MySQL的innoDB存储引擎，使用Redo log保证了事务的持久性</table></div><p>数据库中的一致性可以分为数据库外部的一致性和数据库内部的一致性。前者由外部应用的编码来保证， 即某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作。 如果在这个层次出现错误，这不是数据库本身能够解决的，也不属于我们需要讨论的范围。后者由数据库来保证， 即在同一个事务内部的一组操作必须全部执行成功(或者全部失败)。这就是事务处理的原子性。</p><p>如果在事务中第一次读取采用非加锁读，第二次读取采用加锁读，则如果在两次读取之间数据发生了变化， 两次读取到的结果不一样，因为加锁读时不会采用 MVCC</p><h3 id="undo-log-实现原子性"><span class="mr-2">undo log 实现原子性</span><a href="#undo-log-实现原子性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>MySQL 的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等， 此外 InnoDB 存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。 其中 redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。InnoDB 实现回滚， 靠的是 undo log：当事务对数据库进行修改时，InnoDB 会生成对应的 undo log； 如果事务执行失败或调用了 rollback，导致事务需要回滚， 便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p><p>undo log 属于逻辑日志，它记录的是 sql 执行相关的信息。当发生回滚时， InnoDB 会根据 undo log的内容做与之前相反的工作：对于每个 insert，回滚时会执行 delete； 对于每个 delete，回滚时会执行 insert；对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</p><h3 id="redo-log-实现持久性"><span class="mr-2">redo log 实现持久性</span><a href="#redo-log-实现持久性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘 IO，效率会很低。 为此，InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射， 作为访问数据库的缓冲：当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有， 则从磁盘读取后放入 Buffer Pool；当向数据库写入数据时，会首先写入 Buffer Pool， Buffer Pool 中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。</p><p>Buffer Pool 的使用大大提高了读写数据的效率，但是也带了新的问题：如果 MySQL 宕机， 而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据， 还会在 redo log 记录这次操作；当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。 如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。 redo log 采用的是 WAL（Write-ahead logging，预写式日志），所有修改先写入日志， 再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。</p><p>在这个事务提交前，将 redo log 的写入拆成了两个步骤，prepare 和 commit，这就是”两阶段提交”。</p><blockquote><p>为什么要采用两阶段提交呢？</p></blockquote><p>实际上，两阶段提交是分布式系统常用的机制。MySQL 使用了两阶段提交后，也是为了保证事务的持久性。 redo log 和 bingo 有一个共同的数据字段叫 XID, 崩溃恢复的时候，会按顺序扫描 redo log。</p><ul><li>假设在写入 binlog 前系统崩溃，那么数据库恢复后顺序扫描 redo log，碰到只有 parepare、 而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务，而且 binlog 也没写入，所以事务就直接回滚了。<li>假设在写入 binlog 之后，事务提交前数据库崩溃，那么数据库恢复后顺序扫描 redo log， 碰到既有 prepare、又有 commit 的 redo log，就直接提交，保证数据不丢失。</ul><p>插入数据的过程中，生成的日志都得先写入 redo log buffer ，等到 commit 的时候，才真正把日志写到 redo log 文件。 （当然，这里不绝对，因为redo log buffer可能因为其他原因被迫刷新到redo log）。而为了确保每次日志都能写入日志文件， 在每次将 重做日志缓冲 写入 重做日志文件 后，InnoDB 存储引擎都需要调用一次 fsync 操作，确保写入了磁盘。</p><p>而为了确保每次日志都能写入日志文件，在每次将重做日志缓冲 写入 重做日志文件 后，InnoDB存储引擎都需要调用一次fsync操作，确保写入了磁盘。</p><h3 id="锁和-mvcc-机制实现隔离性"><span class="mr-2">锁和 MVCC 机制实现隔离性</span><a href="#锁和-mvcc-机制实现隔离性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>MySQL 的锁机制可以参见<a href="https://zhuanlan.zhihu.com/p/29150809/">MySQL锁总结</a>，结合案例分析可 参见<a href="https://blog.csdn.net/qq_40378034/article/details/90904573">MySQL锁详解</a>。MVCC 可参见 <a href="https://blog.51cto.com/u_12182612/2486731">正确的理解MySQL的MVCC及实现原理</a>，其案例分析可参见 <a href="https://www.jianshu.com/p/f692d4f8a53e">MYSQL MVCC实现原理</a>，版本链形象化描述可参见 <a href="https://blog.csdn.net/qianghaiyang/article/details/109907563?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-1-109907563.pc_agg_rank_aggregation&amp;utm_term=mvcc%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3+mysql&amp;spm=1000.2123.3001.4430">mvcc原理详解</a> MVCC 具象化描述可参见 <a href="https://www.cnblogs.com/deepalley/p/14415042.html">MySQL MVCC底层原理详解MySQL MVCC底层原理详解</a></p><h1 id="日志文件">日志文件</h1><ul><li>日志文件的类型可参见 <a href="https://mp.weixin.qq.com/s/-v6CHvvAwtuznG-bzZKQ0w">MySQL不会丢失数据的秘密，就藏在它的 7种日志里</a>、<a href="https://www.jb51.net/article/216581.htm">MySQL系列之十一 日志记录</a> 、<a href="https://segmentfault.com/a/1190000039860472">MySQL中的日志文件 你全都了解吗？</a> 或 <a href="https://www.cnblogs.com/f-ck-need-u/p/9001061.html#auto_id_3">详细分析MySQL的日志(一)</a><li>binlog、undo log、redo log 参见<a href="http://xiaot123.com/mysqlbinlogredologundolog-lagwx">彻底搞懂mysql日志系统binlog,redolog,undolog</a>、<a href="https://blog.csdn.net/cxyITgc/article/details/108706531">必须了解的mysql三大日志,你知道几个？</a><li>binlog 详解可参见 <a href="https://www.cnblogs.com/kevingrace/p/6065088.html">MySQL 数据库之Binlog日志使用总结</a><li>事务日志详解可参见 <a href="https://www.cnblogs.com/f-ck-need-u/p/9010872.html">详细分析MySQL事务日志(redo log和undo log)</a>、<a href="https://www.cnblogs.com/xinysu/p/6555082.html">说说MySQL中的Redo log Undo log都在干啥</a> 、<a href="https://www.cnblogs.com/GGGong/p/12124476.html">Redo与Undo的理解</a></ul><blockquote><p>redo 和 bin 日志区别(<a href="https://blog.csdn.net/suifeng629/article/details/106310027?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control">联系见该文</a>)</p></blockquote><ul><li>产生位置不同： redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。<li>记录内容不同： redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑<li>生成方式不同： redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。<li>使用目的不同： binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。<li>写入时间不同： binlog仅仅在事务提交前，只写磁盘⼀次，不论这时该事务多⼤；重做⽇志，在事务进⾏过程中，会发⽣不断地写⼊</ul><blockquote><p>redolog 和 undolog的区别</p></blockquote><ul><li>作用不同： redolog即重做⽇志，⽤来保证事务的原⼦性和持久性。正常情况⽤不到，只有 mysql 实例所在的主机断电了， Innodb存储引擎会使⽤redolog恢复到掉电前的时刻，保证数据完整性；undolog⽤来保证事务的⼀致性，当事务需要回滚时，就会⽤到undolog<li>位置不同： redolog存储在重做⽇志⽂件中， undo放在数据库内部的⼀个特殊的段，这个段被称 为undo段。 undo段位于共享表空间内<li>类型不同： redo是物理⽇志，记录的是⻚的物理修改操作。undo是逻辑⽇志，根据每⾏记录进⾏记录。 当事务回滚时， undolog回滚⾏记录到某个特定版本。只是将数据库逻辑地恢复到原来的样⼦， ⽽不是完整的将数据库回滚到事务开始前的样⼦。 事务回滚可能有各种原因，⽐如死锁回滚，⽐如⽤⽤户主动rollback等.</ul><h2 id="日志落盘策略"><span class="mr-2">日志落盘策略</span><a href="#日志落盘策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Mysql 普通落盘策略可参见 <a href="https://www.cnblogs.com/VicLiu/p/13968661.html">MySQL InnoDB的磁盘文件及落盘机制</a> 和 <a href="https://blog.csdn.net/weixin_35179252/article/details/113287073">mysql数据落盘详解_MySQL的Flush-List和脏页的落盘机制</a> redo 日志刷盘策略可参见 <a href="https://blog.csdn.net/weixin_38629422/article/details/105813338">redo日志的刷盘策略</a></p><h2 id="数据丢失的场景"><span class="mr-2">数据丢失的场景</span><a href="#数据丢失的场景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>可参见 <a href="http://blog.itpub.net/30109892/viewspace-2062493/">MySQL数据库丢失数据场景分析</a>、 <a href="https://zhuanlan.zhihu.com/p/273241487">[MySQL] 如何做到不丢数据</a></p><h2 id="主从同步"><span class="mr-2">主从同步</span><a href="#主从同步" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>可参见 <a href="https://segmentfault.com/a/1190000008663001">Mysql主从同步的原理</a>、 <a href="https://blog.csdn.net/weixin_44742132/article/details/107479136?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-5&amp;spm=1001.2101.3001.4242">小白都能懂的Mysql主从复制原理（原理+实操）</a>、 <a href="https://blog.csdn.net/cpongo2ppp1/article/details/90172526?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control">深度探索MySQL主从复制原理</a>、</p><p>主从存在的疑问</p><ul><li><a href="https://blog.csdn.net/qq_40378034/article/details/91125768?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-5.control">MySQL主备、主从、读写分离详解</a></ul><h2 id="存储过程"><span class="mr-2">存储过程</span><a href="#存储过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>存储过程是⼀个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建⼀次，以 后在该程序中就可以调⽤多次。如果某次操作需要执⾏多次SQL，使⽤存储过程⽐单纯SQL 语句执⾏要快。</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">-- 创建存储过程</span>
<span class="k">CREATE</span> <span class="k">PROCEDURE</span> <span class="n">proname</span><span class="p">()</span> 
<span class="k">BEGIN</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>

<span class="c1">-- 执行存储过程</span>
<span class="k">CALL</span> <span class="n">proname</span><span class="p">();</span>

<span class="c1">-- 删除存储过程</span>
<span class="k">DROP</span> <span class="k">PROCEDURE</span> <span class="n">proname</span><span class="p">;</span>

</pre></table></code></div></div><blockquote><p>优点</p></blockquote><ul><li>1）存储过程是预编译过的，执⾏效率⾼。<li>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调⽤，减少⽹络通讯。<li>3）安全性⾼，执⾏存储过程需要有⼀定权限的⽤户。<li>4）存储过程可以重复使⽤，减少数据库开发⼈员的⼯作量。</ul><blockquote><p>缺点</p></blockquote><ul><li>1）调试麻烦，但是⽤ PL/SQL Developer 调试很⽅便！弥补这个缺点。<li>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做⼯程型项⽬，基本不存在移植问题。<li>3）重新编译问题，因为后端代码是运⾏前编译的，如果带有引⽤关系的对象发⽣改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运⾏时刻⾃动编译）</ul><p>存储过程的具体细节可参见 <a href="https://www.jianshu.com/p/7b2d74701ccd">mysql存储过程详细教程</a></p><h2 id="视图"><span class="mr-2">视图</span><a href="#视图" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>所谓视图，本质上是⼀种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含⼀系 列带有名称的列和⾏数据。但是，视图并不在数据库中以储存的数据值形式存在。⾏和列数 据来⾃定义视图的查询所引⽤基本表，并且在具体引⽤视图时动态⽣成。</p><p>为了提⾼复杂SQL语句的复⽤性和表操作的安全性， MySQL数据库管理系统提供了视图特 性。视图使开发者只关⼼感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定 义的数据，⽽不是视图所引⽤表中的数据，从⽽提⾼了数据库中数据的安全性。</p><p>视图相关的一些具体细节可参见 <a href="https://www.cnblogs.com/ljxt/p/11613167.html">MySQL视图详解</a></p><h1 id="索引">索引</h1><p>可参见 <a href="https://blog.csdn.net/o9109003234/article/details/101365956">彻底搞懂MySQL的索引</a>、 <a href="https://www.manongdao.com/article-2414489.html">彻底搞懂MySQL的索引</a>、 <a href="https://www.cnblogs.com/otis/p/12850367.html">MySQL索引到底怎么回事</a>、 <a href="https://www.zhihu.com/question/433967891">mysql 索引是怎么实现的？</a>、 <a href="https://www.hollischuang.com/archives/4110">MySQL索引完全解读</a> <a href="https://blog.51cto.com/u_15100534/2619101">彻底理解 MySQL 的索引机制，终于不再因为 MySQL 优化而被面试官鄙视了</a></p><h2 id="不走索引的情况"><span class="mr-2">不走索引的情况</span><a href="#不走索引的情况" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>可参见 <a href="https://www.css3er.com/p/237.html">mysql中的索引使用以及索引失效及索引常见面试题</a>、 <a href="https://blog.csdn.net/lmp5023/article/details/106850252?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&amp;spm=1001.2101.3001.4242">详解mysql什么时候不走索引</a>、 <a href="https://www.jianshu.com/p/3ccca0444432">总结mysql索引失效的N种情况</a>、 <a href="https://www.jb51.net/article/142970.htm">MySQL中有哪些情况下数据库索引会失效详析</a>、 <a href="https://blog.csdn.net/wlopper/article/details/103336337?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-14.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-14.control">mysql什么时候需要建索引，什么是后不要建索引？</a></p><h1 id="存储引擎">存储引擎</h1><p>MyISAM 和 InnoDB 对比可参见 <a href="https://blog.csdn.net/qq_38311489/article/details/89304434">MySQL存储引擎详解</a>， 各大存储引擎简介可参见 <a href="https://www.wenjiangs.com/article/mysql-storage-engine.html">MySQL 常用存储引擎详解和区别</a>、 <a href="https://blog.csdn.net/tyroscz/article/details/108334708">MySQL 各种存储引擎详解</a>， 各大引擎的适用场景可参见 <a href="https://blog.csdn.net/weixin_39571179/article/details/113223443">mysql的存储引擎详解_Mysql存储引擎详解</a></p><h1 style="visibility: hidden;" id="want-cmm"> 我要评论</h1></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL%20%E6%9D%82%E8%B0%88%20-%20Code-Winder&url=%2F%2Fcode-winder.github.io%2F2016%2F07%2Fmysql.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL%20%E6%9D%82%E8%B0%88%20-%20Code-Winder&u=%2F%2Fcode-winder.github.io%2F2016%2F07%2Fmysql.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2F%2Fcode-winder.github.io%2F2016%2F07%2Fmysql.html&text=MySQL%20%E6%9D%82%E8%B0%88%20-%20Code-Winder" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/it-basic/">IT_Basic</a> <a class="post-tag" href="/tags/tool/">Tool</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/it-basic/">IT-Basic</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/vim/">Vim</a></div></div></div><script> (function() { $("#content-list").click(function(event){ var e=window.event || event; if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } if($('#markdown-toc').is(':hidden')){ $('#markdown-toc').show(); }else{ $('#markdown-toc').hide(); } }); $("#markdown-toc").click(function(event){ var e=window.event || event; if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } }); $(document).click(function(event) { $("#markdown-toc").hide(); }); }()); </script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"><ul class="nav navbar-nav"><li><a href="#基本概念" class="nav-link">基本概念</a><ul class="nav navbar-nav"><li><a href="#mysql-基本框架图" class="nav-link">MySQL 基本框架图</a></ul><li><a href="#sql-语句" class="nav-link">SQL 语句</a><ul class="nav navbar-nav"><li><a href="#数据库连接" class="nav-link">数据库连接</a><li><a href="#语句执行流程" class="nav-link">语句执行流程</a><ul class="nav navbar-nav"><li><a href="#查询语句执行流程" class="nav-link">查询语句执行流程</a><ul class="nav navbar-nav"><li><a href="#查询状态" class="nav-link">查询状态</a><li><a href="#查询优化" class="nav-link">查询优化</a></ul><li><a href="#update-语句执行流程" class="nav-link">update 语句执行流程</a><li><a href="#insert-语句执行流程" class="nav-link">insert 语句执行流程</a><li><a href="#delete-语句执行流程" class="nav-link">delete 语句执行流程</a></ul><li><a href="#语句实现原理" class="nav-link">语句实现原理</a><ul class="nav navbar-nav"><li><a href="#select-工作原理" class="nav-link">select 工作原理</a><li><a href="#关联查询join" class="nav-link">关联查询（join）</a><li><a href="#order-by-工作原理" class="nav-link">order by 工作原理</a><li><a href="#group-by-工作原理" class="nav-link">group by 工作原理</a><li><a href="#where-和-having-的区别" class="nav-link">where 和 having 的区别</a></ul></ul><li><a href="#事务机制" class="nav-link">事务机制</a><ul class="nav navbar-nav"><li><a href="#衡量事务的四个特性acid" class="nav-link">衡量事务的四个特性（ACID）</a><ul class="nav navbar-nav"><li><a href="#undo-log-实现原子性" class="nav-link">undo log 实现原子性</a><li><a href="#redo-log-实现持久性" class="nav-link">redo log 实现持久性</a><li><a href="#锁和-mvcc-机制实现隔离性" class="nav-link">锁和 MVCC 机制实现隔离性</a></ul></ul><li><a href="#日志文件" class="nav-link">日志文件</a><ul class="nav navbar-nav"><li><a href="#日志落盘策略" class="nav-link">日志落盘策略</a><li><a href="#数据丢失的场景" class="nav-link">数据丢失的场景</a><li><a href="#主从同步" class="nav-link">主从同步</a><li><a href="#存储过程" class="nav-link">存储过程</a><li><a href="#视图" class="nav-link">视图</a></ul><li><a href="#索引" class="nav-link">索引</a><ul class="nav navbar-nav"><li><a href="#不走索引的情况" class="nav-link">不走索引的情况</a></ul><li><a href="#存储引擎" class="nav-link">存储引擎</a><li><a href="#want-cmm" class="nav-link"> 我要评论 </a></ul></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/2023/03/etcd.html"><div class="card-body"> <em class="small" data-ts="1677711925" data-df="YYYY/MM/DD" > 2023/03/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>etcd 杂谈</h3><div class="text-muted small"><p> 本文主要对 ETCD 的相关资料进行收集，以备查阅和整理。 架构简介 etcd 应用 典型应用场景 常用工具和命令 etcd 实现原理 通讯协议 etcd 集群 etcd 故障及调优 etcd 综合 etcd 源码和常见面试题 架构简介 etcd 架构原理学习（来自etcd实战） et...</p></div></div></a></div><div class="card"> <a href="/2016/07/kafka.html"><div class="card-body"> <em class="small" data-ts="1467765411" data-df="YYYY/MM/DD" > 2016/07/06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>kafka 杂谈</h3><div class="text-muted small"><p> 本文主要介绍 kafka 相关的一些理论知识、实践经验和验证实验。 架构简介 kafka 应用 典型应用场景 常用工具和命令 kafka 实现原理 通讯协议 kafka 集群 kafka 故障及调优 kafka 综合 kafka 常见面试题 架构简介 Kafka系列3-Kafka架构 ...</p></div></div></a></div><div class="card"> <a href="/2016/07/redis.html"><div class="card-body"> <em class="small" data-ts="1467775611" data-df="YYYY/MM/DD" > 2016/07/06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>redis 杂谈</h3><div class="text-muted small"><p> 本文主要介绍 Redis 相关的一些理论知识、实践经验和验证实验。 它的全称是 REmote Dictionary Service, 直接翻译过来是远程字典服务。 redis 架构 应用架构演化 Redis 自身架构演化 redis 模块 线程模型 单线程模型 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"><div class="btn btn-outline-primary disabled" prompt="上一篇"><p>-</p></div><a href="/2016/07/kafka.html" class="btn btn-outline-primary" prompt="下一篇"><p>kafka 杂谈</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/it-basic/">IT_Basic</a> <a class="post-tag" href="/tags/tool/">Tool</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/it-basic/">IT-Basic</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/vim/">Vim</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/code-winder">code-winder</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div style="text-align:center;width: 90%;"><p class="mb-0"> 总访问量 <span id="busuanzi_value_site_pv" style="color: blue;"></span> ，访客数 <span id="busuanzi_value_site_uv" style="color: blue;"></span> ，本文总阅读量 <span id="busuanzi_value_page_pv" style="color: blue;"> </span></p></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1.11.6/dayjs.min.js,npm/dayjs@1.11.6/locale/zh.min.js,npm/dayjs@1.11.6/plugin/relativeTime.min.js,npm/dayjs@1.11.6/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-72449510-4"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-72449510-4'); }); </script>
