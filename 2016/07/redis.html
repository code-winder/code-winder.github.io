<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="redis 杂谈" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文主要介绍 Redis 相关的一些理论知识、实践经验和验证实验。 它的全称是 REmote Dictionary Service, 直接翻译过来是远程字典服务。" /><meta property="og:description" content="本文主要介绍 Redis 相关的一些理论知识、实践经验和验证实验。 它的全称是 REmote Dictionary Service, 直接翻译过来是远程字典服务。" /><link rel="canonical" href="//code-winder.github.io/2016/07/redis.html" /><meta property="og:url" content="//code-winder.github.io/2016/07/redis.html" /><meta property="og:site_name" content="Code-Winder" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-07-06T11:26:51+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="redis 杂谈" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-07-06T11:26:51+08:00","datePublished":"2016-07-06T11:26:51+08:00","description":"本文主要介绍 Redis 相关的一些理论知识、实践经验和验证实验。 它的全称是 REmote Dictionary Service, 直接翻译过来是远程字典服务。","headline":"redis 杂谈","mainEntityOfPage":{"@type":"WebPage","@id":"//code-winder.github.io/2016/07/redis.html"},"url":"//code-winder.github.io/2016/07/redis.html"}</script><title>redis 杂谈 | Code-Winder</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Code-Winder"><meta name="application-name" content="Code-Winder"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script> <script> // 百度统计代码 var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e37ebacf05386ebe11672ab0dc609b69"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script> // google analytics (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '{site.google_analytics_id}}', 'auto'); ga('send', 'pageview'); </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/favicons/favicon.ico" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Code-Winder</a></div><div class="site-subtitle font-italic">灵感源于好奇</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/code-winder" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['414834682','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <i class="fas fa-list-alt fa-fw" id="content-list"></i> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>redis 杂谈</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >X</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 class="title_class" data-toc-skip>redis 杂谈</h1><div id="label_center"><div class="label"><div class="label-card"></div><div class="label-card"> <span class="categories"> <i class="fa fa-th-list"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88" title="Category: 计算机综合" rel="category">计算机综合</a> </span></div><div class="label-card"> <span class="pageTag"> <i class="fa fa-tags"></i> <a href="/tags/it-basic" title="Tag: IT_Basic" rel="tag">IT_Basic</a> </span></div></div></div><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1467775611" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2016/07/06 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/code-winder">code-winder</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="41346 字"> <em>229 分钟</em>阅读</span></div></div></div><div class="post-content"><blockquote><p>本文主要介绍 Redis 相关的一些理论知识、实践经验和验证实验。 它的全称是 REmote Dictionary Service, 直接翻译过来是远程字典服务。</p></blockquote><ul id="markdown-toc"><li><a href="#redis-架构" id="markdown-toc-redis-架构">redis 架构</a><ul><li><a href="#应用架构演化" id="markdown-toc-应用架构演化">应用架构演化</a><li><a href="#redis-自身架构演化" id="markdown-toc-redis-自身架构演化">Redis 自身架构演化</a></ul><li><a href="#redis-模块" id="markdown-toc-redis-模块">redis 模块</a><ul><li><a href="#线程模型" id="markdown-toc-线程模型">线程模型</a><ul><li><a href="#单线程模型" id="markdown-toc-单线程模型">单线程模型</a><li><a href="#多线程模型" id="markdown-toc-多线程模型">多线程模型</a></ul></ul><li><a href="#redis-应用" id="markdown-toc-redis-应用">redis 应用</a><ul><li><a href="#典型应用场景" id="markdown-toc-典型应用场景">典型应用场景</a><li><a href="#数据类型及相关命令" id="markdown-toc-数据类型及相关命令">数据类型及相关命令</a></ul><li><a href="#redis-实现原理" id="markdown-toc-redis-实现原理">redis 实现原理</a><ul><li><a href="#底层数据结构" id="markdown-toc-底层数据结构">底层数据结构</a><ul><li><a href="#底层数据结构概述" id="markdown-toc-底层数据结构概述">底层数据结构概述</a><li><a href="#sds简单动态字符串存储结构" id="markdown-toc-sds简单动态字符串存储结构">SDS(简单动态字符串存储结构)</a><li><a href="#链表" id="markdown-toc-链表">链表</a><li><a href="#压缩列表" id="markdown-toc-压缩列表">压缩列表</a><li><a href="#哈希表" id="markdown-toc-哈希表">哈希表</a><ul><li><a href="#哈希表结构设计" id="markdown-toc-哈希表结构设计">哈希表结构设计</a><li><a href="#哈希冲突" id="markdown-toc-哈希冲突">哈希冲突</a></ul><li><a href="#整数集合" id="markdown-toc-整数集合">整数集合</a><ul><li><a href="#整数集合结构设计" id="markdown-toc-整数集合结构设计">整数集合结构设计</a><li><a href="#整数集合的升级操作" id="markdown-toc-整数集合的升级操作">整数集合的升级操作</a></ul><li><a href="#跳表" id="markdown-toc-跳表">跳表</a><ul><li><a href="#跳表结构设计" id="markdown-toc-跳表结构设计">跳表结构设计</a><li><a href="#跳表节点查询过程" id="markdown-toc-跳表节点查询过程">跳表节点查询过程</a><li><a href="#跳表节点层数设置" id="markdown-toc-跳表节点层数设置">跳表节点层数设置</a></ul><li><a href="#quicklist" id="markdown-toc-quicklist">quicklist</a><li><a href="#listpack" id="markdown-toc-listpack">listpack</a><li><a href="#rax前缀树" id="markdown-toc-rax前缀树">rax(前缀树)</a><li><a href="#stream" id="markdown-toc-stream">stream</a><ul><li><a href="#添加消息" id="markdown-toc-添加消息">添加消息</a><li><a href="#删除消息" id="markdown-toc-删除消息">删除消息</a><li><a href="#参考文档" id="markdown-toc-参考文档">参考文档</a></ul></ul><li><a href="#redis-源码导读" id="markdown-toc-redis-源码导读">redis 源码导读</a></ul><li><a href="#redis-通信协议" id="markdown-toc-redis-通信协议">redis 通信协议</a><ul><li><a href="#resp2" id="markdown-toc-resp2">RESP2</a><ul><li><a href="#简单字符串" id="markdown-toc-简单字符串">简单字符串</a><li><a href="#错误" id="markdown-toc-错误">错误</a><li><a href="#整型" id="markdown-toc-整型">整型</a><li><a href="#批量字符串" id="markdown-toc-批量字符串">批量字符串</a><li><a href="#数组" id="markdown-toc-数组">数组</a><li><a href="#数组中的空元素" id="markdown-toc-数组中的空元素">数组中的空元素</a><li><a href="#多命令和管道" id="markdown-toc-多命令和管道">多命令和管道</a><li><a href="#内联命令" id="markdown-toc-内联命令">内联命令</a><li><a href="#高性能-redis-协议解析器" id="markdown-toc-高性能-redis-协议解析器">高性能 Redis 协议解析器</a><li><a href="#参考文档-1" id="markdown-toc-参考文档-1">参考文档</a></ul><li><a href="#resp3" id="markdown-toc-resp3">RESP3</a><ul><li><a href="#与resp2兼容" id="markdown-toc-与resp2兼容">与RESP2兼容</a><ul><li><a href="#请求格式" id="markdown-toc-请求格式">请求格式</a><li><a href="#simple-string" id="markdown-toc-simple-string">Simple string</a><li><a href="#simple-error" id="markdown-toc-simple-error">Simple error</a><li><a href="#number" id="markdown-toc-number">Number</a><li><a href="#blob-string" id="markdown-toc-blob-string">Blob string</a><li><a href="#array" id="markdown-toc-array">Array</a></ul><li><a href="#resp3中新的类型" id="markdown-toc-resp3中新的类型">RESP3中新的类型</a><ul><li><a href="#null" id="markdown-toc-null">Null</a><li><a href="#double" id="markdown-toc-double">Double</a><li><a href="#boolean" id="markdown-toc-boolean">Boolean</a><li><a href="#blob-error" id="markdown-toc-blob-error">Blob error</a><li><a href="#verbatim-string" id="markdown-toc-verbatim-string">Verbatim string</a><li><a href="#big-number" id="markdown-toc-big-number">Big number</a><li><a href="#aggregate-data-types" id="markdown-toc-aggregate-data-types">Aggregate data types</a><li><a href="#map" id="markdown-toc-map">Map</a><li><a href="#set" id="markdown-toc-set">Set</a><li><a href="#attribute" id="markdown-toc-attribute">Attribute</a><li><a href="#push" id="markdown-toc-push">Push</a><li><a href="#stream-1" id="markdown-toc-stream-1">Stream</a><li><a href="#hello" id="markdown-toc-hello">HELLO</a><li><a href="#参考文档-2" id="markdown-toc-参考文档-2">参考文档</a></ul></ul><li><a href="#gossip" id="markdown-toc-gossip">gossip</a></ul><li><a href="#redis-集群" id="markdown-toc-redis-集群">redis 集群</a><ul><li><a href="#集群部署方案" id="markdown-toc-集群部署方案">集群部署方案</a><ul><li><a href="#主从复制模式" id="markdown-toc-主从复制模式">主从复制模式</a><li><a href="#sentinel哨兵模式" id="markdown-toc-sentinel哨兵模式">Sentinel（哨兵）模式</a><li><a href="#cluster模式" id="markdown-toc-cluster模式">Cluster模式</a><ul><li><a href="#redis集群的数据分布算法哈希槽算法" id="markdown-toc-redis集群的数据分布算法哈希槽算法">Redis集群的数据分布算法：哈希槽算法</a><li><a href="#集群的请求重定向" id="markdown-toc-集群的请求重定向">集群的请求重定向</a><li><a href="#集群扩容和缩容" id="markdown-toc-集群扩容和缩容">集群扩容和缩容</a><li><a href="#集群的故障检测与故障转恢复机制" id="markdown-toc-集群的故障检测与故障转恢复机制">集群的故障检测与故障转恢复机制</a><ul><li><a href="#集群故障检测" id="markdown-toc-集群故障检测">集群故障检测</a><li><a href="#集群的故障恢复" id="markdown-toc-集群的故障恢复">集群的故障恢复</a></ul><li><a href="#集群的运维" id="markdown-toc-集群的运维">集群的运维</a><ul><li><a href="#数据迁移问题" id="markdown-toc-数据迁移问题">数据迁移问题</a><li><a href="#带宽消耗问题" id="markdown-toc-带宽消耗问题">带宽消耗问题</a><li><a href="#pubsub广播问题" id="markdown-toc-pubsub广播问题">Pub/Sub广播问题</a><li><a href="#集群倾斜" id="markdown-toc-集群倾斜">集群倾斜</a><li><a href="#集群读写分离" id="markdown-toc-集群读写分离">集群读写分离</a></ul></ul><li><a href="#参考文档-3" id="markdown-toc-参考文档-3">参考文档</a></ul></ul><li><a href="#redis-故障及调优" id="markdown-toc-redis-故障及调优">redis 故障及调优</a><li><a href="#redis-综合" id="markdown-toc-redis-综合">redis 综合</a></ul><h1 id="redis-架构">redis 架构</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构， 如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><p>Redis 是一种KV存储的非关系数据库，类似的数据库组件可参考此网站<a href="https://hostingdata.co.uk/nosql-database/">nosql-database</a>。 能不能把SQL和NoSQL的特性结合在一起呢？当然可以。所以现在又有了所谓的NewSQL数据库。 NewSQL是指这样一类新式的关系型数据库管理系统，针对OLTP（读-写）工作负载，追求提供和NoSQL系统相同的扩展性能，且仍然保持ACID和SQL等特性（scalable and ACID and (relational and/or sql -access)）。 NewSQL 结合了 SQL和 NoSQL 的特性。例如 TiDB (PingCAP)、VoltDB、ScaleDB等。</p><p>redis 架构从单机版不断演化成如今的分片集群版。</p><h2 id="应用架构演化"><span class="mr-2">应用架构演化</span><a href="#应用架构演化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>单机版：作为热数据的内存KV数据库，分担Mysql非内存式的持久化数据库的压力<br /> <a href="/assets/img/it_basic/redis/redis-004.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-004.jpeg" alt="单机版" class="lazyload" data-proofer-ignore></a><li>Redis 持久化($DB/AOF)：减少数据丢失<br /> <a href="/assets/img/it_basic/redis/redis-005.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-005.png" alt="数据持久化" class="lazyload" data-proofer-ignore></a><li>主从复制：多副本<ul><li>缩短不可用时间：master 宕机，手动把slave提升为master<li>分摊读压力，提升读性能：让 slave 分担一部分读请求，提升应用整体性能<br /> <a href="/assets/img/it_basic/redis/redis-006.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-006.jpeg" alt="主从复制" class="lazyload" data-proofer-ignore></a></ul><li>单哨兵：单哨兵可能因网络问题，对master存活造成误判<br /> <a href="/assets/img/it_basic/redis/redis-008.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-008.jpeg" alt="单哨兵" class="lazyload" data-proofer-ignore></a><li>哨兵集群：故障节点自动切换，加快切换时间（相对于故障手动切换而言）<br /> <a href="/assets/img/it_basic/redis/redis-007.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-007.jpeg" alt="哨兵集群" class="lazyload" data-proofer-ignore></a><li>分片集群：分摊写压力，提升集群整体性能<ul><li>proxy方案(非官方)：多个主从集群分担根据路由规则写压力，一个哨兵集群监测状态。其中路由规则可以在客户端实现（客户端分片）， 也可以在服务端实现。对于在服务端实现路由的方案，即为这里所说的proxy方案<li>gossip协议方案(官方)：Redis 节点之间通过 Gossip 协议通信，无需部署哨兵集群，可横向扩容<li>proxy加官方集群方案：由各公司自研的proxy，来屏蔽业务迁移至官方集群的复杂性，降低升级成本<br /> <a href="/assets/img/it_basic/redis/redis-009.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-009.jpeg" alt="proxy" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-010.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-010.jpeg" alt="官方集群" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-011.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-011.jpeg" alt="综合方案" class="lazyload" data-proofer-ignore></a></ul></ul><p>更复杂和详细的应用演化之旅可以参考以下文章：</p><ul><li><a href="https://blog.csdn.net/u013411339/article/details/102827689">阿里云Redis技术架构演进</a><li><a href="https://blog.csdn.net/wwd0501/article/details/131927307">一文搞懂Redis架构演化之路</a></ul><h2 id="redis-自身架构演化"><span class="mr-2">Redis 自身架构演化</span><a href="#redis-自身架构演化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redis 自身架构演化大体和其应用架构演化类似。</p><ul><li>单机版：Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。<br /> <a href="/assets/img/it_basic/redis/redis-003.webp" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-003.webp" alt="单机版" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-012.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-012.png" alt="单机版组件图" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-013.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-013.png" alt="单机版组件图" class="lazyload" data-proofer-ignore></a><li>集群架构<br /> <a href="/assets/img/it_basic/redis/redis-014.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-014.png" alt="集群架构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-015.webp" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-015.webp" alt="集群架构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-018.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-018.png" alt="集群架构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-016.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-016.png" alt="集群架构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-017.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-017.png" alt="集群架构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-019.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-019.png" alt="集群架构" class="lazyload" data-proofer-ignore></a></ul><h1 id="redis-模块">redis 模块</h1><p><a href="/assets/img/it_basic/redis/redis-026.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-026.png" alt="模块" class="lazyload" data-proofer-ignore></a></p><h2 id="线程模型"><span class="mr-2">线程模型</span><a href="#线程模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redis 6.0 之前为什么使用单线程。 虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型， 但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求， 这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。</p><p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis 有多线程同时执行命令。 Redis 官方表示，Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上。</p><p>Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对发送响应数据，并不会以多线程的方式处理读请求。 要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>//读请求也使用io多线程
io-threads-do-reads <span class="nb">yes</span> 
// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）
io-threads 4
</pre></table></code></div></div><p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。 因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会创建 6 个线程：</p><ul><li>Redis-server ： Redis的主线程，主要负责执行命令；<li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；<li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</ul><h3 id="单线程模型"><span class="mr-2">单线程模型</span><a href="#单线程模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis 6.0 版本之前的单线模式如下图：<br /> <a href="/assets/img/it_basic/redis/redis-020.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-020.png" alt="单线程模型" class="lazyload" data-proofer-ignore></a></p><p>Redis 初始化的时候，会做下面这几件事情：</p><ul><li>调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务器套接字 socket；<li>调用 bind() 绑定端口和调用 listen() 设置监听该套接字；<li>将调用 epoll_ctl() 将该监听套接字listen socket 加入到 epoll红黑树柄，同时注册「连接请求」处理函数。</ul><p>初始化完后，主线程就进入到一个事件循环函数，主要会做以下事情：<br /> <a href="/assets/img/it_basic/redis/redis-021.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-021.png" alt="单线程模型" class="lazyload" data-proofer-ignore></a></p><ul><li>先调用处理发送队列函数，每一次进入 epoll_wait 前都调用 beforesleep看是发送队列里是否有任务， 如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写事件触发后再处理 。<li>接着，调用 epoll_wait 函数等待事件的到来：<ul><li>如果是连接事件到来，则会调用连接事件处理函数，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；<br /> <a href="/assets/img/it_basic/redis/redis-022.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-022.png" alt="单线程模型" class="lazyload" data-proofer-ignore></a><li>如果是读事件到来，则会调用读事件处理函数，该函数会做这些事情：调用 read 获的取客户端发送数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存送区等待发；<br /> <a href="/assets/img/it_basic/redis/redis-023.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-023.png" alt="单线程模型" class="lazyload" data-proofer-ignore></a><li>如果是写事件到来，则会调用写事件处理函数，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。<br /> <a href="/assets/img/it_basic/redis/redis-024.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-024.png" alt="单线程模型" class="lazyload" data-proofer-ignore></a></ul></ul><p>在 aeMain 函数中，每次在进入 aeProcessEvents 前都需要先进行 beforesleep 处理。该函数处理了许多工作，其中一项便是：</p><ul><li>遍历发送任务队列，并将 client 发送缓存区中的处理结果通过 write 发送到客户端手中；<li>值得注意的是，发送 write 并不总是能一次性发送完的。假如要发送的结果太大，而系统为每个 socket 设置的发送缓存区又是有限的；<li>在这种情况下， 判断仍然有未发送完的数据的话，就需要注册一个写事件处理函数到 epoll 上。等待 epoll 发现该 socket 可写的时候再次调用 sendReplyToClient进行发送。</ul><p>其他详细解读请参考以下文章：</p><ul><li><a href="https://blog.csdn.net/weixin_44479862/article/details/126512100">Redis源码剖析——线程模型</a><li><a href="https://www.jianshu.com/p/034ef320be2d">从架构图及源码分析redis单体服务架构</a></ul><p>之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：</p><ul><li>内存操作<li>高效数据结构<li>I/O多路复用<li>协议简单<li>无多线程切换和资源争用开销<li>处理流程简单高效</ul><h3 id="多线程模型"><span class="mr-2">多线程模型</span><a href="#多线程模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis6.0版本的多线程处理模型：<br /> <a href="/assets/img/it_basic/redis/redis-025.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-025.png" alt="多线程模型" class="lazyload" data-proofer-ignore></a></p><p>主线程工作流程如下：</p><ul><li>主线程负责接收建立连接请求，将epoll_wait等待的读事件加入全局待处理列表中；<li>将等待列表中的读事件平均分给IO线程；<li>主线程处理其中一部分读事件；<li>阻塞等待IO线程将分配到的读事件进行命令解析；<li>当所有IO线程将分配到的读事件都命令解析完毕，主线程负责执行命令，并将回复信息写入客户端对应的回复缓冲区。<li>将等待等待列表中写事件平均分给IO线程；<li>主线程处理其中一部分写事件；</ul><p>从上面的实现机制可以看出，Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。 所以我们不需要去考虑控制 key、lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。</p><blockquote><p>Redis多线程模型缺陷</p></blockquote><p>随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的程单线模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，于是诞生了Redis6.0多线程模型。</p><p>但是 Redis 多线程网络模型实际上并不是一个标准的 Multi-Reactors/Master-Workers模型。Redis 的多线程方案中， I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令。所有客户端命令最后还需要回到主线程去执行， 因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。</p><p>在我看来，Redis 目前的多线程方案更像是一个折中的选择：既保持了原系统的兼容性，又能利用多核提升 I/O 性能</p><h1 id="redis-应用">redis 应用</h1><p>有时候应用一个组件不需要事先知道其原理，只有在深度使用时遇到比较棘手的场景或问题时才会去深度了解。 基于这个观点，我们首先从应用的角度来了解redis。</p><h2 id="典型应用场景"><span class="mr-2">典型应用场景</span><a href="#典型应用场景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://blog.csdn.net/qq_45988641/article/details/119914549?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-119914549-blog-125927452.pc_relevant_3mothn_strategy_recovery&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">Redis 16种常见应用场景</a><li><a href="https://blog.csdn.net/qq_38279833/article/details/115444924?spm=1001.2101.3001.6650.13&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-13-115444924-blog-119914549.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-13-115444924-blog-119914549.pc_relevant_default&amp;utm_relevant_index=21">Redis在项目中的地位及使用场景剖析</a><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&amp;mid=2247495365&amp;idx=1&amp;sn=6b7d36d4c8caf19d03613bbab0b3d922&amp;chksm=97293fbfa05eb6a9925f1850308f4353887aa600cefd719023ca60b73e190f50171725e779f7&amp;scene=27">关于redis的应用场景</a><li><a href="https://zhuanlan.zhihu.com/p/528146852">细说 Redis 九种数据类型和应用场景</a><li><a href="https://zhuanlan.zhihu.com/p/536953657">Redis的应用场景</a></ul><h2 id="数据类型及相关命令"><span class="mr-2">数据类型及相关命令</span><a href="#数据类型及相关命令" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>数据类型有哪些可以参考<a href="https://redis.io/docs/data-types/">官方文档</a>、 <a href="https://www.redis.net.cn/tutorial/3501.html">中文文档</a></p><ul><li><a href="https://blog.csdn.net/zhaozhenzuo/article/details/118324457">redis架构</a><li><a href="https://www.runoob.com/redis/redis-commands.html">Redis命令</a> 或者 <a href="https://www.w3cschool.cn/redis/redis-commands.html">Redis命令</a><li>在学习命令或者验证所学的时候，图简便可以参考<a href="https://try.redis.io/">在线Redis</a><li><a href="https://blog.51cto.com/u_11239407/2930728">一文读懂Redis数据类型</a></ul><h1 id="redis-实现原理">redis 实现原理</h1><p>了解了基本的应用之后，会遇到对性能和匹配度要求更高的场景，甚至为了自身特殊需要来改造redis，这就需要了解redis的底层原理及其相关理论。</p><ul><li><a href="https://blog.csdn.net/m0_55161603/article/details/122475158">Redis单机版全面讲解</a><li><a href="https://blog.csdn.net/qq1309664161/article/details/125253037">浅谈redis(一)——单机版redis特性记录</a></ul><h2 id="底层数据结构"><span class="mr-2">底层数据结构</span><a href="#底层数据结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redis 目前共有 9 种数据结构：SDS、双向链表、压缩列表(新版本已废弃)、哈希表、跳表、整数集合、quicklist、listpack。<br /> <a href="/assets/img/it_basic/redis/redis-027.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-027.png" alt="数据结构" class="lazyload" data-proofer-ignore></a></p><p>底层数据结构是 redis 高性能的一个重要支撑。我们也可以借鉴这些结构，用到其他项目中，或者在它的基础上进行改良。 本章节参考了：</p><ul><li><a href="https://blog.csdn.net/zhaohuodian/article/details/126585141">为了拿捏 Redis 数据结构，我画了 40 张图（完整版）</a><li><a href="http://redisbook.com/index.html">Redis设计与实现</a> 第一部分的<em>数据结构与对象</em><li>《Redis 源码剖析与实战》</ul><h3 id="底层数据结构概述"><span class="mr-2">底层数据结构概述</span><a href="#底层数据结构概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis 是一种k-v数据库，那这种键值对是怎么实现的呢？</p><p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。 哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据， 然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身， 而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。<br /> <a href="/assets/img/it_basic/redis/redis-028.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-028.png" alt="数据结构" class="lazyload" data-proofer-ignore></a></p><p>上图中涉及到的数据结构的名字和用途：</p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， key 指向的是 String 对象， 而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</ul><p>特别说明下，void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示，如下图：<br /></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// redis 6.0.6</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 4位=0.5字节</span>
    <span class="kt">unsigned</span> <span class="n">encoding</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 4位=0.5字节</span>
    <span class="kt">unsigned</span> <span class="n">lru</span><span class="o">:</span><span class="n">LRU_BITS</span><span class="p">;</span> <span class="c1">// 24位=3字节, 对象最后一次访问时间（秒）</span>
    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span> <span class="c1">// 32位=4字节，引用计数。0：可被垃圾回收</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">// 64位=8字节</span>
<span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</pre></table></code></div></div><p><a href="/assets/img/it_basic/redis/redis-029.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-029.png" alt="数据结构" class="lazyload" data-proofer-ignore></a></p><p>对象结构里包含的成员变量：</p><ul><li>type： 显式类型，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；<li>encoding：隐式类型，标识该对象使用了哪种底层的数据结构；<li>ptr：指向底层数据结构的指针。</ul><p>每种显式类型，会根据不同的阈值在不同的隐式类型中切换。</p><div class="table-wrapper"><table><thead><tr><th>序号<th>类型<th>描述<tbody><tr><td>1<td>int<td>整数<tr><td>2<td>embstr<td>embstr编码的简单动态字符串（SDS）<tr><td>3<td>raw<td>简单动态字符串<tr><td>4<td>ht<td>字典<tr><td>5<td>linkedlist<td>双端链表<tr><td>5<td>ziplist<td>压缩列表<tr><td>5<td>intset<td>整数集合<tr><td>5<td>skiplist<td>跳跃链表和字典</table></div><p>type和encoding之间的对应关系大致如下(可能存在版本差异)，数据使用不同类型存储是有限制条件的， 不同条件下，使用不同的存储格式。</p><div class="table-wrapper"><table><thead><tr><th>type<th>encoding<tbody><tr><td>string<td>（1）int：值为整型，取值[-2^63-1, 2^63-1]<tr><td> <td>（2）embstr：值不为整型或者整型值不在上述int范围内，且值长度小于等于44个字节<tr><td> <td>（3）raw：值超过44个字节(64-16-3-1=44)<tr><td>list<td>quicklist(3.2版本前对应ziplist<tr><td> <td>linkedlist)3.2版本后，list使用quicklist(ziplist和linkedlist组合)<tr><td>hash<td>（1）ziplist：值个数在hash-max-ziplist-entries范围内或者值长度在hash-max-ziplist-value范围内<tr><td> <td>（2）hashtable：超过上述范围<tr><td>set<td>（1）intset：值为整型，取值[-2^63-1, 2^63-1]<tr><td> <td>（2）hashtable：其他情况<tr><td>zset<td>（1）ziplist：值个数在zset-max-ziplist-entries范围内或者值长度在zset-max-ziplist-value范围内<tr><td> <td>（2）skiplist：超过上述情况</table></div><p>我画了一张 Redis 键值对数据库的全景图，你就能清晰知道 Redis 对象和数据结构的关系了： <a href="/assets/img/it_basic/redis/redis-033.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-033.png" alt="数据结构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-031.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-031.png" alt="数据结构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-030.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-030.png" alt="数据结构" class="lazyload" data-proofer-ignore></a></p><p>redis会采用dict来保存全局hash，会有2个dict，dict0和dict1，其中dict1用于扩容用。 redis有扩容和缩容，缩容流程与扩容基本一致。除了什么时候扩会有差异：扩容是负载因子&gt;=1或负载因子&gt;=5；缩容是负载因子小于等于0.1。 扩容时，采用的是渐进式hash。这种思路可以借鉴。</p><ul><li>对于增删改查都会将一个元素从dict0放到dict1<ul><li>对于没有变动的使用定时任务迁移<li>对于增加只会往dict1放</ul><li>迁移完成后将dict0置为dict1，同时清空dict1<br /> <a href="/assets/img/it_basic/redis/redis-032.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-032.jpeg" alt="数据结构" class="lazyload" data-proofer-ignore></a></ul><p>整体redis的渐近式hash细节步骤可以用到数据库扩容上</p><h3 id="sds简单动态字符串存储结构"><span class="mr-2">SDS(简单动态字符串存储结构)</span><a href="#sds简单动态字符串存储结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。</p><p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串， 而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p><p>既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。 要了解这一点，得先来看看 char* 字符数组的结构。</p><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。 在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而字符数组的结尾位置就用“\0”表示，意思是指字符串的结束。 这种字符数组结构有以下不便：</p><ul><li>求字符串长度需要遍历计数<li>不能存放二进制数据(比如音视频数据、压缩编码数据)或者含有”\0”的数据，否则会被截断，无法读取真实完整的字符串<li>修改字符串时带来的内存重分配次数较多<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</ul><p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。 下图就是 Redis 5.0 的 SDS 的数据结构：<br /> <a href="/assets/img/it_basic/redis/redis-034.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-034.png" alt="SDS" class="lazyload" data-proofer-ignore></a></p><p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。 当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容），以满足修改所需的大小。</p><p>在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。 这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，有效的减少内存分配次数。 所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。</p><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。 Redos 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。 这 5 种类型的主要区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同。</p><p>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间。比如，在保存小字符串时，结构头占用空间也比较少。 除了设计不同类型的结构体，Redis 在编程上还使用了专门的编译优化来节省内存空间， 即在 struct 声明了 __attribute__ ((packed)) ，它的作用是：告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐。 比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 16 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。</p><h3 id="链表"><span class="mr-2">链表</span><a href="#链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。 实际上就是双链表。</p><p>Redis 在双链表的基础上封装了 List 结构(把操作和数据绑定，类似面向对象)。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
    <span class="c1">//链表头节点</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="c1">//链表尾节点</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="c1">//节点值复制函数</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="c1">//节点值释放函数</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="c1">//节点值比较函数</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="c1">//链表节点数量</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</pre></table></code></div></div><p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。<br /> <a href="/assets/img/it_basic/redis/redis-035.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-035.png" alt="SDS" class="lazyload" data-proofer-ignore></a></p><p>Redis 的链表实现优点如下：</p><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表；<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以获取链表的表头节点和表尾节点的时间复杂度只需O(1)；<li>list 结构因为提供了链表节点数量 len，所以获取链表中的节点数量的时间复杂度只需O(1)；<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此链表节点可以保存各种不同类型的值；</ul><p>链表的缺陷也是有的：</p><ul><li>链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销较大。</ul><p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。 不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p><p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p><h3 id="压缩列表"><span class="mr-2">压缩列表</span><a href="#压缩列表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p>但是，压缩列表的缺陷也是有的：</p><p>不能保存过多的元素，否则查询效率就会降低； 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。 因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><p>压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。<br /> <a href="/assets/img/it_basic/redis/redis-036.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-036.png" alt="压缩列表" class="lazyload" data-proofer-ignore></a></p><ul><li>zlbytes，记录整个压缩列表占用对内存字节数；<li>zltail，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；<li>zllen，记录压缩列表包含的节点数量；<li>zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。</ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。 而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素。 压缩列表节点（entry）的构成如下：<br /> <a href="/assets/img/it_basic/redis/redis-037.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-037.png" alt="压缩列表" class="lazyload" data-proofer-ignore></a></p><ul><li>prevlen，记录了「前一个节点」的长度；<li>encoding，记录了当前节点实际数据的类型以及长度；<li>data，记录了当前节点的实际数据；</ul><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小， 会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息， 这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的。</p><p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。 压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值；<li>如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值；</ul><p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：</p><ul><li>如果当前节点的数据是整数，则 encoding 会使用 1 字节的空间进行编码。<li>如果当前节点的数据是字符串，根据字符串的长度大小，encoding 会使用 1 字节/2字节/5字节的空间进行编码。</ul><p>压缩列表除了查找复杂度较高之外，还有一个连续更新的问题。 压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。 而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。 前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配</p><ul><li>如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值；<li>如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值；</ul><p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：<br /> <a href="/assets/img/it_basic/redis/redis-038.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-038.png" alt="压缩列表" class="lazyload" data-proofer-ignore></a></p><p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。 这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图<br /> <a href="/assets/img/it_basic/redis/redis-039.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-039.png" alt="压缩列表" class="lazyload" data-proofer-ignore></a></p><p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。 多米诺牌的效应就此开始。<br /> <a href="/assets/img/it_basic/redis/redis-040.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-040.png" alt="压缩列表" class="lazyload" data-proofer-ignore></a></p><p>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。 正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展… 一直持续到结尾。 这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下……</p><p>空间扩展操作也就是重新分配内存，因此连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能。 所以说，虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题。 因此，压缩列表只会用于保存的节点数量不多的场景，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。 这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p><h3 id="哈希表"><span class="mr-2">哈希表</span><a href="#哈希表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>哈希表是一种保存键值对（key-value）的数据结构。 哈希表中的每一个 key 都是独一无二的，程序可以根据 key 查找到与之关联的 value，或者通过 key 来更新 value，又或者根据 key 来删除整个 key-value等等。</p><p>在讲压缩列表的时候，提到过 Redis 的 Hash 对象的底层实现之一是压缩列表（最新 Redis 代码已将压缩列表替换成 listpack）。Hash 对象的另外一个底层实现就是哈希表。 哈希表优点在于，它能以 O(1) 的复杂度快速查询数据。怎么做到的呢？将 key 通过 Hash 函数的计算，就能定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。 但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么哈希冲突的可能性也会越高。 解决哈希冲突的方式，有很多种。</p><p>Redis 采用了「链式哈希」来解决哈希冲突，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p><h4 id="哈希表结构设计"><span class="mr-2">哈希表结构设计</span><a href="#哈希表结构设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis 的哈希表结构如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="c1">//哈希表数组</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>
    <span class="c1">//哈希表大小</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>  
    <span class="c1">//哈希表大小掩码，用于计算索引值</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
    <span class="c1">//该哈希表已有的节点数量</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>
</pre></table></code></div></div><p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。<br /> <a href="/assets/img/it_basic/redis/redis-041.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-041.png" alt="哈希表" class="lazyload" data-proofer-ignore></a></p><p>哈希表节点的结构如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
    <span class="c1">//键值对中的键</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
 
    <span class="c1">//键值对中的值</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
    <span class="c1">//指向下一个哈希表节点，形成链表</span>
    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>
</pre></table></code></div></div><p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希。</p><p>另外，这里还跟你提一下，dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针， 或者是一个无符号的 64 位整数或有符号的 64 位整数或double 类的值。这么做的好处是可以节省内存空间， 因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</p><h4 id="哈希冲突"><span class="mr-2">哈希冲突</span><a href="#哈希冲突" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>哈希表实际上是一个数组，数组里多每一个元素就是一个哈希桶。 当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。</p><p>什么是哈希冲突呢？ 举个例子，有一个可以存放 8 个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值 % 8 」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶 1 和桶 6。<br /> <a href="/assets/img/it_basic/redis/redis-042.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-042.png" alt="哈希冲突" class="lazyload" data-proofer-ignore></a></p><p>此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。 因此，当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突。</p><p>Redis 采用了「链式哈希」的方法来解决哈希冲突。 链式哈希是怎么实现的？</p><p>实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表， 被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来，这样就解决了哈希冲突。</p><p>还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1 就会通过 next 指针指向 key9，形成一个单向链表。<br /> <a href="/assets/img/it_basic/redis/redis-043.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-043.png" alt="哈希冲突" class="lazyload" data-proofer-ignore></a></p><p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。 要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。 接下来，看看 Redis 是如何实现的 rehash 的。</p><p>哈希表结构设计的这一小节，我给大家介绍了 Redis 使用 dictht 结构体表示哈希表。 不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了两个哈希表（ht[2]）。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="err">…</span>
    <span class="c1">//两个Hash表，交替使用，用于rehash操作</span>
    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> 
    <span class="err">…</span>
<span class="p">}</span> <span class="n">dict</span><span class="p">;</span>
</pre></table></code></div></div><p>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。<br /> <a href="/assets/img/it_basic/redis/redis-044.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-044.png" alt="哈希冲突" class="lazyload" data-proofer-ignore></a></p><p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。 随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</ul><p>为了方便你理解，我把 rehash 这三个过程画在了下面这张图。 这个过程看起来简单，但是其实第二步很有问题，如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求。<br /> <a href="/assets/img/it_basic/redis/redis-045.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-045.png" alt="哈希冲突" class="lazyload" data-proofer-ignore></a></p><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。 渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；<li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上；<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间嗲呢，会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</ul><p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。 在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。 比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作， 这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p><p>rehash 的触发条件跟 <strong>负载因子（load factor）</strong> 有关系。 负载因子可以通过下面这个公式计算：<br /> <a href="/assets/img/it_basic/redis/redis-046.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-046.png" alt="哈希冲突" class="lazyload" data-proofer-ignore></a></p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。<li>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</ul><h3 id="整数集合"><span class="mr-2">整数集合</span><a href="#整数集合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不时，就会使用整数集这个数据结构作为底层实现。</p><h4 id="整数集合结构设计"><span class="mr-2">整数集合结构设计</span><a href="#整数集合结构设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>整数集合本质上是一块连续内存空间，它的结构定义如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="c1">//编码方式</span>
    <span class="kt">uint32_t</span> <span class="n">encoding</span><span class="p">;</span>
    <span class="c1">//集合包含的元素数量</span>
    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="c1">//保存元素的数组</span>
    <span class="kt">int8_t</span> <span class="n">contents</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</pre></table></code></div></div><p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组， 但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p><ul><li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；</ul><p>不同类型的 contents 数组，意味着数组的大小也会不同。</p><h4 id="整数集合的升级操作"><span class="mr-2">整数集合的升级操作</span><a href="#整数集合的升级操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时， 整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p><p>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。 举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。<br /> <a href="/assets/img/it_basic/redis/redis-047.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-047.png" alt="整数集合" class="lazyload" data-proofer-ignore></a></p><p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作， 首先需要为 contents 数组扩容，在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素。<br /> <a href="/assets/img/it_basic/redis/redis-048.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-048.png" alt="整数集合" class="lazyload" data-proofer-ignore></a></p><p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：<br /> <a href="/assets/img/it_basic/redis/redis-049.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-049.png" alt="整数集合" class="lazyload" data-proofer-ignore></a></p><p>整数集合升级有什么好处呢？ 如果要让一个数组同时保存 int16_t、int32_t、int64_t 类型的元素，最简单做法就是直接使用 int64_t 类型的数组。 不过这样的话，当如果元素都是 int16_t 类型的，就会造成内存浪费的情况。 整数集合升级就能避免这种情况，如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组， 只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作。 因此，整数集合升级的好处是节省内存资源。</p><p>整数集合支持降级操作吗？ 不支持降级操作，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了 65535 元素， 整数集合的数组还是 int32_t 类型的，并不会因此降级为 int16_t 类型。</p><h3 id="跳表"><span class="mr-2">跳表</span><a href="#跳表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。 Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zset</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>
    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zset</span><span class="p">;</span>
</pre></table></code></div></div><p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><h4 id="跳表结构设计"><span class="mr-2">跳表结构设计</span><a href="#跳表结构设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快读定位数据。</p><p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。<br /> <a href="/assets/img/it_basic/redis/redis-050.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-050.png" alt="跳表" class="lazyload" data-proofer-ignore></a></p><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；<li>L1 层级共有 3 个节点，分别是节点 2、3、5；<li>L2 层级只有 1 个节点，也就是节点 3 。</ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p><p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。 那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="c1">//Zset 对象的元素值</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="c1">//元素权重值</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="c1">//后向指针</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
 
    <span class="c1">//节点的level数组，保存每层上的前向指针和跨度</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>
</pre></table></code></div></div><p>Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。 每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的zskiplistLevel 结构体类型的 level 数组。 level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示， 比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p><p>比如，下面这张图，展示了各个节点的跨度。<br /> <a href="/assets/img/it_basic/redis/redis-051.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-051.png" alt="跳表" class="lazyload" data-proofer-ignore></a></p><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；<li>L1 层级共有 3 个节点，分别是节点 2、3、5；<li>L2 层级只有 1 个节点，也就是节点 3 。</ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p><p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p><p>那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="c1">//Zset 对象的元素值</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="c1">//元素权重值</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="c1">//后向指针</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
 
    <span class="c1">//节点的level数组，保存每层上的前向指针和跨度</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>
</pre></table></code></div></div><p>Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。 每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的zskiplistLevel 结构体类型的 level 数组。</p><p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示， 比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p><p>比如，下面这张图，展示了各个节点的跨度。<br /> <a href="/assets/img/it_basic/redis/redis-052.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-052.png" alt="跳表" class="lazyload" data-proofer-ignore></a></p><p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针就可以完成了。 跨度实际上是为了计算这个节点在跳表中的排位。具体怎么做的呢？因为跳表中的节点都是按序排列的， 那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p><p>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L3），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。</p><p>另外，图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点的后向指针、权重、元素值都会被用到，所以图中省略了这部分。</p><p>问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍「跳表」结构体了，如下所示：</p><ul><li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；<li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；<li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="跳表节点查询过程"><span class="mr-2">跳表节点查询过程</span><a href="#跳表节点查询过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时， 会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针， 然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。 举个例子，下图有个 3 层级的跳表。<br /> <a href="/assets/img/it_basic/redis/redis-053.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-053.png" alt="跳表" class="lazyload" data-proofer-ignore></a></p><p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p><ul><li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；<li>但是该层上的下一个节点是空节点，于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];<li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；<li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</ul><h4 id="跳表节点层数设置"><span class="mr-2">跳表节点层数设置</span><a href="#跳表节点层数设置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。 举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。<br /> <a href="/assets/img/it_basic/redis/redis-054.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-054.png" alt="跳表" class="lazyload" data-proofer-ignore></a></p><p>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。 跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。 下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。<br /> <a href="/assets/img/it_basic/redis/redis-055.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-055.png" alt="跳表" class="lazyload" data-proofer-ignore></a></p><p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？ 如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。 Redis 则采用一种巧妙的方法是，跳表在创建节点的时候，随机生成每个节点的层数，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p><p>具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%）， 那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。 这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p><h3 id="quicklist"><span class="mr-2">quicklist</span><a href="#quicklist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。 其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计， 如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p><p>quicklist 解决办法，通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。 因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</p><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklist</span> <span class="p">{</span>
    <span class="c1">//quicklist的链表头</span>
    <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>      <span class="c1">//quicklist的链表头</span>
    <span class="c1">//quicklist的链表头</span>
    <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span> 
    <span class="c1">//所有压缩列表中的总元素个数</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
    <span class="c1">//quicklistNodes的个数</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>       
    <span class="p">...</span>
<span class="p">}</span> <span class="n">quicklist</span><span class="p">;</span>
</pre></table></code></div></div><p>quicklistNode 的结构定义：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="p">{</span>
    <span class="c1">//前一个quicklistNode</span>
    <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>     <span class="c1">//前一个quicklistNode</span>
    <span class="c1">//下一个quicklistNode</span>
    <span class="k">struct</span> <span class="n">quicklistNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>     <span class="c1">//后一个quicklistNode</span>
    <span class="c1">//quicklistNode指向的压缩列表</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">;</span>              
    <span class="c1">//压缩列表的的字节大小</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>                
    <span class="c1">//压缩列表的元素个数</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="mi">16</span><span class="p">;</span>        <span class="c1">//ziplist中的元素个数 </span>
    <span class="p">....</span>
<span class="p">}</span> <span class="n">quicklistNode</span><span class="p">;</span>
</pre></table></code></div></div><p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。 但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。 我画了一张图，方便你理解 quicklist 数据结构。<br /> <a href="/assets/img/it_basic/redis/redis-056.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-056.png" alt="quicklist" class="lazyload" data-proofer-ignore></a></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素， 如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h3 id="listpack"><span class="mr-2">listpack</span><a href="#listpack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p><p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p><p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了， 压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p>我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、Set 对象的底层数据结构的压缩列表还未被替换成 listpack， 而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现， 估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本。</p><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。 我们先看看 listpack 结构：<br /> <a href="/assets/img/it_basic/redis/redis-057.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-057.png" alt="listpack" class="lazyload" data-proofer-ignore></a></p><p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。 每个 listpack 节点结构如下：<br /> <a href="/assets/img/it_basic/redis/redis-058.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-058.png" alt="listpack" class="lazyload" data-proofer-ignore></a></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；<li>data，实际存放的数据；<li>len，encoding+data的总长度；</ul><p>可以看到，listpack 没有压缩列表中记录前一个节点长度的字段了， listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候， 不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</p><h3 id="rax前缀树"><span class="mr-2">rax(前缀树)</span><a href="#rax前缀树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>rax 是 redis 自己实现的基数树, 它是一种基于存储空间优化的前缀树数据结构, 在 redis 的许多地方都有使用到， 比如：streams这个类型里面的 consumer group(消费者组) 的名称还有集群名称；集群状态下clusterState中的slots_to_keys用rax保存了从槽到key之间的关系。 通常来讲, 一个基数树(前缀树) 看起来如下所示：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="o">*</span>              <span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="s">""</span>
 <span class="o">*</span>                \
 <span class="o">*</span>                <span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="s">"f"</span>
 <span class="o">*</span>                  \
 <span class="o">*</span>                  <span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="s">"fo"</span>
 <span class="o">*</span>                    \
 <span class="o">*</span>                  <span class="p">[</span><span class="n">t</span>   <span class="n">b</span><span class="p">]</span> <span class="s">"foo"</span>
 <span class="o">*</span>                  <span class="o">/</span>     \
 <span class="o">*</span>         <span class="s">"foot"</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>     <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="s">"foob"</span>
 <span class="o">*</span>                <span class="o">/</span>         \
 <span class="o">*</span>      <span class="s">"foote"</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>         <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="s">"fooba"</span>
 <span class="o">*</span>              <span class="o">/</span>             \
 <span class="o">*</span>    <span class="s">"footer"</span> <span class="p">[]</span>             <span class="p">[]</span> <span class="s">"foobar"</span>
</pre></table></code></div></div><p>然而, 当前的代码实现使用了一种非常常见的优化策略, 把只有单个子的节点连续几个节点压缩成一个节点, 这个节点有一个字符串, 不再是只存储单个字符, 上述的结构可以优化成如下结构：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> <span class="o">*</span>                  <span class="p">[</span><span class="s">"foo"</span><span class="p">]</span> <span class="s">""</span>
 <span class="o">*</span>                     <span class="o">|</span>
 <span class="o">*</span>                  <span class="p">[</span><span class="n">t</span>   <span class="n">b</span><span class="p">]</span> <span class="s">"foo"</span>
 <span class="o">*</span>                  <span class="o">/</span>     \
 <span class="o">*</span>        <span class="s">"foot"</span> <span class="p">(</span><span class="s">"er"</span><span class="p">)</span>    <span class="p">(</span><span class="s">"ar"</span><span class="p">)</span> <span class="s">"foob"</span>
 <span class="o">*</span>                 <span class="o">/</span>          \
 <span class="o">*</span>       <span class="s">"footer"</span> <span class="p">[]</span>          <span class="p">[]</span> <span class="s">"foobar"</span>
</pre></table></code></div></div><p>字符串 mygroup1 在 rax 中也是以压缩节点的方式存储的, 可以用如下表示:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="o">*</span>                  <span class="p">[</span><span class="s">"mygroup1"</span><span class="p">]</span> <span class="s">""</span>
 <span class="o">*</span>                     <span class="o">|</span>
 <span class="o">*</span>                    <span class="p">[]</span> <span class="s">"mygroup1"</span>
</pre></table></code></div></div><p>第一个节点存储了压缩过的整个字符串 mygroup1, 第二个节点是一个空的叶子节点, 他是一个 key 值, 表示到这个节点之前合起来的字符串存储在了当前的 raxNode中。 rax结构代表一个Rax树：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">rax</span> <span class="p">{</span>
<span class="err">　　</span><span class="n">raxNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="err">　　</span><span class="kt">uint64_t</span> <span class="n">numele</span><span class="p">;</span>
<span class="err">　　</span><span class="kt">uint64_t</span> <span class="n">numnodes</span><span class="p">;</span>
<span class="p">}</span> <span class="n">rax</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>head：指向rax的头节点；<li>numele：rax元素的个数，即key的个数；<li>numnodes：节点个数。</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">raxNode</span> <span class="p">{</span>
    <span class="c1">//节点是否包含key</span>
    <span class="kt">uint32_t</span> <span class="n">iskey</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Does this node contain a key? */</span>
    <span class="c1">//节点的值是否为NULL</span>
    <span class="kt">uint32_t</span> <span class="n">isnull</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>    <span class="cm">/* Associated value is NULL (don't store it). */</span>
    <span class="c1">//节点是否被压缩</span>
    <span class="kt">uint32_t</span> <span class="n">iscompr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Node is compressed. */</span>
    <span class="c1">//节点大小</span>
    <span class="kt">uint32_t</span> <span class="n">size</span><span class="o">:</span><span class="mi">29</span><span class="p">;</span>     <span class="cm">/* Number of children, or compressed string len. */</span>
    <span class="c1">//节点的实际存储数据</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">raxNode</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>iskey 表示当前的节点是否为 key 节点，即表示从 Radix Tree 的根节点到当前节点路径上的字符组成的字符串，是否表示了一个完整的 key。这里需要注意的是，当前节点所表示的 key，并不包含该节点自身的内容<li>isnull 表示当前节点是否有存储额外的值(data的指针是否为空)<li>iscompr 表示当前节点是否为压缩的节点<li>size 是子节点数量或者压缩的字符串长度，如果当前节点是压缩节点，该值表示压缩数据的长度；如果是非压缩节点，该值表示该节点指向的子节点个数。<li>data存储数据</ul><p>在 Radix Tree 中存在两类节点：</p><ul><li>第一类节点是非压缩节点，这类节点会包含多个指向不同子节点的指针，以及多个子节点所对应的字符。data 数组包括子节点对应的字符、指向子节点的指针，以及节点表示 key 时对应的 value 指针；<li>第二类节点是压缩节点，这类节点会包含一个指向子节点的指针，以及子节点所代表的合并的字符串。data 数组包括子节点对应的合并字符串、指向子节点的指针，以及节点为 key 时的 value 指针。</ul><p>在 raxNode 的实现中，无论是非压缩节点还是压缩节点，其实具有两个特点：</p><ul><li>它们所代表的 key，是从根节点到当前节点路径上的字符串，但并不包含当前节点；<li>它们本身就已经包含了子节点代表的字符或合并字符串。而对于它们的子节点来说， 也都属于非压缩或压缩节点，所以，子节点本身又会保存，子节点的子节点所代表的字符或合并字符串。</ul><p>可以简单看下这个例子：<br /> <a href="/assets/img/it_basic/redis/redis-059.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-059.png" alt="radix" class="lazyload" data-proofer-ignore></a></p><p>这张图上显示了 Radix Tree 最右侧分支的 4 个节点 r、e、d、is 和它们各自的 raxNode 内容。 其中，节点 r、e 和 d 都不代表 key，所以它们的 iskey 值为 0，isnull 值为 1，没有为 value 指针分配空间。</p><p>节点 r 和 e 指向的子节点都是单字符节点，所以它们不是压缩节点，iscompr 值为 0。而节点 d 的子节点包含了合并字符串“is”， 所以该节点是压缩节点，iscompr 值为 1。最后的叶子节点 is，它的 raxNode 的 size 为 0，没有子节点指针。 不过，因为从根节点到节点 is 路径上的字符串代表了 key“redis”，所以，节点 is 的 value 指针指向了“redis”对应的 value 数据。</p><p>这里，你需要注意的是，为了满足内存对齐的需要，raxNode 会根据保存的字符串长度，在字符串后面填充一些字节，也就是图中的 padding 部分。 下图是字符串 mygroup1 当前所在的 rax 的实际图示：<br /> <a href="/assets/img/it_basic/redis/redis-060.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-060.png" alt="radix" class="lazyload" data-proofer-ignore></a></p><p>第一个节点的 iscompr 值为 1, 并且整个字符串 mygroup1 存储在了当前这一个节点中, size 为 8 表示当前节点存储了 8 个 char 字符, iskey为 0, 表示当前的节点不是 key 节点, 我们需要继续往下搜索。</p><p>第二个节点的 iskey 为 1, 表示当前的节点为 key 节点, 它表示在到这个节点之前的所有字符串连起来(也就是mygroup1) 存在当前的前缀树中, 也就是说当前的前缀树有包含 mygroup1 这个字符串, isnull 为 0 表示在当前这个 key 节点的 data 尾部存储了一个指针, 这个指针是函数调用者进行存储的, 在当前的情况它是一个指向 streamCG 的指针, 但是实际上他可以是指向任意对象的指针, 比如集群名称或者其他对象。</p><p>我们再来插入一个 consumer group 名称到当前的前缀树中：比如执行 XGROUP CREATE mystream mygroup2 $<br /> <a href="/assets/img/it_basic/redis/redis-061.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-061.jpeg" alt="radix" class="lazyload" data-proofer-ignore></a></p><p>从上图可知, 第一个节点被裁剪了, 并且它后面插入了一个新的节点, 左下角的节点是原先存在的节点, 右下角的节点也是一个新插入的节点:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="o">*</span>                  <span class="p">[</span><span class="s">"mygroup"</span><span class="p">]</span> <span class="s">""</span>
 <span class="o">*</span>                     <span class="o">|</span>
 <span class="o">*</span>                  <span class="p">[</span><span class="mi">1</span>   <span class="mi">2</span><span class="p">]</span> <span class="s">"mygroup"</span>
 <span class="o">*</span>                  <span class="o">/</span>     \
 <span class="o">*</span>      <span class="s">"mygroup1"</span> <span class="p">[]</span>     <span class="p">[]</span> <span class="s">"mygroup2"</span>
</pre></table></code></div></div><p>中间的节点未被压缩(iscompr 这个位没有被设置), data 字段中存储了 size 个字符, 在这些字符之后, 同样会存储 size 个指向与之前字符一一对应的 raxNode 的结构的指针。 底下两个节点的 iskey = 1 并 isnull = 0, 表示当到达任意一个这样的节点时, 当前的字符串是存储在这个前缀树中的, 并且在 data 字段最尾部存储了一个辅助的指针, 这个指针具体指向什么对象取决于调用者。</p><h3 id="stream"><span class="mr-2">stream</span><a href="#stream" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Stream 会使用 Radix Tree 来保存消息 ID，然后将消息内容保存在 listpack 中，并作为消息 ID 的 value，用 raxNode 的 value 指针指向对应的 listpack。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">stream</span> <span class="p">{</span>
<span class="err">　　</span><span class="n">rax</span> <span class="o">*</span><span class="n">rax</span><span class="p">;</span> <span class="cm">/* 存储生产者生产的具体消息，以消息ID为键，消息内容为值存储在rax中，值得注意的是，rax中的一个节点可能存储多个消息*/</span>
<span class="err">　　</span><span class="kt">uint64_t</span> <span class="n">length</span><span class="p">;</span> <span class="cm">/*当前stream中的消息个数（不包括已经删除的消息）。*/</span>
<span class="err">　　</span><span class="n">streamID</span> <span class="n">last_id</span><span class="p">;</span> <span class="cm">/* 当前stream中最后插入的消息的ID，stream空时，设置为0。. */</span>
<span class="err">　　</span><span class="n">rax</span> <span class="o">*</span><span class="n">cgroups</span><span class="p">;</span> <span class="cm">/* 存储了当前stream相关的消费组，rax中: name -&gt; streamCG */</span>
<span class="p">}</span> <span class="n">stream</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>rax：指向rax的的头节点，存储生产者生产的具体消息，以消息ID为键，消息内容为值存储在rax中；<li>length：stream中消息的个数，不包括已经删除的消息；<li>last_id： 当前stream中最后插入的消息的ID，stream空时，设置为0；<li>cgoups：指向rax的头节点，存储了当前stream相关的消费组。</ul><p>每个Stream会有多个消费组，每个消费组通过组名称进行唯一标识，同时关联一个streamCG结构，该结构定义如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">streamCG</span> <span class="p">{</span>
<span class="err">　　</span><span class="n">streamID</span> <span class="n">last_id</span><span class="p">;</span> <span class="c1">// 该消费组已经确认的最后一个消息的ID</span>
<span class="err">　　</span><span class="n">rax</span> <span class="o">*</span><span class="n">pel</span><span class="p">;</span> <span class="c1">// 该消费组尚未确认的消息，消息ID为键，streamNACK（一个尚未确认的消息）为值；</span>
<span class="err">　　</span><span class="n">rax</span> <span class="o">*</span><span class="n">consumers</span><span class="p">;</span> <span class="c1">// 该消费组中所有的消费者，消费者的名称为键，streamConsumer（代表一个消费者）为值。</span>
<span class="p">}</span> <span class="n">streamCG</span><span class="p">;</span>
</pre></table></code></div></div><p>每个消费者通过streamConsumer唯一标识，该结构如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">streamConsumer</span> <span class="p">{</span>
<span class="err">　　</span><span class="n">mstime_t</span> <span class="n">seen_time</span><span class="p">;</span> <span class="cm">/* 该消费者最后一次活跃的时间； */</span>
<span class="err">　　</span><span class="n">sds</span> <span class="n">name</span><span class="p">;</span> <span class="cm">/* 消费者的名称*/</span>
<span class="err">　　</span><span class="n">rax</span> <span class="o">*</span><span class="n">pel</span><span class="p">;</span> <span class="cm">/* 消费者尚未确认的消息，以消息ID为键，streamNACK为值。 */</span>
<span class="p">}</span> <span class="n">streamConsumer</span><span class="p">;</span>
</pre></table></code></div></div><p>未确认消息（streamNACK）维护了消费组或者消费者尚未确认的消息，值得注意的是，消费组中的pel的元素与每个消费者的pel中的元素是共享的， 即该消费组消费了某个消息，这个消息会同时放到消费组以及该消费者的pel队列中，并且二者是同一个streamNACK结构。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/* Pending (yet not acknowledged) message in a consumer group. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">streamNACK</span> <span class="p">{</span>
    <span class="n">mstime_t</span> <span class="n">delivery_time</span><span class="p">;</span> <span class="cm">/* 该消息最后发送给消费方的时间 */</span>
    <span class="kt">uint64_t</span> <span class="n">delivery_count</span><span class="p">;</span> <span class="cm">/*为该消息已经发送的次数（组内的成员可以通过xclaim命令获取某个消息的处理权，该消息已经分给组内另一个消费者但其并没有确认该消息）。*/</span>
    <span class="n">streamConsumer</span> <span class="o">*</span><span class="n">consumer</span><span class="p">;</span> <span class="cm">/* 该消息当前归属的消费者 */</span>
<span class="p">}</span> <span class="n">streamNACK</span><span class="p">;</span>
</pre></table></code></div></div><p>此外，还可以看下迭代器：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">streamIterator</span> <span class="p">{</span>
    <span class="n">stream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span> <span class="cm">/*当前迭代器正在遍历的消息流 */</span>
    <span class="n">streamID</span> <span class="n">master_id</span><span class="p">;</span> <span class="cm">/* 消息内容实际存储在listpack中，每个listpack都有一个masterentry（也就是第一个插入的消息），master_id为该消息id */</span>
    <span class="kt">uint64_t</span> <span class="n">master_fields_count</span><span class="p">;</span> <span class="cm">/* master entry中field域的个数. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">master_fields_start</span><span class="p">;</span> <span class="cm">/*master entry field域存储的首地址*/</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">master_fields_ptr</span><span class="p">;</span> <span class="cm">/*当listpack中消息的field域与master entry的field域完全相同时，该消息会复用master entry的field域，在我们遍历该消息时，需要记录当前所在的field域的具体位置，master_fields_ptr就是实现这个功能的。 */</span>
    <span class="kt">int</span> <span class="n">entry_flags</span><span class="p">;</span> <span class="cm">/* 当前遍历的消息的标志位 */</span>
    <span class="kt">int</span> <span class="n">rev</span><span class="p">;</span> <span class="cm">/*当前迭代器的方向 */</span>
    <span class="kt">uint64_t</span> <span class="n">start_key</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* 该迭代器处理的消息ID的范围 */</span>
    <span class="kt">uint64_t</span> <span class="n">end_key</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* End key as 128 bit big endian. */</span>
    <span class="n">raxIterator</span> <span class="n">ri</span><span class="p">;</span> <span class="cm">/*rax迭代器，用于遍历rax中所有的key. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span> <span class="cm">/* 当前listpack指针*/</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lp_ele</span><span class="p">;</span> <span class="cm">/* 当前正在遍历的listpack中的元素, cursor. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lp_flags</span><span class="p">;</span> <span class="cm">/* Current entry flags pointer.指向当前消息的flag域 */</span>
    <span class="c1">//用于从listpack读取数据时的缓存</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">field_buf</span><span class="p">[</span><span class="n">LP_INTBUF_SIZE</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value_buf</span><span class="p">[</span><span class="n">LP_INTBUF_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">streamIterator</span><span class="p">;</span>
</pre></table></code></div></div><p>存储方式如下图示：<br /> <a href="/assets/img/it_basic/redis/redis-062.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-062.png" alt="stream" class="lazyload" data-proofer-ignore></a></p><p>stream 结构体中的 rax 指针，指向了 Radix Tree 的头节点，也就是 rax 结构体。 rax 结构体中的头指针进一步指向了第一个 raxNode。因为我们假设就只有一个 streamID， 暂时没有其他 streamID 和该 streamID 共享前缀，所以，当前这个 streamID 就可以用压缩节点保存。</p><p>然后，第一个 raxNode 指向了下一个 raxNode，也是 Radix Tree 的叶子节点。 这个节点的 size 为 0，它的 value 指针指向了实际的消息内容。</p><p>streamID可以自己指定，也可以由redis生成，即由每个消息创建时的时间（1970年1月1号至今的毫秒数）以及序号组成，共128位：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">streamID</span> <span class="p">{</span>
<span class="err">　　</span><span class="kt">uint64_t</span> <span class="n">ms</span><span class="p">;</span> <span class="cm">/* Unix time in milliseconds. */</span>
<span class="err">　　</span><span class="kt">uint64_t</span> <span class="n">seq</span><span class="p">;</span> <span class="cm">/* Sequence number. */</span>
<span class="p">}</span> <span class="n">streamID</span><span class="p">;</span>
</pre></table></code></div></div><p>而在消息内容这里，是使用了 listpack 进行保存的。 一个listpack可以存储多个消息，也就是说多个raxNode可能会指向同一个listpack。</p><p>每个listpack都有一个master entry，该结构中存储了创建这个listpack时待插入消息的所有field， 这主要是考虑同一个消息流，消息内容通常具有相似性，如果后续消息的field与master entry内容相同， 则不需要再存储其field。master entry中每一个元素都是一个单独的entry （下图省略了listpack每个元素存储时的encoding以及backlen字段）<br /> <a href="/assets/img/it_basic/redis/redis-063.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-063.png" alt="stream" class="lazyload" data-proofer-ignore></a></p><ul><li>count 为当前listpack中的所有未删除的消息个数；<li>deleted 为当前listpack中所有已经删除的消息个数；<li>num-fields 为下面的field的个数；<li>field-1,…,filed-N 为当前listpack中第一个插入的消息的所有field域；<li>0 为标识位，在从后向前遍历该listpack的所有消息时使用。</ul><p>存储一个消息时，如果该消息的field域与master entry的域完全相同，则不需要再次存储field域：<br /> <a href="/assets/img/it_basic/redis/redis-064.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-064.png" alt="stream" class="lazyload" data-proofer-ignore></a></p><ul><li>flags字段为消息标志位，STREAM_ITEM_FLAG_NONE代表无特殊标识， STREAM_ITEM_FLAG_DELETED代表该消息已经被删除， STREAM_ITEM_FLAG_SAMEFIELDS代表该消息的field域与master entry完全相同；<li>streamID.ms以及streamID.seq为该消息ID减去master entry id之后的值；<li>value域存储了该消息的每个field域对应的内容；<li>lp-count为该消息占用listpack的元素个数，也就是3+N。</ul><p>消息的field域与master entry不完全相同，存储如下：<br /> <a href="/assets/img/it_basic/redis/redis-065.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-065.png" alt="stream" class="lazyload" data-proofer-ignore></a></p><ul><li>flags为消息标志位，与上面一致；<li>streamID.ms，streamID.seq为该消息ID减去master entry id之后的值；<li>num-fields为该消息field域的个数；<li>field-value存储了消息的域值对，也就是消息的具体内容；<li>lp-count为该消息占用的listpack的元素个数，也就是4+2N。</ul><h4 id="添加消息"><span class="mr-2">添加消息</span><a href="#添加消息" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis提供了streamAppendItem函数，用于向stream中添加一个新的消息：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">streamAppendItem</span><span class="p">(</span><span class="n">stream</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">robj</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">numfields</span><span class="p">,</span> 
        <span class="n">streamID</span> <span class="o">*</span><span class="n">added_id</span><span class="p">,</span> <span class="n">streamID</span> <span class="o">*</span><span class="n">use_id</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>s 为待插入的数据流；<li>argv 为待插入的消息内容，argv[0]为field_1，argv[1]为value_1，依此类推；<li>numfields 为待插入的消息的field的总数；<li>added_id 不为空，并且插入成功时，将新插入的消息id写入added_id以供调用方使用；<li>use_id 为调用方为该消息定义的消息id，该消息id应该大于s中任意一个消息的id。</ul><p>大概流程如下：</p><ul><li>获取rax的最后一个key所在的节点，由于Rax树是按照消息id的顺序存储的，所以最后一个key节点存储了上一次插入的消息；<li>查看该节点是否可以插入这条新的消息；<li>如果该节点已经不能再插入新的消息（listpack为空或者已经达到设定的存储最大值），在rax中插入新的节点（以消息id为key，新建listpack为value），并初始化新建的listpack；<li>如果仍然可以插入消息，则对比插入的消息与listpack中的master消息对应的fields是否完全一致，完全一致则表明该消息可以复用master的field；<li>将待插入的消息内容插入到新建的listpack中或者原来的rax的最后一个key节点对应的listpack中，这一步主要取决于前2步的结果。</ul><h4 id="删除消息"><span class="mr-2">删除消息</span><a href="#删除消息" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>streamIteratorRemoveEntry函数用于移除某个消息，值得注意的是，该函数通常只是设置待移除消息的标志位为已删除，并修改master entry的统计信息， 而不会将该消息从所在的listpack中删除。当消息所在的整个listpack的所有消息都已删除时，则会从rax中释放该节点。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">streamIteratorRemoveEntry</span><span class="p">(</span><span class="n">streamIterator</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span> <span class="n">streamID</span> <span class="o">*</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lp</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">aux</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">lpGetInteger</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">lp_flags</span><span class="p">);</span>
    <span class="n">flags</span> <span class="o">|=</span> <span class="n">STREAM_ITEM_FLAG_DELETED</span><span class="p">;</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">lpReplaceInteger</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">lp_flags</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span> <span class="c1">// 设置消息的标志位</span>

    <span class="cm">/* Change the valid/deleted entries count in the master entry. */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">lpFirst</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">lpGetInteger</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 当前Listpack只有待删除消息，可以直接删除节点. */</span>
        <span class="n">lpFree</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
        <span class="n">raxRemove</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">,</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">.</span><span class="n">key_len</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 修改listpack master enty中的统计信息 */</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="n">lpReplaceInteger</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="n">aux</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">lpNext</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">p</span><span class="p">);</span> <span class="cm">/* Seek deleted field. */</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">lpGetInteger</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="n">lpReplaceInteger</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="n">aux</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="cm">/* 查看listpack是否有变化(listpack中元素变化导致的扩容缩容) . */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">lp</span> <span class="o">!=</span> <span class="n">lp</span><span class="p">)</span>
            <span class="n">raxInsert</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">,</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">ri</span><span class="p">.</span><span class="n">key_len</span><span class="p">,</span><span class="n">lp</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">.....</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="参考文档"><span class="mr-2">参考文档</span><a href="#参考文档" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><a href="https://blog.csdn.net/Xin_101/article/details/126341239?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-12-126341239-blog-124260839.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-12-126341239-blog-124260839.pc_relevant_aa&amp;utm_relevant_index=16">图文讲解Redis底层数据结构之embstr,raw,ziplist,quicklist和hashtable （带源码讲解）</a><li><a href="https://blog.csdn.net/qq_44766883/article/details/126203364?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-126203364-blog-108218992.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-126203364-blog-108218992.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=7">redis各数据类型的编码格式和数据结构SDS、list、dict、zskiplist、intset、ziplist、quicklist、listpack、rax、stream</a></ul><h2 id="redis-源码导读"><span class="mr-2">redis 源码导读</span><a href="#redis-源码导读" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>数据结构除了抽象描述之外，如何实现也是很有参考价值的。了解Redis原理时看C语言代码有困难， 或者想了解Go语言是如何实现Redis功能的，可参考<a href="https://zhuanlan.zhihu.com/p/383044660">Godis</a>。</p><p><a href="/assets/img/it_basic/redis/redis-001.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-001.png" alt="总体流程图" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-002.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-002.png" alt="服务端流程图" class="lazyload" data-proofer-ignore></a></p><ul><li><a href="https://zhouyx.blog.csdn.net/article/details/121600281?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-121600281-blog-126255683.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9-121600281-blog-126255683.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=15">Redis 源码阅读篇</a><li><a href="https://blog.csdn.net/wejack/article/details/127535759?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5-127535759-blog-121716785.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5-127535759-blog-121716785.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=6">Redis源码解析-全览</a><li><a href="https://blog.csdn.net/gps666666/article/details/121715787">深入了解Redis（底层实现）源码 （第一篇）</a><li><a href="https://blog.csdn.net/gps666666/article/details/121716310">深入了解Redis（底层实现）源码 （第二篇）</a><li><a href="https://blog.csdn.net/gps666666/article/details/121716785">深入了解Redis（底层实现）源码 （第三篇）</a><li><a href="https://blog.csdn.net/gps666666/article/details/121718331">深入了解Redis（底层实现）源码 （第四篇）</a><li><a href="https://blog.csdn.net/u012804784/article/details/127161136">Redis核心设计原理（深入底层C源码）</a><li><a href="https://jutou.blog.csdn.net/article/details/124647689?spm=1001.2101.3001.6650.17&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-17-124647689-blog-121600281.pc_relevant_landingrelevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-17-124647689-blog-121600281.pc_relevant_landingrelevant&amp;utm_relevant_index=23">如何去高效阅读源码</a><li><a href="https://github.com/huangz1990/redis-3.0-annotated">Redis源码注解</a><li><a href="https://github.com/redis/redis">Redis源码</a> 阅读源码应从低版本开始，毕竟代码量比较少<li><a href="http://doc.yonyoucloud.com/doc/wiki/project/redis/index.html">Redis 源码日志</a></ul><h1 id="redis-通信协议">redis 通信协议</h1><p>所谓 协议，本质是一种约定，需要使用者双方来准守，常见于 C/S 通信模式中，比如在浏览器中最常用的 HTTP 应用层通信协议。 通信两端需要某种约定，才能保持正常通信。一端通过约定的格式发送数据，另一端通过约定的格式解析数据，这种约定，取了一个好听的名字 —- 协议。 典型的 HTTP 协议，最本质的原理也是如此。redis 作为一款高性能内存组件，要尽可能将精力花在数据的组织形式上，因此，没有采用开源的一些复杂协议，比如 HTTP，而是简单的自定义一套应用层通信协议。</p><p>Redis 客户端 - 服务端通信协议称之为 RESP 协议，全称叫 Redis Serialization Protocol，即 redis 序列化协议。人类易读，相当精巧！</p><p>RESP 是一种二进制安全协议，因为编码后的每一个字符串都有前缀来表明其长度，通过长度就能知道数据边界，从而避免越界访问的问题。 值得注意的是，RESP 协议只用于 客户端 - 服务端 之间的交流，redis cluster 各节点之间采用不同的二进制协议（采用 Gossip 协议）进行交流。</p><p>我们知道，在传统计算机网络模型中，传输层（TCP / UDP）的上一层便是应用层。应用层协议一般专注于数据的编解码等约定，比如经典的 HTTP 协议。 RESP 协议本质和 HTTP 是一个级别，都属于应用层协议。</p><p>在 redis 中，传输层协议使用的是 TCP，服务端从 TCP socket 缓冲区中读取数据，然后经过 RESP 协议解码得到我们的指令。 而写入数据则是相反，服务器先将响应数据使用 RESP 编码，然后将编码后的数据写入 TCP Socket 缓冲区发送给客户端。</p><h2 id="resp2"><span class="mr-2">RESP2</span><a href="#resp2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在 RESP 协议中，第一个字节决定了具体数据类型：</p><ul><li>简单字符串：Simple Strings，第一个字节响应 +<li>错误：Errors，第一个字节响应 -<li>整型：Integers，第一个字节响应 :<li>批量字符串：Bulk Strings，第一个字节响应 $<li>数组：Arrays，第一个字节响应 *</ul><p>我们来看看一具体的例子，我们一条正常指令<code class="language-plaintext highlighter-rouge">PSETEX test_redisson_batch_key8 120000 test_redisson_batch_key=&gt;value:8</code>，经 RESP 协议编码后长这样：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">*</span>4
<span class="nv">$6</span>
PSETEX
<span class="nv">$24</span>
test_redisson_batch_key8
<span class="nv">$6</span>
120000
<span class="nv">$32</span>
<span class="nv">test_redisson_batch_key</span><span class="o">=&gt;</span>value:8
</pre></table></code></div></div><p>值得注意的是，在 RESP 协议中的每一部分都是以 <code class="language-plaintext highlighter-rouge">\R\N</code> 结尾。</p><h3 id="简单字符串"><span class="mr-2">简单字符串</span><a href="#简单字符串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Simple Strings。以 + 为前缀的响应数据，例如：<code class="language-plaintext highlighter-rouge">"+OK\r\n"</code>。 以上是字符串 <code class="language-plaintext highlighter-rouge">OK</code>，被编码后的格式，总共 5 字节。</p><p>这是一种非二进制安全的编码方式，因为， 我们无法确切的知道字符串的长度，只能以 \r\n 来判断，所以编码的字符串中，不能包含 \r 或者 \n 字符。 当然，如果你想要二进制安全字符串，可以选择 Bulk Strings 方式，我们后面会介绍。</p><h3 id="错误"><span class="mr-2">错误</span><a href="#错误" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RESP 提供了错误类型，和简单字符串非常类似，不过是以 - 开头，基本格式如下：<code class="language-plaintext highlighter-rouge">"-Error message\r\n"</code>。 与简单字符串真正不同的之处在于客户端的处理上，对 - 开头的响应，客户端直接以异常情况处理。 我们来看一个是实际例子，当我们的指令或者参数错误，redis 服务端会直接返回异常，如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nt">-ERR</span> unknown <span class="nb">command</span> <span class="s1">'helloworld'</span>
<span class="nt">-WRONGTYPE</span> Operation against a key holding the wrong kind of value
</pre></table></code></div></div><p>其中 - 后面的第一个单词，直到第一个空格或换行符，表示返回的错误类型。这只是 Redis 使用的一个惯例，并不是 RESP 错误格式的一部分。 ERR 是通用错误，而 WRONGTYPE 是一个更具体的错误，表示客户端尝试执行错误的数据类型，通常作为一个错误的前缀，它允许客户端在不检查确切错误消息的情况下理解服务器返回的错误类型。</p><p>我们在客户端实现的时候，可以针对不同的错误返回不同类型的异常，或者提供一种捕获错误的通用方法，比如，直接将错误名称作为字符串提供给调用者。 然而，这样的特性不应该被认为是至关重要的，因为它很少有用，而且有限的客户端实现可能只是返回一个通用的错误条件，比如 false。</p><h3 id="整型"><span class="mr-2">整型</span><a href="#整型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RESP Integers。表示响应的是整数，以 : 开头，比如 :0\r\n 和 :1000\r\n</p><p>redis 中很多命令的响应都是整数，比如 INCR, LLEN, 及 LASTSAVE。另外，响应值是一个 64 位的整数。 当然，整形也可以表示 true 或者 false 语义，比如 EXISTS 或者 SISMEMBER 返回 1 表示 true，0 表示 false。 还有其他命令，比如 SADD, SREM, 和 SETNX 返回 1 表示实际执行，反之为 0。</p><p>以下命令会响应结果为整数：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>SETNX, DEL, EXISTS, INCR, 
INCRBY, DECR, DECRBY, 
DBSIZE, LASTSAVE, RENAMENX, 
MOVE, LLEN, SADD, SREM, 
SISMEMBER, SCARD.
</pre></table></code></div></div><h3 id="批量字符串"><span class="mr-2">批量字符串</span><a href="#批量字符串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RESP Bulk Strings。批量回复，是一个大小在 512 Mb 的二进制安全字符串，被编码成：</p><ul><li>以 $ 开头，紧跟一个整数代表回复字符串的大小，以 \r\n 结束<li>随后是实际的字符串数据<li>最后以 “\r\n” 结尾</ul><p>以下是示例：</p><ul><li>比如 hello 被编码为：”$5\r\nhello\r\n”<li>一个空字符串被编码为：”$0\r\n\r\n”</ul><p>另外，对于一些不存在的 value 可以返回 -1 表示 null，也被称为 NULL 批量回复。 客户端库进行实现时，可以将此 -1 处理成空对象，比如 Ruby 将返回 nil，而 C 则返回 NULL</p><h3 id="数组"><span class="mr-2">数组</span><a href="#数组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RESP Arrays。数组，对于响应的集合元素，比如 LRANGE 命令，返回的是元素列表，也就是数组形式。编码格式：</p><ul><li>以 * 开头表示，紧接着是一个整数，表示数组元素个数，并以 \r\n 结尾。<li>数组的每个元素的都是 RESP 提供的类型。</ul><p>以下是示例：</p><ul><li>例如，空数组：<code class="language-plaintext highlighter-rouge">"*0\r\n"</code><li>包含 “hello” 和 “world” 的响应数组（也叫多批量字符串，每一个元素是批量字符串）：<code class="language-plaintext highlighter-rouge">"*2\r\n$5\r\nhello\r\n$5\r\nworld\r\n"</code><li>3个整数的数组是这样的：<code class="language-plaintext highlighter-rouge">"*3\r\n:1\r\n:2\r\n:3\r\n"</code><li>另外，数组也可以混合类型的。比如以下5个元素中，有4个是整形，一个是 批量字符串：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">*</span>5<span class="se">\r\n</span>
:1<span class="se">\r\n</span>
:2<span class="se">\r\n</span>
:3<span class="se">\r\n</span>
:4<span class="se">\r\n</span>
<span class="nv">$5</span><span class="se">\r\n</span>
hello<span class="se">\r\n</span>
</pre></table></code></div></div><p>以上结果为了更加清晰的展示，进行了手动换行。</p><p>当然，也同样支持空数组（一般情况下，更习惯使用 Null Bulk String，但由于历史原因，两种方式都存在） 例如，当使用 BLPOP 命令 timeout 时，将返回空数组：<code class="language-plaintext highlighter-rouge">"*-1\r\n"</code></p><p>当 redis 返回 NULL 数组时，客户端实现库最好也返回一个空对象， 有助于区别到底是 empty 数组还是产生了其他问题内置数组，如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">*</span>2<span class="se">\r\n</span>
<span class="k">*</span>3<span class="se">\r\n</span>
:1<span class="se">\r\n</span>
:2<span class="se">\r\n</span>
:3<span class="se">\r\n</span>
<span class="k">*</span>2<span class="se">\r\n</span>
+Hello<span class="se">\r\n</span>
<span class="nt">-World</span><span class="se">\r\n</span>
</pre></table></code></div></div><p>同样，为了展示更加清晰，进行了手动换行</p><p>该响应结果表示，外层数组包含两个元素，每个元素都是数组。第一个子数组包含 3 个整型数字，第二个子数组包含 1 个简单字符串和一个错误。</p><h3 id="数组中的空元素"><span class="mr-2">数组中的空元素</span><a href="#数组中的空元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Null elements in Arrays。数组出现 NULL 元素，这种场景也是很常见的， 比如我们使用 MGET 批量获取 key，当其中一些 key 不存在时，返回的就是 NULL 元素。例如响应结果：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">*</span>3<span class="se">\r\n</span>
<span class="nv">$5</span><span class="se">\r\n</span>
hello<span class="se">\r\n</span>
<span class="nv">$-</span>1<span class="se">\r\n</span>
<span class="nv">$5</span><span class="se">\r\n</span>
world<span class="se">\r\n</span>
</pre></table></code></div></div><p>如上响应编码，客户端库解析之后应该是这样：<code class="language-plaintext highlighter-rouge">["hello",nil,"world"]</code></p><h3 id="多命令和管道"><span class="mr-2">多命令和管道</span><a href="#多命令和管道" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Multiple commands and pipelining。多命令和管道，redis 中提供了一次发送多条指令的操作，比如 MGET、MSET、pipline，服务端接收并处理后一次性响应。 这种形式就是上面提到的数组，数组里面可以是批量字符串、整数，甚至是 NULL 都可以。 我们先使用 telnet 看看原生响应结果：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">[</span>root@VM-20-17-centos ~]# telnet 127.0.0.1 6379
MGET key1 key2 key3
<span class="k">*</span>3
<span class="nv">$6</span>
value1
<span class="nv">$6</span>
value2
<span class="nv">$-</span>1
</pre></table></code></div></div><p>我们再使用 redis-cli 看看被客户端解码后的结果：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>127.0.0.1:6379&gt; MGET key1 key2 key3
1<span class="o">)</span> <span class="s2">"value1"</span>
2<span class="o">)</span> <span class="s2">"value2"</span>
3<span class="o">)</span> <span class="o">(</span>nil<span class="o">)</span>
</pre></table></code></div></div><h3 id="内联命令"><span class="mr-2">内联命令</span><a href="#内联命令" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Inline commands。是这样的，一般情况下我们和 redis 服务端通信都需要一个客户端（比如redis-cli），因为双方都遵循 RESP 协议，数据可以正常编码和解析。 考虑这样一种情况，当你没有任何客户端工具可用时，是否也能正常和服务端通信呢？比如 telnet。 也是可以的，redis 正式通过 内联指令 支持的，咱们来看看例子：</p><ul><li>例1，通过 RESP 协议发送指令（由于没有客户端，这里我们手动编码）：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="o">[</span>root@VM-20-17-centos ~]# telnet 127.0.0.1 6379
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is <span class="s1">'^]'</span><span class="nb">.</span>
<span class="k">*</span>3       
<span class="nv">$3</span>
<span class="nb">set</span>
<span class="nv">$4</span>   
key1
<span class="nv">$5</span> 
world
+OK
</pre></table></code></div></div><p>我们正常的指令是 set key1 word，经过 RESP 编码之后 <code class="language-plaintext highlighter-rouge">*3\r\n$3\r\nset\r\n$4\r\nkey1\r\r$5\r\nworld</code>，redis 服务端解码之后便可得到正常指令。</p><ul><li>例2，通过内联操作发送指令：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="o">[</span>root@VM-20-17-centos ~]# telnet 127.0.0.1 6379
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is <span class="s1">'^]'</span><span class="nb">.</span>
exists key1
:1
get key1
<span class="nv">$1</span>
1
<span class="nb">set </span>key1 hello             
+OK
get key1
<span class="nv">$5</span>
hello
</pre></table></code></div></div><p>这里我们直接发送 内联指令 比如 EXISTS key1、GET key1、SET key1 hello 等，无需 RESP 协议编码，服务端仍可正常处理。 值得注意的是，因为没有了统一请求协议中的 * 项来声明参数的数量，所以在 telnet 会话输入命令的时候，必须使用空格来分割各个参数， 服务器在接收到数据之后，会按空格对用户的输入进行解析，并获取其中的命令参数。</p><h3 id="高性能-redis-协议解析器"><span class="mr-2">高性能 Redis 协议解析器</span><a href="#高性能-redis-协议解析器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>High performance parser for the Redis protocol，即，高性能 Redis 协议分析器。 RESP 是一款人类易读、简单实现的通信协议，它可以类似于二进制协议的性能实现。 RESP 使用前缀长度来传输批量数据，因此不需要像 JSON 那样，为了查找某个特殊字符而扫描整个数据，也无须对发送至服务器的数据进行转义。</p><p>程序可以在对协议文本中的各个字符进行处理的同时， 查找 CR 字符， 并计算出批量回复或多条批量回复的长度， 就像这样：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">"$123</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">'\r'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
        <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Now p points at '\r', and the len is in bulk_len. */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>得到了批量回复或多条批量回复的长度之后， 程序只需调用一次 read 函数， 就可以将回复的正文数据全部读入到内存中， 而无须对这些数据做任何的处理。 在回复最末尾的 CR 和 LF 不作处理，丢弃它们。 Redis 协议的实现性能可以和二进制协议的实现性能相媲美，并且由于 Redis 协议的简单性，大部分高级语言都可以轻易地实现这个协议，这使得客户端软件的 bug 数量大大减少。</p><h3 id="参考文档-1"><span class="mr-2">参考文档</span><a href="#参考文档-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><a href="https://blog.csdn.net/ldw201510803006/article/details/126093440?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-126093440-blog-128150427.pc_relevant_3mothn_strategy_and_data_recovery&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">redis 通信协议（RESP），最简单的应用层协议，没有之一</a><li><a href="http://redisdoc.com/topic/protocol.html">redis 通信协议</a><li><a href="https://www.redis.com.cn/topics/rediscli.html">redis-cli，Redis命令行工具</a></ul><h2 id="resp3"><span class="mr-2">RESP3</span><a href="#resp3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为了照顾老用户，Redis6在兼容 RESP2 的基础上，开始支持 RESP3，但未来会全面切换到RESP3之上。 今天的客户端缓存在基于RESP3才能有更好的实现，可以在同一个连接中运行数据的查询和接收失效消息。 而目前在RESP2上实现的客户端缓存，需要两个客户端连接以转发重定向的形式实现</p><p>在Redis6中我们可以使用HELLO命令在RESP2和RESP3协议之间进行切换：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c">#使用RESP2协议</span>
HELLO 2
<span class="c">#使用RESP3协议</span>
HELLO 3
</pre></table></code></div></div><h3 id="与resp2兼容"><span class="mr-2">与RESP2兼容</span><a href="#与resp2兼容" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>随着Redis版本的不断更新以及功能迭代，RESP V2协议开始渐渐无法满足新的需求， 为了适配在Redis6.0中出现的一些新功能，在它的基础上发展出了全新的下一代RESP3协议。 下面我们先来回顾一下继承自RESP V2的5种数据返回类型，在了解这些类型的局限性后， 再来看看RESP3中新的数据返回类型都在什么地方做出了改进。</p><h4 id="请求格式"><span class="mr-2">请求格式</span><a href="#请求格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>协议中数据的请求格式与RESP V2完全相同，请求的格式如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">*</span>&lt;参数数量&gt; CRLF
<span class="nv">$&lt;</span>参数1的字节长度&gt; CRLF
&lt;参数1的数据&gt; CRLF
<span class="nv">$&lt;</span>参数2的字节长度&gt; CRLF
&lt;参数2的数据&gt; CRLF
...
<span class="nv">$&lt;</span>参数N的字节长度&gt; CRLF
&lt;参数N的数据&gt; CRLF
</pre></table></code></div></div><p>每行末尾的CRLF转换成程序语言是\r\n，也就是回车加换行。以set name hydra这条命令为例， 转换过程及转换后的结果如下：<br /> <a href="/assets/img/it_basic/redis/redis-066.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-066.png" alt="RESP3" class="lazyload" data-proofer-ignore></a></p><p>在了解了发送的协议后，下面对不同类型的回复进行测试。这一过程如何进行模拟呢？ 直接在命令行下使用telnet进行连接就可以了，以我本机启动的redis为例， 直接输入telnet 127.0.0.1 6379就可以连接到redis服务了。 之后再将包含换行的指令一次性拷贝到命令行，然后回车，就能够收到来自Redis服务的回复了：<br /> <a href="/assets/img/it_basic/redis/redis-067.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-067.png" alt="RESP3" class="lazyload" data-proofer-ignore></a></p><p>下面先来看看继承自RESP V2的5种返回格式，为了统一命名规范， 介绍中均采用RESP3官方文档中的新的名称来替代RESP V2中的旧命名， 例如不再使用旧的批量回复、多条批量回复等类型名称。</p><h4 id="simple-string"><span class="mr-2">Simple string</span><a href="#simple-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>表示简单字符串回复，它只有一行回复，回复的内容以+作为开头，不允许换行，并以\r\n结束。 有很多指令在执行成功后只会回复一个OK，使用的就是这种格式，能够有效地将传输、解析的开销降到最低。 还是以上面的set指令为例，发送请求</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">*</span>3
<span class="nv">$3</span>
<span class="nb">set</span>
<span class="nv">$4</span>
name
<span class="nv">$5</span>
hydra
</pre></table></code></div></div><p>收到回复：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>+OK<span class="se">\r\n</span>
</pre></table></code></div></div><h4 id="simple-error"><span class="mr-2">Simple error</span><a href="#simple-error" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>错误回复，它可以看做简单字符串回复的变种形式，它们之间的格式也非常类似， 区别只有第一个字符是以-作为开头，错误回复的内容通常是错误类型及对错误描述的字符串。 错误回复出现在一些异常的场景，例如当发送了错误的指令、操作数的数量不对时，都会进行错误回复。</p><p>发送一条错误的指令：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">*</span>1
<span class="nv">$8</span>
Dr.Hydra
</pre></table></code></div></div><p>收到回复，提示错误信息：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nt">-ERR</span> unknown <span class="nb">command</span> <span class="sb">`</span>Dr.Hydra<span class="sb">`</span>, with args beginning with:<span class="se">\r\n</span>
</pre></table></code></div></div><h4 id="number"><span class="mr-2">Number</span><a href="#number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>整数回复，它的应用也非常广泛，它以:作为开头，以\r\n结束，用于返回一个整数。 例如当执行incr后返回自增后的值，执行llen返回数组的长度， 或者使用exists命令返回的0或1作为判断一个key是否存在的依据，这些都使用了整数回复。</p><p>发送一条查看数组长度的指令：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">*</span>2
<span class="nv">$4</span>
llen
<span class="nv">$7</span>
myarray
</pre></table></code></div></div><p>收到回复：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>:4<span class="se">\r\n</span>
</pre></table></code></div></div><h4 id="blob-string"><span class="mr-2">Blob string</span><a href="#blob-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>多行字符串的回复，也被叫做批量回复，在RESP V2中将它称为Bulk String。以$作为开头， 后面是发送的字节长度，然后是\r\n，然后发送实际的数据，最终以\r\n结束。 如果要回复的数据不存在，那么回复长度为-1。</p><p>发送一条get命令请求：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">*</span>2
<span class="nv">$3</span>
get
<span class="nv">$4</span>
name
</pre></table></code></div></div><p>收到回复：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$5</span><span class="se">\r\n</span>
hydra<span class="se">\r\n</span>
</pre></table></code></div></div><h4 id="array"><span class="mr-2">Array</span><a href="#array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>可以理解为RESP V2中的多条批量回复，当服务端要返回多个值时，例如返回一些元素的集合时， 就会使用Array。它以*作为开头，后面是返回元素的个数，之后再跟随多个上面的Blob String。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">*</span>4
<span class="nv">$6</span>
lrange
<span class="nv">$7</span>
myarray
<span class="nv">$1</span>
0
<span class="nv">$2</span>
<span class="nt">-1</span>
</pre></table></code></div></div><p>收到回复，包含了集合中的4个元素：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">*</span>4
<span class="nv">$1</span>
1
<span class="nv">$1</span>
2
<span class="nv">$1</span>
2
<span class="nv">$2</span>
32
</pre></table></code></div></div><h3 id="resp3中新的类型"><span class="mr-2">RESP3中新的类型</span><a href="#resp3中新的类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>目前在Redis6.0.X版本中，仍然是默认使用的RESP V2协议，并且在兼容RESP V2的基础上， 也同时也支持开启RESP3。估计在未来的某个版本，Redis可能会全面切换到RESP3， 不过这么做的话对目前的Redis客户端连接工具会有不小的冲击，都需要根据协议内容进行底层通信的改造。</p><p>在使用telnet连接到redis服务后，先输入下面的命令来切换到RESP3版本的协议， 至于hello命令的具体返回数据以及数据表示的意义，这里暂且略过，后面会具体来看。</p><p>下面我们就来详细看看在RESP3中，除了保留上面的5种旧回复类型外，新增的13种通信返回数据类型， 部分数据类型会配合示例进行演示。为了看起来更加简洁，下面的演示例子发送命令均使用原始命令， 不再转化为协议格式，并且省略数据返回结果中每行结束的\r\n！</p><h4 id="null"><span class="mr-2">Null</span><a href="#null" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>新协议中使用下划线字符后跟CR和LF字符来表示空值，也就是用_\r\n来替代原先的单个空值的返回$-1。 例如在使用get命令查找一个不存在的key时，get keyNotExist，不同版本的回包协议返回如下：</p><ul><li>RESP V2 返回 <code class="language-plaintext highlighter-rouge">$-1</code><li>RESP3 返回 <code class="language-plaintext highlighter-rouge">_\r\n</code></ul><h4 id="double"><span class="mr-2">Double</span><a href="#double" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>浮点数返回时以逗号开头，格式为 ,<floating-point-number>\r\n，使用zset score key member获取分数的命令来进行测试。 如执行 zscore fruit apple，返回如下：</floating-point-number></p><ul><li>RESP V2返回时使用的是Bulk String的格式：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$18</span>
5.6600000000000001
</pre></table></code></div></div><ul><li>RESP3返回格式：<code class="language-plaintext highlighter-rouge">,5.6600000000000001\r\n</code></ul><h4 id="boolean"><span class="mr-2">Boolean</span><a href="#boolean" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>布尔类型的数据返回值，其中true被表示为#t\r\n，而false被表示为#f\r\n。</p><h4 id="blob-error"><span class="mr-2">Blob error</span><a href="#blob-error" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>与字符串类型比较相似，它的格式为!<length>\r\n<bytes>\r\n，但是与简单错误类型一样， 开头使用!表示返回的是一段错误信息描述。例如错误SYNTAX invalid syntax会按照下面的格式返回：</bytes></length></p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">!</span>21
SYNTAX invalid syntax
</pre></table></code></div></div><h4 id="verbatim-string"><span class="mr-2">Verbatim string</span><a href="#verbatim-string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Verbatim string也表示一个字符串格式，与Blob String非常相似，但是使用=开头替换了$， 另外之后的三个字节提供了有关字符串格式的信息，例如txt表示纯文本，mkd表示markdown格式， 第四个字节则固定为 :。这种格式适用于在没有任何转义或过滤的情况下显示给用户。</p><p>使用延时事件统计与分析指令进行测试，发送：latency doctor</p><ul><li>RESP2返回的数据还是Blob String格式：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$196</span>
Dave, no latency spike was observed during the lifetime of this Redis instance, not <span class="k">in </span>the slightest bit. I honestly think you ought to sit down calmly, take a stress pill, and think things over.
</pre></table></code></div></div><ul><li>RESP V3返回的数据采用了新的格式：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">=</span>200
txt:Dave, no latency spike was observed during the lifetime of this Redis instance, not <span class="k">in </span>the slightest bit. I honestly think you ought to sit down calmly, take a stress pill, and think things over.
</pre></table></code></div></div><h4 id="big-number"><span class="mr-2">Big number</span><a href="#big-number" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Big number类型用于返回非常大的整数数字，可以表示在有符号64位数字范围内的整数，包括正数或负数， 但是需要注意不能含有小数部分。数据格式为(&lt;big number&gt;\r\n，以左括号开头，示例如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">(</span>3492890328409238509324850943850943825024385
</pre></table></code></div></div><p>注意，当Big number不可用时，客户端会返回一个字符串格式的数据。</p><h4 id="aggregate-data-types"><span class="mr-2">Aggregate data types</span><a href="#aggregate-data-types" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>与前面我们介绍的给定数据类型的单个值不同，Aggregate data types可以理解为聚合数据类型。 这也是RESP3的一个核心思想，要能够从协议和类型的角度，来描述不同语义的聚合数据类型。</p><p>聚合数据类型的格式如下，通常由聚合类型、元素个数以及具体的单一元素构成：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>&lt;aggregate-type-char&gt;&lt;numelements&gt;&lt;CR&gt;&lt;LF&gt;
... numelements other types ...
</pre></table></code></div></div><p>例如一个包含三个数字的数组[1,2,3]可以表示为：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">*</span>3
:1
:2
:3
</pre></table></code></div></div><p>当然聚合数据类型中的元素可以是其他聚合数据类型，例如在数组中也可以嵌套包含其他数组（下面的内容包含了缩进方便理解）：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">*</span>2
    <span class="k">*</span>3
        :1
        <span class="nv">$5</span>
        hello
        :2
    <span class="c">#f</span>
</pre></table></code></div></div><p>上面的聚合数据类型所表示的数据为[[1,”hello”,2],false]。</p><h4 id="map"><span class="mr-2">Map</span><a href="#map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Map数据类型与数组比较类似，但是以%作为起始，后面是Map中键值对的数量，而不再是单个数据项的数量。 它的数据内容是一个有序的键值对的数组，之后分行显示键值对的key和value，因此后面的数据行一定是偶数行。 先看一下官方文档给出的例子，以下面的Json字符串为例：</p><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"first"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nl">"second"</span><span class="p">:</span><span class="mi">2</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>转换为Map类型后格式为下面的形式：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>%2
+first
:1
+second
:2
</pre></table></code></div></div><p>但是通过实验，Hydra发现了点有意思的东西，当我们发送一条hgetall的命令来请求哈希类型的数据时， 如 hgetall user</p><ul><li>RESP V2返回的数据仍然使用老的Array格式，符合我们的预期：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">*</span>4
<span class="nv">$4</span>
name
<span class="nv">$5</span>
Hydra
<span class="nv">$3</span>
age
<span class="nv">$2</span>
18
</pre></table></code></div></div><ul><li>但是下面RESP3的数据返回却出乎我们的意料，可以看到虽然前面的%2表示使用了Map格式， 但是后面并没有遵循官方文档给出的规范，除了开头的%2以外，其余部分与Array完全相同（）。</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>%2
<span class="nv">$4</span>
name
<span class="nv">$5</span>
Hydra
<span class="nv">$3</span>
age
<span class="nv">$2</span>
18
</pre></table></code></div></div><p>关于实际传输数据与文档中给出示例的出入，Hydra有一点自己的猜测，放在最后总结部分。</p><h4 id="set"><span class="mr-2">Set</span><a href="#set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Set与Array类型非常相似，但是它的第一个字节使用~替代了*，它是一个无序的数据集合。 还是先看一下官方文档中给出的示例，下面是一个包含了5个元素的集合类型数据，并且其中具体的数据类型可以不同：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>~5&lt;CR&gt;&lt;LF&gt;
+orange&lt;CR&gt;&lt;LF&gt;
+apple&lt;CR&gt;&lt;LF&gt;
<span class="c">#t&lt;CR&gt;&lt;LF&gt;</span>
:100&lt;CR&gt;&lt;LF&gt;
:999&lt;CR&gt;&lt;LF&gt;
</pre></table></code></div></div><p>下面使用SMEMBERS命令获取集合中的所有元素进行测试，如 MEMBERS myset</p><ul><li>RESP V2返回时仍然使用Array格式：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">*</span>3
<span class="nv">$1</span>
a
<span class="nv">$1</span>
c
<span class="nv">$1</span>
b
</pre></table></code></div></div><ul><li>RESP3的数据返回情况和Map比较类似，使用~开头，但是没有完全遵从协议中的格式：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>~3
<span class="nv">$1</span>
a
<span class="nv">$1</span>
c
<span class="nv">$1</span>
b
</pre></table></code></div></div><h4 id="attribute"><span class="mr-2">Attribute</span><a href="#attribute" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Attribute类型与Map类型非常相似，但是头一个字节使用|来代替了%， Attribute描述的数据内容比较像Map中的字典映射。客户端不应该将这个字典内容看做数据回复的一部分， 而是当做增强回复内容的辅助数据。</p><p>在文档中提到，在未来某个版本的Redis中可能会出现这样一个功能，每次执行指令时都会打印访问的key的请求频率， 这个值可能使用一个浮点数表示，那么在执行MGET a b时就可能会收到回复：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>|1
    +key-popularity
    %2
        <span class="nv">$1</span>
        a
        ,0.1923
        <span class="nv">$1</span>
        b
        ,0.0012
<span class="k">*</span>2
    :2039123
    :9543892
</pre></table></code></div></div><p>在上面的数据回复中，实际中回复的数据应该是[2039123,9543892]，但是在前面附加了它们请求的属性， 当读到这个Attribute类型数据后，应当继续读取后面的实际数据。</p><h4 id="push"><span class="mr-2">Push</span><a href="#push" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Push数据类型是一种服务器向客户端发送的异步数据，它的格式与Array类型比较类似，但是以&gt;开头， 接下来的数组中的第一个数据为字符串类型，表示服务器发送给客户端的推送数据是何种类型。 数组中其他的数据也都包含自己的类型，需要按照协议中类型规范进行解析。</p><p>简单看一下文档中给出的示例，在执行get key命令后，可能会得到两个有效回复：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="o">&gt;</span>4
+pubsub
+message
+somechannel
+this is the message
<span class="nv">$9</span>
Get-Reply
</pre></table></code></div></div><p>在上面的这段回复中需要注意，收到的两个回复中第一个是推送数据的类型，第二个才是真正回复的数据内容。 注意！这里在文档中有一句提示：虽然下面的演示使用的是Simple string格式， 但是在实际数据传输中使用的是Blob string格式。所以盲猜一波，上面的Map和Set也是同样的情况？</p><p>这里先简单铺垫一下Push回复类型在redis6中非常重要的一个使用场景客户端缓存client-side caching， 它允许将数据存储在本地应用中，当访问时不再需要访问redis服务端， 但是其他客户端修改数据时需要通知当前客户端作废掉本地应用的客户端缓存，这时候就会用到Push类型的消息。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>client tracking on
get key1
</pre></table></code></div></div><p>在客户端B中执行： set key1 newValue</p><p>这时就会在客户端A中收到Push类型的消息，通知客户端缓存失效。在下面收到的消息中就包含了两部分， 第一部分表示收到的消息类型为invalidate，第二部分则是需要作废的缓存key1：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;</span>2
<span class="nv">$10</span>
invalidate
<span class="k">*</span>1
<span class="nv">$4</span>
key1
</pre></table></code></div></div><h4 id="stream-1"><span class="mr-2">Stream</span><a href="#stream-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在前面介绍的类型中，返回的数据字符串一般都具有指定的长度，例如下面这样：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$1234</span>&lt;CR&gt;&lt;LF&gt;
.... 1234 bytes of data here ...&lt;CR&gt;&lt;LF&gt;
</pre></table></code></div></div><p>但是有时候需要将一段不知道长度的字符串数据从客户端传给服务器（或者反向传输）时， 很明显这种格式无法使用，因此需要一种新的格式用来传送不确定长度的数据。</p><p>文档中提到，过去在服务端有一个私有扩展的数据格式，规范如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$EOF</span>:&lt;40 bytes marker&gt;&lt;CR&gt;&lt;LF&gt;
... any number of bytes of data here not containing the marker ...
&lt;40 bytes marker&gt;
</pre></table></code></div></div><p>它以$EOF:作为起始字节，然后是40字节的marker标识符，在\r\n后跟随的是真正的数据，结束后也是40字节的标识符。 标识符以伪随机的方式生成，基本上不会与正常的数据发生冲突。</p><p>但是这种格式存在一定的局限性，主要问题就在于生成标识符以及解析标识符上， 由于一些原因使得上面这种格式在实际使用中非常脆弱。因此最终在规范中提出了一种分块编码格式， 举一个简单的例子，当需要发送事先不知道长度的字符串Hello world时：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$?</span>
<span class="p">;</span>4
Hell
<span class="p">;</span>5
o wor
<span class="p">;</span>2
ld
<span class="p">;</span>0
</pre></table></code></div></div><p>这种格式以$?开头，表示是一个不知道长度的分块编码格式，后面传输的数据数量没有限制， 在最后以零长度的;0作为结束传输的标识。文档中提到，目前还没有命令会以这个格式来进行数据回复， 但是会在后面的功能模块中实装这个协议。</p><h4 id="hello"><span class="mr-2">HELLO</span><a href="#hello" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在介绍RESP3的最开始，我们就在telnet中通过hello 3的命令来切换协议到V3版本。这个特殊的命令完成了两件事：</p><ul><li>它允许服务器与RESP V2版本向后兼容，也方便以后更加轻松的切换到RESP3<li>hello命令可以返回有关服务器和协议的信息，以供客户端使用</ul><p>hello命令的格式如下，可以看到除了协议版本号外，还可以指定用户名和密码：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>HELLO &lt;protocol-version&gt; <span class="o">[</span>AUTH &lt;username&gt; &lt;password&gt;]
</pre></table></code></div></div><p>hello命令的返回结果是前面介绍过的Map类型，仅仅在客户端和服务器建立连接的时候发送。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre>%7
<span class="nv">$6</span>
server
<span class="nv">$5</span>
redis
<span class="nv">$7</span>
version
<span class="nv">$6</span>
6.0.16
<span class="nv">$5</span>
proto
:3
<span class="nv">$2</span>
<span class="nb">id</span>
:18
<span class="nv">$4</span>
mode
<span class="nv">$10</span>
standalone
<span class="nv">$4</span>
role
<span class="nv">$6</span>
master
<span class="nv">$7</span>
modules
<span class="k">*</span>0
</pre></table></code></div></div><p>转换为我们可读的Map格式后，可以看到它返回的Redis服务端的一些信息：</p><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"server"</span><span class="p">:</span><span class="s2">"redis"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="s2">"6.0.16"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"proto"</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w">
    </span><span class="nl">"id"</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span><span class="w">
    </span><span class="nl">"mode"</span><span class="p">:</span><span class="s2">"standalone"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"role"</span><span class="p">:</span><span class="s2">"master"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"modules"</span><span class="p">:[]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><h4 id="参考文档-2"><span class="mr-2">参考文档</span><a href="#参考文档-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><a href="https://github.com/redis/redis-doc/blob/master/docs/reference/protocol-spec.md">redis-doc</a><li><a href="https://github.com/antirez/RESP3/blob/master/spec.md">RESP3</a><li><a href="https://redis.io/docs/reference/protocol-spec/#high-performance-parser-for-the-redis-protocol">redis-parser</a><li><a href="https://github.com/sandwich-go/redisson">go-redis客户端</a></ul><h2 id="gossip"><span class="mr-2">gossip</span><a href="#gossip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Cluster中的每个节点都维护一份在自己看来当前整个集群的状态，主要包括：</p><ul><li>当前集群状态<li>集群中各节点所负责的slots信息，及其migrate状态<li>集群中各节点的master-slave状态<li>集群中各节点的存活状态及不可达投票</ul><p>redis集群的哈希槽算法解决的是数据的存取问题，不同的哈希槽位于不同的节点上，而不同的节点维护着一份它所认为的当前集群的状态， 同时，Redis集群是去中心化的架构。那么，当集群的状态发生变化时，比如新节点加入、slot迁移、节点宕机、slave提升为新Master等等， 我们希望这些变化尽快被其他节点发现，Redis是如何进行处理的呢？也就是说，Redis不同节点之间是如何进行通信进行维护集群的同步状态呢？</p><p>在Redis集群中，不同的节点之间采用gossip协议进行通信，节点之间通讯的目的是为了维护节点之间的元数据信息。 这些元数据就是每个节点包含哪些数据，是否出现故障，通过gossip协议，达到最终数据的一致性。</p><p>gossip协议，是基于流行病传播方式的节点或者进程之间信息交换的协议。原理就是在不同的节点间不断地通信交换信息， 一段时间后，所有的节点就都有了整个集群的完整信息，并且所有节点的状态都会达成一致。每个节点可能知道所有其他节点， 也可能仅知道几个邻居节点，但只要这些节可以通过网络连通，最终他们的状态就会是一致的。 Gossip协议最大的好处在于，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。</p><p>Redis集群中节点的通信过程如下：</p><ul><li>集群中每个节点都会单独开一个TCP通道，用于节点间彼此通信。<li>每个节点在固定周期内通过待定的规则选择几个节点发送ping消息<li>接收到ping消息的节点用pong消息作为响应</ul><p>使用gossip协议的优点在于将元数据的更新分散在不同的节点上面，降低了压力；但是缺点就是元数据的更新有延时， 可能导致集群中的一些操作会有一些滞后。另外，由于 gossip 协议对服务器时间的要求较高， 时间戳不准确会影响节点判断消息的有效性。而且节点数量增多后的网络开销也会对服务器产生压力， 同时结点数太多，意味着达到最终一致性的时间也相对变长，因此官方推荐最大节点数为1000左右。</p><p>redis cluster架构下的每个redis都要开放两个端口号，比如一个是6379，另一个就是加1w的端口号16379。</p><ul><li>6379端口号就是redis服务器入口。<li>16379端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。 cluster bus 用的是一种叫gossip 协议的二进制协议</ul><p>gossip协议常见的消息类型包含： ping、pong、meet、fail等等。</p><ul><li>meet：主要用于通知新节点加入到集群中，通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。<li>ping：用于交换节点的元数据。每个节点每秒会向集群中其他节点发送 ping 消息，消息中封装了自身节点状态还有其他部分节点的状态数据，也包括自身所管理的槽信息等等。<ul><li>因为发送ping命令时要携带一些元数据，如果很频繁，可能会加重网络负担。因此，一般每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。<li>如果发现某个节点通信延时达到了 cluster_node_timeout / 2，那么立即发送 ping，避免数据交换延时过长导致信息严重滞后。比如说， 两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 cluster_node_timeout 可以调节，如果调得比较大，那么会降低 ping 的频率。<li>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 3 个其它节点的信息，最多包含 （总节点数 - 2）个其它节点的信息。</ul><li>pong：ping和meet消息的响应，同样包含了自身节点的状态和集群元数据信息。<li>fail：某个节点判断另一个节点 fail 之后，向集群所有节点广播该节点挂掉的消息，其他节点收到消息后标记已下线。</ul><p>由于Redis集群的去中心化以及gossip通信机制，Redis集群中的节点只能保证最终一致性。例如当加入新节点时(meet)， 只有邀请节点和被邀请节点知道这件事，其余节点要等待 ping 消息一层一层扩散。除了 Fail 是立即全网通知的， 其他诸如新节点、节点重上线、从节点选举成为主节点、槽变化等，都需要等待被通知到，也就是Gossip协议是最终一致性的协议。</p><h1 id="redis-集群">redis 集群</h1><h2 id="集群部署方案"><span class="mr-2">集群部署方案</span><a href="#集群部署方案" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在开发测试环境中，我们一般搭建Redis的单实例来应对开发测试需求，但是在生产环境， 如果对可用性、可靠性要求较高，则需要引入Redis的集群方案。虽然现在各大云平台有提供缓存服务可以直接使用， 但了解一下其背后的实现与原理总还是有些必要（比如面试）， 本文就一起来学习一下Redis的几种集群方案</p><h3 id="主从复制模式"><span class="mr-2">主从复制模式</span><a href="#主从复制模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>原理：主从复制模式中包含一个主数据库实例（master）与一个或多个从数据库实例（slave），如下图<br /> <a href="/assets/img/it_basic/redis/redis-006.jpeg" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-006.jpeg" alt="主从复制" class="lazyload" data-proofer-ignore></a></p><p>客户端可对主数据库进行读写操作，对从数据库进行读操作，主数据库写入的数据会实时自动同步给从数据库。 具体工作机制为：</p><ul><li>slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照（即上文所介绍的RDB持久化）， 并使用缓冲区记录保存快照这段时间内执行的写命令<li>master将保存的快照文件发送给slave，并继续记录执行的写命令<li>slave接收到快照文件后，加载快照文件，载入数据<li>master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化<li>此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</ul><p>本示例基于Redis 5.0.3版。redis.conf的主要配置，部署示例如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c">###网络相关###</span>
<span class="c"># bind 127.0.0.1 # 绑定监听的网卡IP，注释掉或配置成0.0.0.0可使任意IP均可访问</span>
protected-mode no <span class="c"># 关闭保护模式，使用密码访问</span>
port 6379  <span class="c"># 设置监听端口，建议生产环境均使用自定义端口</span>
<span class="nb">timeout </span>30 <span class="c"># 客户端连接空闲多久后断开连接，单位秒，0表示禁用</span>
<span class="c">###通用配置###</span>
daemonize <span class="nb">yes</span> <span class="c"># 在后台运行</span>
pidfile /var/run/redis_6379.pid  <span class="c"># pid进程文件名</span>
logfile /usr/local/redis/logs/redis.log <span class="c"># 日志文件的位置</span>
<span class="c">###RDB持久化配置###</span>
save 900 1 <span class="c"># 900s内至少一次写操作则执行bgsave进行RDB持久化</span>
save 300 10
save 60 10000
<span class="c"># 如果禁用RDB持久化，可在这里添加 save ""</span>
rdbcompression <span class="nb">yes</span> <span class="c">#是否对RDB文件进行压缩，建议设置为no，以（磁盘）空间换（CPU）时间</span>
dbfilename dump.rdb <span class="c"># RDB文件名称</span>
<span class="nb">dir</span> /usr/local/redis/datas <span class="c"># RDB文件保存路径，AOF文件也保存在这里</span>
<span class="c">###AOF配置###</span>
appendonly <span class="nb">yes</span> <span class="c"># 默认值是no，表示不使用AOF增量持久化的方式，使用RDB全量持久化的方式</span>
appendfsync everysec <span class="c"># 可选值 always， everysec，no，建议设置为everysec</span>
<span class="c">###设置密码###</span>
requirepass 123456 <span class="c"># 设置复杂一点的密码</span>
</pre></table></code></div></div><p>部署主从复制模式只需稍微调整slave的配置，在redis.conf中添加</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>replicaof 127.0.0.1 6379 <span class="c"># master的ip，port</span>
masterauth 123456 <span class="c"># master的密码</span>
replica-serve-stale-data no <span class="c"># 如果slave无法与master同步，设置成slave不可读，方便监控脚本发现问题</span>
</pre></table></code></div></div><p>本示例在单台服务器上配置master端口6379，两个slave端口分别为7001,7002，启动master，再启动两个slave</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">[</span>root@dev-server-1 master-slave]# redis-server master.conf
<span class="o">[</span>root@dev-server-1 master-slave]# redis-server slave1.conf
<span class="o">[</span>root@dev-server-1 master-slave]# redis-server slave2.conf
</pre></table></code></div></div><p>进入master数据库，写入一个数据，再进入一个slave数据库，立即便可访问刚才写入master数据库的数据。如下所示</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="o">[</span>root@dev-server-1 master-slave]# redis-cli
127.0.0.1:6379&gt; auth 123456
OK
127.0.0.1:6379&gt; <span class="nb">set </span>site blog.jboost.cn
OK
127.0.0.1:6379&gt; get site
<span class="s2">"blog.jboost.cn"</span>
127.0.0.1:6379&gt; info replication
<span class="c"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="o">=</span>127.0.0.1,port<span class="o">=</span>7001,state<span class="o">=</span>online,offset<span class="o">=</span>13364738,lag<span class="o">=</span>1
slave1:ip<span class="o">=</span>127.0.0.1,port<span class="o">=</span>7002,state<span class="o">=</span>online,offset<span class="o">=</span>13364738,lag<span class="o">=</span>0
...
127.0.0.1:6379&gt; <span class="nb">exit</span>
<span class="o">[</span>root@dev-server-1 master-slave]# redis-cli <span class="nt">-p</span> 7001
127.0.0.1:7001&gt; auth 123456
OK
127.0.0.1:7001&gt; get site
<span class="s2">"blog.jboost.cn"</span>
</pre></table></code></div></div><p>执行info replication命令可以查看连接该数据库的其它库的信息，如上可看到有两个slave连接到master</p><p>主从复制的优缺点：</p><ul><li>优点：<ul><li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力<li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</ul><li>缺点：<ul><li>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复<li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题<li>难以支持在线扩容，Redis的容量受限于单机配置</ul></ul><h3 id="sentinel哨兵模式"><span class="mr-2">Sentinel（哨兵）模式</span><a href="#sentinel哨兵模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。如图<br /> <a href="/assets/img/it_basic/redis/redis-068.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-068.png" alt="哨兵集群" class="lazyload" data-proofer-ignore></a></p><p>哨兵顾名思义，就是来为Redis集群站哨的，一旦发现问题能做出相应的应对处理。其功能包括</p><ul><li>监控master、slave是否正常运行<li>当master出现故障时，能自动将一个slave转换为master（大哥挂了，选一个小弟上位）<li>多个哨兵可以监控同一个Redis，哨兵之间也会自动监控</ul><p>在配置文件中通过 sentinel monitor <master-name> <ip> <redis-port> <quorum> 来定位master的IP、端口， 一个哨兵可以监控多个master数据库，只需要提供多个该配置项即可。 哨兵启动后，会与要监控的master建立两条连接：</quorum></redis-port></ip></master-name></p><ul><li>一条连接用来订阅master的_sentinel_:hello频道与获取其他监控该master的哨兵节点信息<li>另一条连接定期向master发送INFO等命令获取master本身的信息</ul><p>与master建立连接后，哨兵会执行三个操作：</p><ul><li>定期（一般10s一次，当master被标记为主观下线时，改为1s一次）向master和slave发送INFO命令<li>定期向master和slave的_sentinel_:hello频道发送自己的信息<li>定期（1s一次）向master、slave和其他哨兵发送PING命令</ul><p>发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。 所以说哨兵只需要配置master数据库信息就可以自动发现其slave信息。 获取到slave信息后，哨兵也会与slave建立两条连接执行监控。 通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。</p><p>接下来哨兵向主从数据库的_sentinel_:hello频道发送信息与同样监控这些数据库的哨兵共享自己的信息， 发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本。 这些信息有以下用处：</p><ul><li>其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PING命令。<li>其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新<li>当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。</ul><p>如果被PING的数据库或者节点超时（通过 sentinel down-after-milliseconds master-name milliseconds 配置）未回复， 哨兵认为其主观下线（sdown，s就是Subjectively —— 主观地）。 如果下线的是master，哨兵会向其它哨兵发送命令询问它们是否也认为该master主观下线， 如果达到一定数目（即配置文件中的quorum）投票， 哨兵会认为该master已经客观下线（odown，o就是Objectively —— 客观地）， 并选举领头的哨兵节点对主从系统发起故障恢复。 若没有足够的sentinel进程同意master下线，master的客观下线状态会被移除， 若master重新向sentinel进程发送的PING命令返回有效回复，master的主观下线状态就会被移除</p><p>哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵来执行，选举采用Raft算法：</p><ul><li>发现master下线的哨兵节点（我们称他为A）向每个哨兵发送命令，要求对方选自己为领头哨兵<li>如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵<li>如果有超过一半的哨兵同意选举A为领头，则A当选<li>如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出， 此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票竞选，直至选举出领头哨兵</ul><p>选出领头哨兵后，领头者开始对系统进行故障恢复， 从出现故障的master的从数据库中挑选一个来当选新的master,选择规则如下：</p><ul><li>所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置<li>如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选<li>如果以上条件都一样，选取id最小的slave</ul><p>挑选出需要继任的slave后，领头哨兵向该数据库发送命令使其升格为master， 然后再向其他slave发送命令接受新的master，最后更新数据。 将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。</p><p>哨兵模式基于前文的主从复制模式。哨兵的配置文件为sentinel.conf，在文件中添加</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>sentinel monitor mymaster 127.0.0.1 6379 1 <span class="c"># mymaster定义一个master数据库的名称，后面是master的ip， port，1表示至少需要一个Sentinel进程同意才能将master判断为失效，如果不满足这个条件，则自动故障转移（failover）不会执行</span>
sentinel auth-pass mymaster 123456 <span class="c"># master的密码</span>
sentinel down-after-milliseconds mymaster 5000 <span class="c"># 5s未回复PING，则认为master主观下线，默认为30s</span>
sentinel parallel-syncs mymaster 2  <span class="c"># 指定在执行故障转移时，最多可以有多少个slave实例在同步新的master实例，在slave实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span>
sentinel failover-timeout mymaster 300000 <span class="c"># 如果在该时间（ms）内未能完成故障转移操作，则认为故障转移失败，生产环境需要根据数据量设置该值</span>
</pre></table></code></div></div><p>一个哨兵可以监控多个master数据库，只需按上述配置添加多套。 分别以26379,36379,46379端口启动三个sentinel</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">[</span>root@dev-server-1 sentinel]# redis-server sentinel1.conf <span class="nt">--sentinel</span>
<span class="o">[</span>root@dev-server-1 sentinel]# redis-server sentinel2.conf <span class="nt">--sentinel</span>
<span class="o">[</span>root@dev-server-1 sentinel]# redis-server sentinel3.conf <span class="nt">--sentinel</span>
</pre></table></code></div></div><p>也可以使用redis-sentinel sentinel1.conf 命令启动。 此时集群包含一个master、两个slave、三个sentinel，如图，<br /> <a href="/assets/img/it_basic/redis/redis-069.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-069.png" alt="哨兵模式" class="lazyload" data-proofer-ignore></a></p><p>我们来模拟master挂掉的场景，执行 kill -9 3017 将master进程干掉， 进入slave中执行 info replication查看，</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="o">[</span>root@dev-server-1 sentinel]# redis-cli <span class="nt">-p</span> 7001
127.0.0.1:7001&gt; auth 123456
OK
127.0.0.1:7001&gt; info replication
<span class="c"># Replication</span>
role:slave
master_host:127.0.0.1
master_port:7002
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
<span class="c"># 省略</span>
127.0.0.1:7001&gt; <span class="nb">exit</span>
<span class="o">[</span>root@dev-server-1 sentinel]# redis-cli <span class="nt">-p</span> 7002
127.0.0.1:7002&gt; auth 123456
OK
127.0.0.1:7002&gt; info replication
<span class="c"># Replication</span>
role:master
connected_slaves:1
slave0:ip<span class="o">=</span>127.0.0.1,port<span class="o">=</span>7001,state<span class="o">=</span>online,offset<span class="o">=</span>13642721,lag<span class="o">=</span>1
<span class="c"># 省略</span>
</pre></table></code></div></div><p>可以看到slave 7002已经成功上位晋升为master（role：master），接收一个slave 7001的连接。 此时查看slave2.conf配置文件，发现replicaof的配置已经被移除了， slave1.conf的配置文件里replicaof 127.0.0.1 6379 被改为 replicaof 127.0.0.1 7002。 重新启动master，也可以看到master.conf配置文件中添加了replicaof 127.0.0.1 7002的配置项， 可见大哥（master）下位后，再出来混就只能当当小弟（slave）了，三十年河东三十年河西。</p><p>哨兵模式的优缺点：</p><ul><li>优点：<ul><li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有<li>哨兵模式下，master挂掉可以自动进行切换，系统可用性更高</ul><li>缺点：<ul><li>同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置<li>需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务</ul></ul><h3 id="cluster模式"><span class="mr-2">Cluster模式</span><a href="#cluster模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题。 Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。如图<br /> <a href="/assets/img/it_basic/redis/redis-070.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-070.png" alt="redis集群" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-081.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-081.png" alt="redis集群" class="lazyload" data-proofer-ignore></a></p><p>Cluster采用无中心结构,它的特点如下：</p><ul><li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽<li>节点的fail是通过集群中超过半数的节点检测失效时才生效<li>客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</ul><p>Cluster模式的具体工作机制：</p><ul><li>在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383<li>当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数， 这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点， 然后直接自动跳转到这个对应的节点上进行存取操作<li>为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点， 当主节点宕机的时候，就会启用从节点<li>当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。 如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了</ul><p>Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作， 从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>本示例基于Redis 5.0.3版。部署步骤如下所述。 Cluster模式的部署比较简单，首先在redis.conf中</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>port 7100 <span class="c"># 本示例6个节点端口分别为7100,7200,7300,7400,7500,7600</span>
daemonize <span class="nb">yes</span> <span class="c"># r后台运行</span>
pidfile /var/run/redis_7100.pid <span class="c"># pidfile文件对应7100,7200,7300,7400,7500,7600</span>
cluster-enabled <span class="nb">yes</span> <span class="c"># 开启集群模式</span>
masterauth passw0rd <span class="c"># 如果设置了密码，需要指定master密码</span>
cluster-config-file nodes_7100.conf <span class="c"># 集群的配置文件，同样对应7100,7200等六个节点</span>
cluster-node-timeout 15000 <span class="c"># 请求超时 默认15秒，可自行设置</span>
</pre></table></code></div></div><p>分别以端口7100,7200,7300,7400,7500,7600 启动六个实例(如果是每个服务器一个实例则配置可一样)</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="o">[</span>root@dev-server-1 cluster]# redis-server redis_7100.conf
<span class="o">[</span>root@dev-server-1 cluster]# redis-server redis_7200.conf
...
</pre></table></code></div></div><p>然后通过命令将这个6个实例组成一个3主节点3从节点的集群，</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>redis-cli <span class="nt">--cluster</span> create <span class="nt">--cluster-replicas</span> 1 127.0.0.1:7100 127.0.0.1:7200 127.0.0.1:7300 127.0.0.1:7400 127.0.0.1:7500 127.0.0.1:7600 <span class="nt">-a</span> passw0rd
</pre></table></code></div></div><p>执行结果如图<br /> <a href="/assets/img/it_basic/redis/redis-071.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-071.png" alt="redis集群" class="lazyload" data-proofer-ignore></a></p><p>可以看到 7100， 7200， 7300 作为3个主节点， 分配的slot分别为 0-5460，5461-10922，10923-16383，7600作为7100的slave，7500作为7300的slave， 7400作为7200的slave。 我们连接7100设置一个值</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">[</span>root@dev-server-1 cluster]# redis-cli <span class="nt">-p</span> 7100 <span class="nt">-c</span> <span class="nt">-a</span> passw0rd
Warning: Using a password with <span class="s1">'-a'</span> or <span class="s1">'-u'</span> option on the <span class="nb">command </span>line interface may not be safe.
127.0.0.1:7100&gt; <span class="nb">set </span>site blog.jboost.cn
-&gt; Redirected to slot <span class="o">[</span>9421] located at 127.0.0.1:7200
OK
127.0.0.1:7200&gt; get site
<span class="s2">"blog.jboost.cn"</span>
127.0.0.1:7200&gt;
</pre></table></code></div></div><p>注意添加 -c 参数表示以集群模式，否则报 (error) MOVED 9421 127.0.0.1:7200 错误， 以 -a 参数指定密码，否则报(error) NOAUTH Authentication required错误。</p><p>从上面命令看到key为site算出的slot为9421，落在7200节点上， 所以有Redirected to slot [9421] located at 127.0.0.1:7200，集群会自动进行跳转。 因此客户端可以连接任何一个节点来进行数据的存取。</p><p>通过cluster nodes可查看集群的节点信息</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>127.0.0.1:7200&gt; cluster nodes
eb28aaf090ed1b6b05033335e3d90a202b422d6c 127.0.0.1:7500@17500 slave c1047de2a1b5d5fa4666d554376ca8960895a955 0 1584165266071 5 connected
4cc0463878ae00e5dcf0b36c4345182e021932bc 127.0.0.1:7400@17400 slave 5544aa5ff20f14c4c3665476de6e537d76316b4a 0 1584165267074 4 connected
dbbb6420d64db22f35a9b6fa460b0878c172a2fb 127.0.0.1:7100@17100 master - 0 1584165266000 1 connected 0-5460
d4b434f5829e73e7e779147e905eea6247ffa5a2 127.0.0.1:7600@17600 slave dbbb6420d64db22f35a9b6fa460b0878c172a2fb 0 1584165265000 6 connected
5544aa5ff20f14c4c3665476de6e537d76316b4a 127.0.0.1:7200@17200 myself,master - 0 1584165267000 2 connected 5461-10922
c1047de2a1b5d5fa4666d554376ca8960895a955 127.0.0.1:7300@17300 master - 0 1584165268076 3 connected 10923-16383
</pre></table></code></div></div><p>我们将7200通过 kill -9 pid杀死进程来验证集群的高可用， 重新进入集群执行cluster nodes可以看到7200 fail了，但是7400成了master，重新启动7200， 可以看到此时7200已经变成了slave。</p><p>Cluster模式的优缺点：</p><ul><li>优点：<ul><li>无中心架构，数据按照slot分布在多个节点。<li>集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接， 而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。<li>可线性扩展到1000多个节点，节点可动态添加或删除<li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</ul><li>缺点：<ul><li>客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”<li>节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的<li>数据通过异步复制，不保证数据的强一致性<li>slave充当“冷备”，不能缓解读压力<li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好<li>key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能<li>不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0</ul></ul><p>Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</p><h4 id="redis集群的数据分布算法哈希槽算法"><span class="mr-2">Redis集群的数据分布算法：哈希槽算法</span><a href="#redis集群的数据分布算法哈希槽算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis集群通过分布式存储的方式解决了单节点的海量数据存储的问题，对于分布式存储， 需要考虑的重点就是如何将数据进行拆分到不同的Redis服务器上。 常见的分区算法有hash算法、一致性hash算法</p><ul><li>普通hash算法：将key使用hash算法计算之后，按照节点数量来取余，即hash(key)%N。 优点就是比较简单，但是扩容或者摘除节点时需要重新根据映射关系计算，会导致数据重新迁移。<li>一致性hash算法：为每一个节点分配一个token，构成一个哈希环； 查找时先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。 优点是在加入和删除节点时只影响相邻的两个节点，缺点是加减节点会造成部分数据无法命中， 所以一般用于缓存，而且用于节点量大的情况下，扩容一般增加一倍节点保障数据负载均衡。</ul><p>Redis集群采用的算法是哈希槽分区算法。 Redis集群中有16384个哈希槽（槽的范围是 0 -16383，哈希槽）， 将不同的哈希槽分布在不同的Redis节点上面进行管理，也就是说每个Redis节点只负责一部分的哈希槽。 在对数据进行操作的时候，集群会对使用CRC16算法对key进行计算并对16384取模（slot = CRC16(key)%16383）， 得到的结果就是 Key-Value 所放入的槽，通过这个值，去找到对应的槽所对应的Redis节点， 然后直接到这个对应的节点上进行存取操作。</p><p>使用哈希槽的好处就在于可以方便的添加或者移除节点，并且无论是添加删除或者修改某一个节点， 都不会造成集群不可用的状态。当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了； 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了； 哈希槽数据分区算法具有以下几种特点：</p><ul><li>解耦数据和节点之间的关系，简化了扩容和收缩难度；<li>节点自身维护槽的映射关系，不需要客户端代理服务维护槽分区元数据<li>支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景</ul><p>槽的迁移与指派命令：<code class="language-plaintext highlighter-rouge">CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000</code>。 默认情况下，redis集群的读和写都是到master上去执行的，不支持slave节点读和写， 跟Redis主从复制下读写分离不一样，因为redis集群的核心的理念，主要是使用slave做数据的热备， 以及master故障时的主备切换，实现高可用的。Redis的读写分离， 是为了横向任意扩展slave节点去支撑更大的读吞吐量。而redis集群架构下， 本身master就是可以任意扩展的，如果想要支撑更大的读或写的吞吐量， 都可以直接对master进行横向扩展。</p><p>代码实现中，clusterNode数据结构的slots属性和numslot属性记录了节点负责处理那些槽： slots属性是一个二进制位数组(bit array)，这个数组的长度为16384/8=2048个字节， 共包含16384个二进制位。Master节点用bit来标识对于某个槽自己是否拥有，时间复杂度为O(1)。</p><p>当收到集群中其他节点发送的信息时，通过将节点槽的指派信息保存在本地的clusterState.slots数组里面， 程序要检查槽i是否已经被指派，又或者取得负责处理槽i的节点，只需要访问clusterState.slots[i]的值即可， 时间复杂度仅为O(1)。<br /> <a href="/assets/img/it_basic/redis/redis-072.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-072.png" alt="哈希结构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-073.webp" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-073.webp" alt="哈希结构" class="lazyload" data-proofer-ignore></a></p><h4 id="集群的请求重定向"><span class="mr-2">集群的请求重定向</span><a href="#集群的请求重定向" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis集群在客户端层面没有采用代理，并且无论Redis 的客户端访问集群中的哪个节点都可以路由到对应的节点上， 下面来看看 Redis 客户端是如何通过路由来调用缓存节点的：</p><ul><li>MOVED请求<br /> <a href="/assets/img/it_basic/redis/redis-074.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-074.png" alt="哈希结构" class="lazyload" data-proofer-ignore></a></ul><p>如上图所示，Redis 客户端通过 CRC16(key)%16383 计算出 Slot 的值，发现需要找“缓存节点1”进行数据操作， 但是由于缓存数据迁移或者其他原因导致这个对应的 Slot 的数据被迁移到了“缓存节点2”上面。 那么这个时候 Redis 客户端就无法从“缓存节点1”中获取数据了。 但是由于“缓存节点1”中保存了所有集群中缓存节点的信息， 因此它知道这个 Slot 的数据在“缓存节点2”中保存， 因此向 Redis 客户端发送了一个 MOVED 的重定向请求。 这个请求告诉其应该访问的“缓存节点2”的地址。Redis 客户端拿到这个地址， 继续访问“缓存节点2”并且拿到数据。<br /> <a href="/assets/img/it_basic/redis/redis-075.webp" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-075.webp" alt="哈希结构" class="lazyload" data-proofer-ignore></a> <a href="/assets/img/it_basic/redis/redis-076.webp" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-076.webp" alt="哈希结构" class="lazyload" data-proofer-ignore></a></p><ul><li>ASK请求：<br /> <a href="/assets/img/it_basic/redis/redis-077.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-077.png" alt="哈希结构" class="lazyload" data-proofer-ignore></a></ul><p>上面的例子说明了，数据 Slot 从“缓存节点1”已经迁移到“缓存节点2”了， 那么客户端可以直接找“缓存节点2”要数据。那么如果两个缓存节点正在做节点的数据迁移， 此时客户端请求会如何处理呢？</p><p>Redis 客户端向“缓存节点1”发出请求，此时“缓存节点1”正向“缓存节点 2”迁移数据， 如果没有命中对应的 Slot，它会返回客户端一个 ASK 重定向请求并且告诉“缓存节点2”的地址。 客户端向“缓存节点2”发送 Asking 命令，询问需要的数据是否在“缓存节点2”上，“缓存节点2”接到消息以后返回数据是否存在的结果。</p><ul><li>频繁重定向造成的网络开销的处理：smart客户端</ul><p>在大部分情况下，可能都会出现一次请求重定向才能找到正确的节点， 这个重定向过程显然会增加集群的网络负担和单次请求耗时。所以大部分的客户端都是smart的。 所谓 smart客户端，就是指客户端本地维护一份hashslot =&gt; node的映射表缓存， 大部分情况下，直接走本地缓存就可以找到hashslot =&gt; node，不需要通过节点进行moved重定向，</p><p>虽然ASK与MOVED都是对客户端的重定向控制，但是有本质区别。 ASK重定向说明集群正在进行slot数据迁移，客户端无法知道迁移什么时候完成， 因此只能是临时性的重定向，客户端不会更新slots缓存。 但是MOVED重定向说明键对应的槽已经明确指定到新的节点，客户端需要更新slots缓存。</p><h4 id="集群扩容和缩容"><span class="mr-2">集群扩容和缩容</span><a href="#集群扩容和缩容" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>作为分布式部署的缓存节点总会遇到缓存扩容和缓存故障的问题。这就会导致缓存节点的上线和下线的问题。 由于每个节点中保存着槽数据，因此当缓存节点数出现变动时，这些槽数据会根据对应的虚拟槽算法被迁移到其他的缓存节点上。 所以对于redis集群，集群伸缩主要在于槽和数据在节点之间移动。</p><blockquote><p>扩容</p></blockquote><ul><li>（1）启动新节点<li>（2）使用cluster meet命令将新节点加入到集群<li>（3）迁移槽和数据：添加新节点后，需要将一些槽和数据从旧节点迁移到新节点<br /> <a href="/assets/img/it_basic/redis/redis-078.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-078.png" alt="哈希结构" class="lazyload" data-proofer-ignore></a></ul><p>如上图所示，集群中本来存在“缓存节点1”和“缓存节点2”，此时“缓存节点3”上线了并且加入到集群中。 此时根据虚拟槽的算法，“缓存节点1”和“缓存节点2”中对应槽的数据会应该新节点的加入被迁移到“缓存节点3”上面。</p><p>新节点加入到集群的时候，作为孤儿节点是没有和其他节点进行通讯的。 因此需要在集群中任意节点执行 cluster meet 命令让新节点加入进来。假设新节点是 192.168.1.1 5002，老节点是 192.168.1.1 5003， 那么运行以下命令将新节点加入到集群中。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>192.168.1.1 5003&gt; cluster meet 192.168.1.1 5002
</pre></table></code></div></div><p>这个是由老节点发起的，有点老成员欢迎新成员加入的意思。新节点刚刚建立没有建立槽对应的数据， 也就是说没有缓存任何数据。如果这个节点是主节点，需要对其进行槽数据的扩容； 如果这个节点是从节点，就需要同步主节点上的数据。总之就是要同步数据。<br /> <a href="/assets/img/it_basic/redis/redis-079.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-079.png" alt="哈希结构" class="lazyload" data-proofer-ignore></a></p><p>如上图所示，由客户端发起节点之间的槽数据迁移，数据从源节点往目标节点迁移。</p><ul><li>（1）客户端对目标节点发起准备导入槽数据的命令，让目标节点准备好导入槽数据。使用命令：cluster setslot {slot} importing {sourceNodeId}<li>（2）之后对源节点发起送命令，让源节点准备迁出对应的槽数据。使用命令：cluster setslot {slot} migrating {targetNodeId}<li>（3）此时源节点准备迁移数据了，在迁移之前把要迁移的数据获取出来。通过命令 cluster getkeysinslot {slot} {count}。Count 表示迁移的 Slot 的个数。<li>（4）然后在源节点上执行，migrate {targetIP} {targetPort} “” 0 {timeout} keys {keys} 命令，把获取的键通过流水线批量迁移到目标节点。<li>（5）重复 3 和 4 两步不断将数据迁移到目标节点。<li>（6）完成数据迁移到目标节点以后，通过 cluster setslot {slot} node {targetNodeId} 命令通知对应的槽被分配到目标节点，并且广播这个信息给全网的其他主节点，更新自身的槽节点对应表。</ul><blockquote><p>缩容</p></blockquote><ul><li>迁移槽。<li>忘记节点。通过命令 cluster forget {downNodeId} 通知其他的节点<br /> <a href="/assets/img/it_basic/redis/redis-080.png" class="popup img-link "><img data-src="/assets/img/it_basic/redis/redis-080.png" alt="哈希结构" class="lazyload" data-proofer-ignore></a></ul><p>为了安全删除节点，Redis集群只能下线没有负责槽的节点。因此如果要下线有负责槽的master节点，则需要先将它负责的槽迁移到其他节点。 迁移的过程也与上线操作类似，不同的是下线的时候需要通知全网的其他节点忘记自己，此时通过命令 cluster forget {downNodeId} 通知其他的节点。</p><h4 id="集群的故障检测与故障转恢复机制"><span class="mr-2">集群的故障检测与故障转恢复机制</span><a href="#集群的故障检测与故障转恢复机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis集群的搭建可以分为以下几个部分：</p><ul><li>启动节点：将节点以集群模式启动，读取或者生成集群配置文件，此时节点是独立的。<li>节点握手：节点通过gossip协议通信，将独立的节点连成网络，主要使用meet命令。<li>槽指派：将16384个槽位分配给主节点，以达到分片保存数据库键值对的效果。</ul><p>集群搭建好之后，其是如何保证可靠性的呢？</p><h5 id="集群故障检测"><span class="mr-2">集群故障检测</span><a href="#集群故障检测" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>Redis集群的故障检测是基于gossip协议的，集群中的每个节点都会定期地向集群中的其他节点发送PING消息， 以此交换各个节点状态信息，检测各个节点状态：在线状态、疑似下线状态PFAIL、已下线状态FAIL。</p><ul><li>主观下线（pfail）：当节点A检测到与节点B的通讯时间超过了cluster-node-timeout 的时候，就会更新本地节点状态，把节点B更新为主观下线。 主观下线并不能代表某个节点真的下线了，有可能是节点A与节点B之间的网络断开了，但是其他的节点依旧可以和节点B进行通讯。<li>客观下线：</ul><p>由于集群内的节点会不断地与其他节点进行通讯，下线信息也会通过 Gossip 消息传遍所有节点，因此集群内的节点会不断收到下线报告。</p><p>当半数以上的主节点标记了节点B是主观下线时，便会触发客观下线的流程（该流程只针对主节点，如果是从节点就会忽略）。 将主观下线的报告保存到本地的 ClusterNode 的结构fail_reports链表中，并且对主观下线报告的时效性进行检查， 如果超过 cluster-node-timeout*2 的时间，就忽略这个报告，否则就记录报告内容，将其标记为客观下线。</p><p>接着向集群广播一条主节点B的Fail 消息，所有收到消息的节点都会标记节点B为客观下线。</p><h5 id="集群的故障恢复"><span class="mr-2">集群的故障恢复</span><a href="#集群的故障恢复" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>当故障节点下线后，如果是持有槽的主节点则需要在其从节点中找出一个替换它，从而保证高可用。此时下线主节点的所有从节点都担负着恢复义务， 这些从节点会定时监测主节点是否进入客观下线状态，如果是，则触发故障恢复流程。 故障恢复也就是选举一个节点充当新的master，选举的过程是基于Raft协议选举方式来实现的。</p><ul><li>从节点过滤：检查每个slave节点与master节点断开连接的时间，如果超过了cluster-node-timeout * cluster-slave-validity-factor，那么就没有资格切换成master<li>投票选举<ul><li>节点排序：对通过过滤条件的所有从节点进行排序，按照priority、offset、run id排序，排序越靠前的节点，越优先进行选举。<ul><li>priority的值越低，优先级越高<li>offset越大，表示从master节点复制的数据越多，选举时间越靠前，优先进行选举<li>如果offset相同，run id越小，优先级越高</ul><li>更新配置纪元：每个主节点会去更新配置纪元（clusterNode.configEpoch），这个值是不断增加的整数。 这个值记录了每个节点的版本和整个集群的版本。 每当发生重要事情的时候（例如：出现新节点，从节点精选）都会增加全局的配置纪元并且赋给相关的主节点， 用来记录这个事件。更新这个值目的是，保证所有主节点对这件“大事”保持一致， 大家都统一成一个配置纪元，表示大家都知道这个“大事”了。<li>选举投票：<ul><li>如果一个主节点具有投票权，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息， 表示这个主节点支持从节点成为新的主节点。每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息， 并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。<li>如果超过(N/2 + 1)数量的master节点都投票给了某个从节点，那么选举通过，这个从节点可以切换成master， 如果在 cluster-node-timeout*2 的时间内从节点没有获得足够数量的票数，本次选举作废， 更新配置纪元，并进行第二轮选举，直到选出新的主节点为止。<li>在节点排序环节领先的从节点通常会获得更多的票，因为它触发选举的时间更早一些，获得票的机会更大</ul></ul><li>替换主节点：当满足投票条件的从节点被选出来以后，会触发替换主节点的操作。删除原主节点负责的槽数据， 把这些槽数据添加到自己节点上，并且广播让其他的节点都知道这件事情，新的主节点诞生了。<ul><li>被选中的从节点执行SLAVEOF NO ONE命令，使其成为新的主节点<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己<li>新的主节点对集群进行广播PONG消息，告知其他节点已经成为新的主节点<li>新的主节点开始接收和处理槽相关的请求</ul></ul><p>如果集群中某个节点的master和slave节点都宕机了，那么集群就会进入fail状态，因为集群的slot映射不完整。 如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。</p><h4 id="集群的运维"><span class="mr-2">集群的运维</span><a href="#集群的运维" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>集群什么时候不可用？</p><ul><li>无主从备份,某一节点宕机<li>某一节点主从全部宕机<li>超半数主节点宕机</ul><p>为什么需要集群?</p><ul><li>并发量：通常来说，单台Redis能够执行10万/秒的命令，这个并发基本上能够满足我们所有需求了。 但有时候比如做离线计算，为了更快的得出结果，有时候我们希望超过这个并发，那这个时候单机就不满足我们需求了，就需要集群了。<li>数据量：通常来说，单台服务器的内存大概在16G-256G之间，前面我们说Redis数据量都是存在内存中的， 那如果实际业务要保存在Redis的数据量超过了单台机器的内存，这个时候最简单的方法是增加服务器内存。 但是单台服务器内存不可能无限制的增加，纵向扩展不了了，便想到如何进行横向扩展。 这时候我们就会想将这些业务数据分散存储在多台Redis服务器中，但是要保证多台Redis服务器能够无障碍的进行内存数据沟通，这也就是Redis集群。</ul><p>Redis cluster集群模式功能限制</p><ul><li>key批量操作支持有限。如：MSET``MGET，目前只支持具有相同slot值的key执行批量操作。<li>key事务操作支持有限。支持多key在同一节点上的事务操作，不支持分布在多个节点的事务功能。<li>key作为数据分区的最小粒度，因此不能将一个大的键值对象映射到不同的节点。如：hash、list。<li>不支持多数据库空间。单机下Redis支持16个数据库，集群模式下只能使用一个数据库空间，即db 0。<li>复制结构只支持一层，不支持嵌套树状复制结构。</ul><h5 id="数据迁移问题"><span class="mr-2">数据迁移问题</span><a href="#数据迁移问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>Redis集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。在扩缩容的时候，需要进行数据迁移。 而 Redis为了保证迁移的一致性，迁移所有操作都是同步操作，执行迁移时，两端的 Redis均会进入时长不等的阻塞状态，对于小Key， 该时间可以忽略不计，但如果一旦Key的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。</p><h5 id="带宽消耗问题"><span class="mr-2">带宽消耗问题</span><a href="#带宽消耗问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>Redis集群是无中心节点的集群架构，依靠Gossip协议协同自动化修复集群的状态，但goosip有消息延时和消息冗余的问题， 在集群节点数量过多的时候，goosip协议通信会消耗大量的带宽，主要体现在以下几个方面：</p><ul><li>消息发送频率：跟cluster-node-timeout密切相关，当节点发现与其他节点的最后通信时间超过 cluster-node-timeout/2时会直接发送ping消息<li>消息数据量：每个消息主要的数据占用包含：slots槽数组（2kb）和整个集群1/10的状态数据<li>节点部署的机器规模：机器的带宽上限是固定的，因此相同规模的集群分布的机器越多，每台机器划分的节点越均匀，则整个集群内整体的可用带宽越高</ul><p>集群带宽消耗主要分为：读写命令消耗+Gossip消息消耗，因此搭建Redis集群需要根据业务数据规模和消息通信成本做出合理规划：</p><ul><li>在满足业务需求的情况下尽量避免大集群，同一个系统可以针对不同业务场景拆分使用若干个集群。<li>适度提供cluster-node-timeout降低消息发送频率，但是cluster-node-timeout还影响故障转移的速度，因此需要根据自身业务场景兼顾二者平衡<li>如果条件允许尽量均匀部署在更多机器上，避免集中部署。如果有60个节点的集群部署在3台机器上每台20个节点，这是机器的带宽消耗将非常严重</ul><h5 id="pubsub广播问题"><span class="mr-2">Pub/Sub广播问题</span><a href="#pubsub广播问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>集群模式下内部对所有publish命令都会向所有节点进行广播，加重带宽负担，所以集群应该避免频繁使用Pub/sub功能</p><h5 id="集群倾斜"><span class="mr-2">集群倾斜</span><a href="#集群倾斜" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>集群倾斜是指不同节点之间数据量和请求量出现明显差异，这种情况将加大负载均衡和开发运维的难度。因此需要理解集群倾斜的原因</p><ul><li>数据倾斜：<ul><li>节点和槽分配不均<li>不同槽对应键数量差异过大<li>集合对象包含大量元素<li>内存相关配置不一致</ul><li>请求倾斜：合理设计键，热点大集合对象做拆分或者使用hmget代替hgetall避免整体读取</ul><h5 id="集群读写分离"><span class="mr-2">集群读写分离</span><a href="#集群读写分离" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>集群模式下读写分离成本比较高，直接扩展主节点数量来提高集群性能是更好的选择。</p><h3 id="参考文档-3"><span class="mr-2">参考文档</span><a href="#参考文档-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><a href="https://www.bbsmax.com/A/qVdeE9pQdP/">一文掌握Redis的三种集群方案</a><li><a href="https://www.cnblogs.com/wzh2010/p/15886799.html">深入分析Cluster 集群模式</a><li><a href="https://zhuanlan.zhihu.com/p/543831926">你必须知道的4种 Redis 集群方案及优缺点对比</a><li><a href="https://zhuanlan.zhihu.com/p/511199672">Redis Cluster数据分片实现原理、及请求路由实现</a><li><a href="https://blog.csdn.net/gaoliang1719/article/details/126576919">Redis集群Gosisp协议与节点通信</a><li><a href="https://blog.csdn.net/makyan/article/details/104798725?spm=1001.2101.3001.6650.13&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-13-104798725-blog-126673703.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-13-104798725-blog-126673703.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=19">集群通信</a><li><a href="https://zhuanlan.zhihu.com/p/500729124">Redis高可用架构—Redis集群（Redis Cluster）详细介绍</a></ul><h1 id="redis-故障及调优">redis 故障及调优</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1816852">Redis 故障诊断及常用运维命令—内存篇</a><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247543634&amp;idx=2&amp;sn=d34c35f4337c319f5c7bbfd04b64fbe7&amp;chksm=fbb1a2acccc62bbaca1449a3c3a2cfccdb5e244bfa4b1b7c7eb42920f50b4bacfe6aa14a5820&amp;scene=27">3大问题！Redis缓存异常及处理方案总结</a><li><a href="https://www.cnblogs.com/knqiufan/articles/16212519.html">Redis的三大缓存异常原因分析和解决方案</a><li><a href="https://blog.csdn.net/wx17343624830/article/details/125870883">Redis常见的故障以及发生场景</a><li><a href="https://blog.csdn.net/real_fxy/article/details/126068480">Redis中常见的问题以及解决方案</a><li><a href="http://www.zuidaima.com/blog/3446249950399488.htm">redis线上环境挂机导致的服务崩溃的故障记录</a><li><a href="https://www.jianshu.com/p/90e8f76257ad">redis故障修复</a><li><a href="https://blog.csdn.net/wf_feng/article/details/121046703?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-121046703-blog-122819459.pc_relevant_3mothn_strategy_recovery&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">Redis的性能问题总结、排查及调优</a><li><a href="https://huaweicloud.csdn.net/637eedf3df016f70ae4c9bdf.html?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-3-121836678-blog-117423025.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-3-121836678-blog-117423025.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=4">Redis性能优化</a></ul><h1 id="redis-综合">redis 综合</h1><p>可参见以下系列文章</p><ul><li><a href="https://blog.csdn.net/m0_50662680/article/details/111039927">一文让你彻底了解Redis(进阶)，史上最全,不看后悔！！！【建议收藏】</a>、<li><a href="https://segmentfault.com/a/1190000022922176">Redis 整理 一文全</a>、<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;mid=2247488119&amp;idx=1&amp;sn=af143b418f9777be99e8f392565e0f66&amp;chksm=fcd8de36cbaf57207261155bc3cd2fb6640ee54581c010ae45083de94e9e68e933a6b5b0228c&amp;scene=27">用Redis实现分布式锁的血泪史</a></ul><h1 style="visibility: hidden;" id="want-cmm"> 我要评论</h1></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=redis%20%E6%9D%82%E8%B0%88%20-%20Code-Winder&url=%2F%2Fcode-winder.github.io%2F2016%2F07%2Fredis.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=redis%20%E6%9D%82%E8%B0%88%20-%20Code-Winder&u=%2F%2Fcode-winder.github.io%2F2016%2F07%2Fredis.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2F%2Fcode-winder.github.io%2F2016%2F07%2Fredis.html&text=redis%20%E6%9D%82%E8%B0%88%20-%20Code-Winder" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/it-basic/">IT_Basic</a> <a class="post-tag" href="/tags/tool/">Tool</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/it-basic/">IT-Basic</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/vim/">Vim</a></div></div></div><script> (function() { $("#content-list").click(function(event){ var e=window.event || event; if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } if($('#markdown-toc').is(':hidden')){ $('#markdown-toc').show(); }else{ $('#markdown-toc').hide(); } }); $("#markdown-toc").click(function(event){ var e=window.event || event; if(e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } }); $(document).click(function(event) { $("#markdown-toc").hide(); }); }()); </script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"><ul class="nav navbar-nav"><li><a href="#redis-架构" class="nav-link">redis 架构</a><ul class="nav navbar-nav"><li><a href="#应用架构演化" class="nav-link">应用架构演化</a><li><a href="#redis-自身架构演化" class="nav-link">Redis 自身架构演化</a></ul><li><a href="#redis-模块" class="nav-link">redis 模块</a><ul class="nav navbar-nav"><li><a href="#线程模型" class="nav-link">线程模型</a><ul class="nav navbar-nav"><li><a href="#单线程模型" class="nav-link">单线程模型</a><li><a href="#多线程模型" class="nav-link">多线程模型</a></ul></ul><li><a href="#redis-应用" class="nav-link">redis 应用</a><ul class="nav navbar-nav"><li><a href="#典型应用场景" class="nav-link">典型应用场景</a><li><a href="#数据类型及相关命令" class="nav-link">数据类型及相关命令</a></ul><li><a href="#redis-实现原理" class="nav-link">redis 实现原理</a><ul class="nav navbar-nav"><li><a href="#底层数据结构" class="nav-link">底层数据结构</a><ul class="nav navbar-nav"><li><a href="#底层数据结构概述" class="nav-link">底层数据结构概述</a><li><a href="#sds简单动态字符串存储结构" class="nav-link">SDS(简单动态字符串存储结构)</a><li><a href="#链表" class="nav-link">链表</a><li><a href="#压缩列表" class="nav-link">压缩列表</a><li><a href="#哈希表" class="nav-link">哈希表</a><ul class="nav navbar-nav"><li><a href="#哈希表结构设计" class="nav-link">哈希表结构设计</a><li><a href="#哈希冲突" class="nav-link">哈希冲突</a></ul><li><a href="#整数集合" class="nav-link">整数集合</a><ul class="nav navbar-nav"><li><a href="#整数集合结构设计" class="nav-link">整数集合结构设计</a><li><a href="#整数集合的升级操作" class="nav-link">整数集合的升级操作</a></ul><li><a href="#跳表" class="nav-link">跳表</a><ul class="nav navbar-nav"><li><a href="#跳表结构设计" class="nav-link">跳表结构设计</a><li><a href="#跳表节点查询过程" class="nav-link">跳表节点查询过程</a><li><a href="#跳表节点层数设置" class="nav-link">跳表节点层数设置</a></ul><li><a href="#quicklist" class="nav-link">quicklist</a><li><a href="#listpack" class="nav-link">listpack</a><li><a href="#rax前缀树" class="nav-link">rax(前缀树)</a><li><a href="#stream" class="nav-link">stream</a><ul class="nav navbar-nav"><li><a href="#添加消息" class="nav-link">添加消息</a><li><a href="#删除消息" class="nav-link">删除消息</a><li><a href="#参考文档" class="nav-link">参考文档</a></ul></ul><li><a href="#redis-源码导读" class="nav-link">redis 源码导读</a></ul><li><a href="#redis-通信协议" class="nav-link">redis 通信协议</a><ul class="nav navbar-nav"><li><a href="#resp2" class="nav-link">RESP2</a><ul class="nav navbar-nav"><li><a href="#简单字符串" class="nav-link">简单字符串</a><li><a href="#错误" class="nav-link">错误</a><li><a href="#整型" class="nav-link">整型</a><li><a href="#批量字符串" class="nav-link">批量字符串</a><li><a href="#数组" class="nav-link">数组</a><li><a href="#数组中的空元素" class="nav-link">数组中的空元素</a><li><a href="#多命令和管道" class="nav-link">多命令和管道</a><li><a href="#内联命令" class="nav-link">内联命令</a><li><a href="#高性能-redis-协议解析器" class="nav-link">高性能 Redis 协议解析器</a><li><a href="#参考文档-1" class="nav-link">参考文档</a></ul><li><a href="#resp3" class="nav-link">RESP3</a><ul class="nav navbar-nav"><li><a href="#与resp2兼容" class="nav-link">与RESP2兼容</a><ul class="nav navbar-nav"><li><a href="#请求格式" class="nav-link">请求格式</a><li><a href="#simple-string" class="nav-link">Simple string</a><li><a href="#simple-error" class="nav-link">Simple error</a><li><a href="#number" class="nav-link">Number</a><li><a href="#blob-string" class="nav-link">Blob string</a><li><a href="#array" class="nav-link">Array</a></ul><li><a href="#resp3中新的类型" class="nav-link">RESP3中新的类型</a><ul class="nav navbar-nav"><li><a href="#null" class="nav-link">Null</a><li><a href="#double" class="nav-link">Double</a><li><a href="#boolean" class="nav-link">Boolean</a><li><a href="#blob-error" class="nav-link">Blob error</a><li><a href="#verbatim-string" class="nav-link">Verbatim string</a><li><a href="#big-number" class="nav-link">Big number</a><li><a href="#aggregate-data-types" class="nav-link">Aggregate data types</a><li><a href="#map" class="nav-link">Map</a><li><a href="#set" class="nav-link">Set</a><li><a href="#attribute" class="nav-link">Attribute</a><li><a href="#push" class="nav-link">Push</a><li><a href="#stream-1" class="nav-link">Stream</a><li><a href="#hello" class="nav-link">HELLO</a><li><a href="#参考文档-2" class="nav-link">参考文档</a></ul></ul><li><a href="#gossip" class="nav-link">gossip</a></ul><li><a href="#redis-集群" class="nav-link">redis 集群</a><ul class="nav navbar-nav"><li><a href="#集群部署方案" class="nav-link">集群部署方案</a><ul class="nav navbar-nav"><li><a href="#主从复制模式" class="nav-link">主从复制模式</a><li><a href="#sentinel哨兵模式" class="nav-link">Sentinel（哨兵）模式</a><li><a href="#cluster模式" class="nav-link">Cluster模式</a><ul class="nav navbar-nav"><li><a href="#redis集群的数据分布算法哈希槽算法" class="nav-link">Redis集群的数据分布算法：哈希槽算法</a><li><a href="#集群的请求重定向" class="nav-link">集群的请求重定向</a><li><a href="#集群扩容和缩容" class="nav-link">集群扩容和缩容</a><li><a href="#集群的故障检测与故障转恢复机制" class="nav-link">集群的故障检测与故障转恢复机制</a><ul class="nav navbar-nav"><li><a href="#集群故障检测" class="nav-link">集群故障检测</a><li><a href="#集群的故障恢复" class="nav-link">集群的故障恢复</a></ul><li><a href="#集群的运维" class="nav-link">集群的运维</a><ul class="nav navbar-nav"><li><a href="#数据迁移问题" class="nav-link">数据迁移问题</a><li><a href="#带宽消耗问题" class="nav-link">带宽消耗问题</a><li><a href="#pubsub广播问题" class="nav-link">Pub/Sub广播问题</a><li><a href="#集群倾斜" class="nav-link">集群倾斜</a><li><a href="#集群读写分离" class="nav-link">集群读写分离</a></ul></ul><li><a href="#参考文档-3" class="nav-link">参考文档</a></ul></ul><li><a href="#redis-故障及调优" class="nav-link">redis 故障及调优</a><li><a href="#redis-综合" class="nav-link">redis 综合</a><li><a href="#want-cmm" class="nav-link"> 我要评论 </a></ul></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/2016/07/mysql.html"><div class="card-body"> <em class="small" data-ts="1467591945" data-df="YYYY/MM/DD" > 2016/07/04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL 杂谈</h3><div class="text-muted small"><p> 本文主要介绍 MySQL 相关的一些理论知识、实践经验和验证实验。 基本概念 MySQL 基本框架图 SQL 语句 数据库连接 语句执行流程 查询语句执行流程 查询状态 查询优化 ...</p></div></div></a></div><div class="card"> <a href="/2023/03/etcd.html"><div class="card-body"> <em class="small" data-ts="1677711925" data-df="YYYY/MM/DD" > 2023/03/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>etcd 杂谈</h3><div class="text-muted small"><p> 本文主要对 ETCD 的相关资料进行收集，以备查阅和整理。 架构简介 etcd 应用 典型应用场景 常用工具和命令 etcd 实现原理 通讯协议 etcd 集群 etcd 故障及调优 etcd 综合 etcd 源码和常见面试题 架构简介 etcd 架构原理学习（来自etcd实战） et...</p></div></div></a></div><div class="card"> <a href="/2016/07/kafka.html"><div class="card-body"> <em class="small" data-ts="1467765411" data-df="YYYY/MM/DD" > 2016/07/06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>kafka 杂谈</h3><div class="text-muted small"><p> 本文主要介绍 kafka 相关的一些理论知识、实践经验和验证实验。 架构简介 kafka 应用 典型应用场景 常用工具和命令 kafka 实现原理 通讯协议 kafka 集群 kafka 故障及调优 kafka 综合 kafka 常见面试题 架构简介 Kafka系列3-Kafka架构 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/2016/07/kafka.html" class="btn btn-outline-primary" prompt="上一篇"><p>kafka 杂谈</p></a> <a href="/2016/07/vim-skill.html" class="btn btn-outline-primary" prompt="下一篇"><p>vim 常规操作</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">Cpp</a> <a class="post-tag" href="/tags/it-basic/">IT_Basic</a> <a class="post-tag" href="/tags/tool/">Tool</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/go/">Go</a> <a class="post-tag" href="/tags/it-basic/">IT-Basic</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/vim/">Vim</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/code-winder">code-winder</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div style="text-align:center;width: 90%;"><p class="mb-0"> 总访问量 <span id="busuanzi_value_site_pv" style="color: blue;"></span> ，访客数 <span id="busuanzi_value_site_uv" style="color: blue;"></span> ，本文总阅读量 <span id="busuanzi_value_page_pv" style="color: blue;"> </span></p></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1.11.6/dayjs.min.js,npm/dayjs@1.11.6/locale/zh.min.js,npm/dayjs@1.11.6/plugin/relativeTime.min.js,npm/dayjs@1.11.6/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-72449510-4"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-72449510-4'); }); </script>
